
import CodeGen.Engine
import CodeGen.RepositoryAPI
import HarmonyCoreGenerator.Model
import Microsoft.Win32
import Newtonsoft.Json
import System
import System.Collections.Generic
import System.Collections.ObjectModel
import System.IO
import System.Linq
import System.Windows
import System.Windows.Input

.array 0

namespace HarmonyCoreGenerator.ViewModel
    
    public class GeneratorViewModel extends ViewModelBase
        
.region "Data binding properties"
        
        private _SolutionFile, string
        
        public property SolutionFile, string
            method get
            proc
                mreturn _SolutionFile
            endmethod
            method set
            proc
                if (_SolutionFile == ^null || !_SolutionFile.Equals(value))
                begin
                    _SolutionFile = value
                    NotifyPropertyChanged(^nameof(SolutionFile))
                end
            endmethod
        endproperty

        private _SolutionFolder, string

        public property SolutionFolder, string
            method get
            proc
                mreturn _SolutionFolder
            endmethod
            method set
            proc
                if (_SolutionFolder == ^null || !_SolutionFolder.Equals(value))
                begin
                    _SolutionFolder = value
                    NotifyPropertyChanged(^nameof(SolutionFolder))
                end
            endmethod
        endproperty

        private _SettingsFile, string

        public property SettingsFile, string
            method get
            proc
                mreturn _SettingsFile
            endmethod
            method set
            proc
                if (_SettingsFile == ^null || !_SettingsFile.Equals(value))
                begin
                    _SettingsFile = value
                    NotifyPropertyChanged(^nameof(SettingsFile))
                end
            endmethod
        endproperty

        private _TasksetFile, string

        public property TasksetFile, string
            method get
            proc
                mreturn _TasksetFile
            endmethod
            method set
            proc
                if (_TasksetFile == ^null || !_TasksetFile.Equals(value))
                begin
                    _TasksetFile = value
                    NotifyPropertyChanged(^nameof(TasksetFile))
                end
            endmethod
        endproperty

        private _SolutionOpen, boolean
        
        public property SolutionOpen, boolean
            method get
            proc
                mreturn _SolutionOpen
            endmethod
            method set
            proc
                if (_SolutionOpen != value)
                begin
                    _SolutionOpen = value
                    NotifyPropertyChanged(^nameof(SolutionOpen))
                end
            endmethod
        endproperty
        
        private _Options, @HarmonyCoreOptions
        
        public property Options, @HarmonyCoreOptions
            method get
            proc
                mreturn _Options
            endmethod
            method set
            proc
                if (_Options != value)
                begin
                    _Options = value
                    NotifyPropertyChanged(^nameof(Options))
                end
            endmethod
        endproperty
        
        private _SelectedTabIndex, int
        
        public property SelectedTabIndex, int
            method get
            proc
                mreturn _SelectedTabIndex
            endmethod
            method set
            proc
                if (_SelectedTabIndex != value)
                begin
                    _SelectedTabIndex = value
                    NotifyPropertyChanged(^nameof(SelectedTabIndex))
                end
            endmethod
        endproperty
        
        private _CodeGenOutput, @ObservableCollection<string>
        
        public property CodeGenOutput, @ObservableCollection<string>
            method get
            proc
                mreturn _CodeGenOutput
            endmethod
            method set
            proc
                if (_CodeGenOutput != value)
                begin
                    _CodeGenOutput = value
                    NotifyPropertyChanged(^nameof(CodeGenOutput))
                end
            endmethod
        endproperty
        
        private _SelectedStructure, @StructureRow
        
        public property SelectedStructure, @StructureRow
            method get
            proc
                mreturn _SelectedStructure
            endmethod
            method set
            proc
                if ((_SelectedStructure == ^null) || (_SelectedStructure != value))
                begin
                    _SelectedStructure = value
                    NotifyPropertyChanged(^nameof(SelectedStructure))
                end
            endmethod
        endproperty
        
        private _CodeGenLoggingLevel, LoggingLevel, LoggingLevel.Normal
        
        public property CodeGenLoggingLevel, LoggingLevel
            method get
            proc
                mreturn _CodeGenLoggingLevel
            endmethod
            method set
            proc
                if (_CodeGenLoggingLevel != value)
                begin
                    _CodeGenLoggingLevel = value
                    NotifyPropertyChanged(^nameof(CodeGenLoggingLevel))
                end
            endmethod
        endproperty
        
        private _StatusBarText, string, String.Empty
        
        public property StatusBarText, string
            method get
            proc
                mreturn _StatusBarText
            endmethod
            method set
            proc
                if (!_StatusBarText.Equals(value))
                begin
                    _StatusBarText = value
                    NotifyPropertyChanged(^nameof(StatusBarText))
                end
            endmethod
        endproperty

.endregion
        
.region "OpenSolutionCommand"
        
        private _OpenSolutionCommand, @ICommand
        
        public property OpenSolutionCommand, @ICommand
            method get
            proc
                lambda generated_lambda1(param)
                begin
                    openSolution()
                end
                if (_OpenSolutionCommand == ^null)
                    _OpenSolutionCommand = new RelayCommand(generated_lambda1)
                mreturn _OpenSolutionCommand
            endmethod
        endproperty
        
.endregion
        
.region "CloseSolutionCommand"
        
        private _CloseSolutionCommand, @ICommand
        
        public property CloseSolutionCommand, @ICommand
            method get
            proc
                lambda execute(param)
                begin
                    closeSolution()
                end
                lambda canExecute(param)
                begin
                    mreturn _SolutionOpen
                end
                if (_CloseSolutionCommand == ^null)
                    _CloseSolutionCommand = new RelayCommand(execute, canExecute)
                mreturn _CloseSolutionCommand
            endmethod
        endproperty
        
.endregion
        
.region "SaveSettingsCommand"
        
        private _SaveSettingsCommand, @ICommand
        
        public property SaveSettingsCommand, @ICommand
            method get
            proc
                lambda execute(param)
                begin
                    saveSettings()
                end
                lambda canExecute(param)
                begin
                    mreturn _SolutionOpen
                end
                if (_SaveSettingsCommand == ^null)
                    _SaveSettingsCommand = new RelayCommand(execute, canExecute)
                mreturn _SaveSettingsCommand
            endmethod
        endproperty
        
.endregion
        
.region "RefreshRepositoryCommand"
        
        private _RefreshRepositoryCommand, @ICommand
        
        public property RefreshRepositoryCommand, @ICommand
            method get
            proc
                lambda execute(param)
                begin
                    refreseRepository()
                end
                lambda canExecute(param)
                begin
                    mreturn _SolutionOpen
                end
                if (_RefreshRepositoryCommand == ^null)
                    _RefreshRepositoryCommand = new RelayCommand(execute, canExecute)
                mreturn _RefreshRepositoryCommand
            endmethod
        endproperty
        
.endregion
        
.region "GenerateCodeCommand"
        
        private _GenerateCodeCommand, @ICommand
        
        public property GenerateCodeCommand, @ICommand
            method get
            proc
                lambda execute(param)
                begin
                    generateCode()
                end
                lambda canExecute(param)
                begin
                    mreturn _SolutionOpen
                end
                if (_GenerateCodeCommand == ^null)
                    _GenerateCodeCommand = new RelayCommand(execute, canExecute)
                mreturn _GenerateCodeCommand
            endmethod
        endproperty
        
.endregion
        
.region "ExitCommand"
        
        private _ExitCommand, @ICommand
        
        public property ExitCommand, @ICommand
            method get
            proc
                lambda generated_lambda10(param)
                begin
                    Environment.^id("Exit")(0)
                end
                if (_ExitCommand == ^null)
                    _ExitCommand = new RelayCommand(generated_lambda10)
                mreturn _ExitCommand
            endmethod
        endproperty
        
.endregion
        
.region "Helper Methods"
        
        private method openSolution, void
        proc
            if (_SolutionOpen)
                closeSolution()

            data dlg = new OpenFileDialog()

            ;; If we have a last folder, use it
            data lastFolder = Properties.Settings.Default.LastFolder
            if (!String.IsNullOrWhiteSpace(lastFolder) && Directory.Exists(lastFolder))
                dlg.InitialDirectory = lastFolder

            dlg.Filter = "Solution Files (*.sln)|*.sln"
            dlg.CheckFileExists = true
            dlg.Multiselect = false

            ;;Show the dialog
            data result, Nullable<boolean>, dlg.ShowDialog()

            if (result == true)
            begin
                SolutionFile = dlg.FileName
                SolutionFolder = Path.GetDirectoryName(_SolutionFile)
                SettingsFile = Path.Combine(Path.GetDirectoryName(_SolutionFile), Path.GetFileNameWithoutExtension(_SolutionFile) + ".hcproj")
                TasksetFile = Path.Combine(Path.GetDirectoryName(_SolutionFile), Path.GetFileNameWithoutExtension(_SolutionFile) + ".codegen")

                ;;Make sure we're in the solution folder
                Directory.SetCurrentDirectory(_SolutionFolder)

                data errors = new List<string>()
                data temp, string

                if (File.Exists(_SettingsFile)) then
                begin
                    ;; Load existing settings file
                    data settingsJson = File.ReadAllText(_SettingsFile)
                    Options = JsonConvert.DeserializeObject<HarmonyCoreOptions>(settingsJson)
                    Options.TrackChanges = true

                    ;; Repository files
                    if (!File.Exists(Options.RepositoryMainFile))
                        errors.Add("File 'rpsmain.ism' was not found in the expected location!")
                    if (!File.Exists(Options.RepositoryTextFile))
                        errors.Add("File 'rpstext.ism' was not found in the expected location!")

                    ;; User tokens file should be in the solution folder
                    if (!File.Exists(Options.UserTokensFile))
                        errors.Add("File 'UserDefinedTokens.tkn' was not found in the solution directory!")

                    ;; Verify the services folder is present
                    if (!Directory.Exists(Options.ServicesFolder))
                        errors.Add("Folder 'Services' was not found in the solution directory!")

                    ;; Verify the controllers folder is present
                    if (!Directory.Exists(Options.ControllersFolder))
                        errors.Add("Folder 'Services.Controllers' was not found in the solution directory!")

                    ;; Verify the self host folder is present
                    if (!Directory.Exists(Options.SelfHostFolder))
                        errors.Add("Folder 'Services.Host' was not found in the solution directory!")

                    ;; Verify the isolated folder is present
                    if (!Directory.Exists(Options.IsolatedFolder))
                        errors.Add("Folder 'Services.Isolated' was not found in the solution directory!")

                    ;; Verify the models folder is present
                    if (!Directory.Exists(Options.ModelsFolder))
                        errors.Add("Folder 'Services.Models' was not found in the solution directory!")

                    ;; Do we have a unit tests folder?
                    if (!String.IsNullOrWhiteSpace(Options.UnitTestFolder))
                        if (!Directory.Exists(Options.UnitTestFolder))
                            errors.Add("Unit test " + %char(12) + "older was not found!")

                    ;; Templates folder should be right below the solution folder.
                    if (!Directory.Exists(Options.TemplatesFolder))
                        errors.Add("Folder 'Templates' was not found in the solution directory!")

                    ;; For existing projects, shjow the code generation page
                    if (errors.Count == 0)
                        SelectedTabIndex = 3
                end
                else
                begin
                    ;; No settings file, start from scratch
                    Options = new HarmonyCoreOptions()
                    Options.TrackChanges = true

                    ;; TODO: For now we're assuming the repository project is in "schema centric" mode and Debug mode is being used

                    ;; Repository files
                    temp = Path.Combine(_SolutionFolder, "Repository", "bin", "Debug", "rpsmain.ism")
                    if (File.Exists(temp)) then
                        Options.RepositoryMainFile = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("File 'rpsmain.ism' was not found in the expected location!")

                    temp = Path.Combine(_SolutionFolder, "Repository", "bin", "Debug", "rpstext.ism")

                    if (File.Exists(temp)) then
                        Options.RepositoryTextFile = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("File 'rpstext.ism' was not found in the expected location!")

                    ;; User tokens file should be in the solution folder
                    temp = Path.Combine(_SolutionFolder, "UserDefinedTokens.tkn")
                    if (File.Exists(temp)) then
                        Options.UserTokensFile = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("File 'UserDefinedTokens.tkn' was not found in the solution directory!")

                    ;; Verify the services folder is present
                    temp = Path.Combine(_SolutionFolder, "Services")
                    if (Directory.Exists(temp)) then
                        Options.ServicesFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("Folder 'Services' was not found in the solution directory!")

                    ;; Verify the controllers folder is present
                    temp = Path.Combine(_SolutionFolder, "Services.Controllers")
                    if (Directory.Exists(temp)) then
                        Options.ControllersFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("Folder 'Services.Controllers' was not found in the solution directory!")

                    ;; Verify the self host folder is present
                    temp = Path.Combine(_SolutionFolder, "Services.Host")
                    if (Directory.Exists(temp)) then
                        Options.SelfHostFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("Folder 'Services.Host' was not found in the solution directory!")

                    ;; Verify the isolated folder is present
                    temp = Path.Combine(_SolutionFolder, "Services.Isolated")
                    if (Directory.Exists(temp)) then
                        Options.IsolatedFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("Folder 'Services.Isolated' was not found in the solution directory!")

                    ;; Verify the models folder is present
                    temp = Path.Combine(_SolutionFolder, "Services.Models")
                    if (Directory.Exists(temp)) then
                        Options.ModelsFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("Folder 'Services.Models' was not found in the solution directory!")

                    ;; Do we have a unit tests folder?
                    temp = Path.Combine(_SolutionFolder, "Services.Test")
                    if (Directory.Exists(temp)) then
                        Options.UnitTestFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        Options.UnitTestFolder = String.Empty

                    ;; Load the repository
                    if (errors.Count == 0)
                    begin
                        data rps = new Repository(Options.RepositoryMainFile, Options.RepositoryTextFile, false)
                        begin
                            data str, @RpsStructure
                            foreach str in rps.Structures
                                Options.Structures.Add(new StructureRow(str))
                        end
                        ;; For new projects, show the structure selection page
                        if (errors.Count == 0)
                            SelectedTabIndex = 1
                    end

                    ;; Templates folder should be right below the solution folder.
                    temp = Path.Combine(_SolutionFolder, "Templates")
                    if (Directory.Exists(temp)) then
                        Options.TemplatesFolder = FileTools.GetRelativePath(_SolutionFolder,temp)
                    else
                        errors.Add("Folder 'Templates' was not found in the solution directory!")
                end

                if (errors.Count == 0) then
                begin
                    if (Options.Structures.Count > 0)
                        SelectedStructure = Options.Structures.First()

                    ;; Save the last used folder
                    Properties.Settings.Default.LastFolder = Path.GetDirectoryName(_SolutionFile)
                    Properties.Settings.Default.Save()
                    SolutionOpen = true
                end
                else
                begin
                    data message = "The solution configuration was not as expected"
                    data error, string
                    foreach error in errors
                        message = message + Environment.NewLine + " - " + error

                    MessageBox.Show(message, "Unsupported Configuration", MessageBoxButton.OK, MessageBoxImage.Exclamation)

                    ;; Clear things down so the UI is blank
                    SolutionFile = String.Empty
                    SolutionFolder = String.Empty
                    SettingsFile = String.Empty
                    TasksetFile = String.Empty
                    Options = new HarmonyCoreOptions()
                end
            end
        endmethod
        
        private method closeSolution, void
        proc
            if (_SolutionOpen)
            begin
                if (Options.UnsavedChanges)
                begin
                    if (MessageBox.Show("Save changes before closing the solution?", "Unsaved Changes", MessageBoxButton.YesNo, MessageBoxImage.Question, MessageBoxResult.Yes) == MessageBoxResult.Yes)
                    begin
                        saveSettings()
                    end
                end

                SolutionOpen = false
                SolutionFile = String.Empty
                SettingsFile = String.Empty
                CodeGenOutput = new ObservableCollection<string>()
                Options = new HarmonyCoreOptions()
                SelectedTabIndex = 0
            end
        endmethod
        
        private method saveSettings, void
        proc
            try
            begin
                File.WriteAllText(_SettingsFile, JsonConvert.SerializeObject(Options, Formatting.Indented))
                Options.ChangesSaved()
            end
            catch (ex, @Exception)
            begin
                MessageBox.Show("Failed to save settings! Error was " + ex.Message)
            end
            endtry
        endmethod
        
        private method refreseRepository, void
        proc
            ;; Ensure the code generation page is visible
            if (SelectedTabIndex != 1)
                SelectedTabIndex = 1
            MessageBox.Show("You wish!")
        endmethod
        
        private method generateCode, void
        proc
            ;; Ensure the code generation page is visible
            if (SelectedTabIndex != 3)
                SelectedTabIndex = 3

            ;;Make sure we're in the solution folder
            Directory.SetCurrentDirectory(_SolutionFolder)

            StatusBarText = "Generating code..."

            CodeGenOutput = new ObservableCollection<string>()

            data taskset = new CodeGenTaskSet()
            &    {
            &    Description = "Code generation tasks for Harmony Core solution.",
            &    RepositoryMainFile = Options.RepositoryMainFile,
            &    RepositoryTextFile = Options.RepositoryTextFile,
            &    TemplateFolder = Options.TemplatesFolder,
            &    EchoCommands = true,
            &    ListGeneratedFiles = true,
            &    LoggingLevel = CodeGenLoggingLevel
            &    }
            setDefines(taskset)
            data task, @CodeGenTask

            ;; Create a task to generate model and metadata classes

            task = new CodeGenTask()
            task.Description = "Generate model and metadata classes"
            task.Templates.Add("ODataModel")
            task.Templates.Add("ODataMetaData")
            task.OutputFolder = Options.ModelsFolder
            task.Namespace = "Services.Models"
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addCustomCodeStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; Create a task to generate controller classes

            task = new CodeGenTask()
            task.Description = "Generate controller classes"
            task.Templates.Add("ODataController")
            task.OutputFolder = Options.ControllersFolder
            task.Namespace = "Services.Controllers"
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; Create a task to generate the DBContext class

            task = new CodeGenTask()
            task.Description = "Generate the DBContext class"
            task.Templates.Add("ODataDbContext")
            task.OutputFolder = Options.ModelsFolder
            task.Namespace = "Services.Models"
            task.MultipleStructures = true
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; Create a task to generate the EdbBuilder and Startup classes

            task = new CodeGenTask()
            task.Description = "Generate the EdbBuilder and Startup classes"
            task.Templates.Add("ODataEdmBuilder")
            task.Templates.Add("ODataStartup")
            task.OutputFolder = Options.ServicesFolder
            task.Namespace = "Services"
            task.MultipleStructures = true
            task.UserTokens.Add(new UserToken("CONTROLLERS_NAMESPACE", "Services.Controllers"))
            task.UserTokens.Add(new UserToken("MODELS_NAMESPACE", "Services.Models"))
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; Create a task to generate self hosting program and environment

            if (Options.GenerateSelfHost)
            begin
                task = new CodeGenTask()
                task.Description = "Generate self hosting program and environment"
                task.Templates.Add("ODataSelfHost")
                task.Templates.Add("ODataSelfHostEnvironment")
                task.OutputFolder = Options.SelfHostFolder
                task.Namespace = "Services.Host"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                ;; TODO: if we have a parameter file structure we need to add that here also
                addStandardOptions(task)
                taskset.Tasks.Add(task)
            end

            ;; Create tasks to generate swagger docs

            if (Options.GenerateSwaggerDocs)
            begin
                task = new CodeGenTask()
                task.Description = "Generate swagger documentation"
                task.Templates.Add("ODataSwaggerYaml")
                task.OutputFolder = Path.Combine(Options.ServicesFolder, "wwwroot")
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                task = new CodeGenTask()
                task.Description = "Generate swagger complex types documentation"
                task.Templates.Add("ODataSwaggerType")
                task.OutputFolder = Path.Combine(Options.ServicesFolder, "wwwroot")
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)
            end

            ;; Create a task to generate Postman tests

            if (Options.GeneratePostmanTests)
            begin
                task = new CodeGenTask()
                task.Description = "Generate Postman tests"
                task.Templates.Add("ODataPostManTests")
                task.OutputFolder = _SolutionFolder
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)
            end

            ;; Create tass to generatea unit test environment

            if (Options.GenerateUnitTests)
            begin
                task = new CodeGenTask()
                task.Description = "Generate client-side models, data loaders and unit tests"
                task.Templates.Add("ODataClientModel")
                task.Templates.Add("ODataTestDataLoader")
                task.Templates.Add("ODataUnitTests")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                task = new CodeGenTask()
                task.Description = "Generate test environment"
                task.Templates.Add("ODataTestEnvironment")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                ;; TODO: if we have a parameter file structure we need to add that here also
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                task = new CodeGenTask()
                task.Description = "Generate unit test environment and hosting program"
                task.Templates.Add("ODataUnitTestEnvironment")
                task.Templates.Add("ODataUnitTestHost")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                task = new CodeGenTask()
                task.Description = "Generate test constants class"
                task.Templates.Add("ODataTestConstantsProperties")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                task = new CodeGenTask()
                task.Description = "Generate test constants values"
                task.Templates.Add("ODataTestConstantsValues")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addNoReplaceOptions(task)
                taskset.Tasks.Add(task)
            end

            ;; Do it all!

            data codegen = new CodeGenerator(taskset)
            data success, boolean

            try
            begin
                ;;Generate code
                success = codegen.GenerateCode()

                ;;Display the results
                CodeGenOutput = taskset.Messages

                ;;Save the taskset to a file so we can manually generate from it later
                taskset.SaveToFile(_TasksetFile)
            end
            catch (e, @Exception)
            begin
                StatusBarText = String.Format("Unexpected error diring code generation. Error was '{0}'",e.Message)
            end
            endtry

            if (success) then
            begin
                StatusBarText = "Success"
            end
            else
            begin
                StatusBarText = "Errors occured during code generation"
            end

            structureAndFileStructures = ^null
            structureAndFileAliases = ^null

        endmethod
        
        private method setDefines, void
            taskset, @CodeGenTaskSet 
        proc
            if (Options.FullCollectionEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_GET_ALL")

            if (Options.PrimaryKeyEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_GET_ONE")

            if (Options.CreateTestFiles)
                taskset.Defines.Add("DEFINED_ENABLE_CREATE_TEST_FILES")

            if (Options.GenerateSwaggerDocs)
                taskset.Defines.Add("DEFINED_ENABLE_SWAGGER_DOCS")

            if (Options.EnableApiVersioning)
                taskset.Defines.Add("DEFINED_ENABLE_API_VERSIONING")

            if (Options.AlternateKeyEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_ALTERNATE_KEYS")

            if (Options.CollectionCountEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_COUNT")

            if (Options.IndividualPropertyEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_PROPERTY_ENDPOINTS")

            if (Options.DocumentPropertyEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_PROPERTY_VALUE_DOCS")

            if (Options.ODataSelect)
                taskset.Defines.Add("DEFINED_ENABLE_SELECT")

            if (Options.ODataFilter)
                taskset.Defines.Add("DEFINED_ENABLE_FILTER")

            if (Options.ODataOrderBy)
                taskset.Defines.Add("DEFINED_ENABLE_ORDERBY")

            if (Options.ODataTop)
                taskset.Defines.Add("DEFINED_ENABLE_TOP")

            if (Options.ODataSkip)
                taskset.Defines.Add("DEFINED_ENABLE_SKIP")

            if (Options.ODataRelations)
                taskset.Defines.Add("DEFINED_ENABLE_RELATIONS")

            if (Options.PutEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_PUT")

            if (Options.PostEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_POST")

            if (Options.PatchEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_PATCH")

            if (Options.DeleteEndpoints)
                taskset.Defines.Add("DEFINED_ENABLE_DELETE")

            if (Options.StoredProcedureRouting)
                taskset.Defines.Add("DEFINED_ENABLE_SPROC")

            if (Options.AdapterRouting)
                taskset.Defines.Add("DEFINED_ENABLE_ADAPTER_ROUTING")

            if (Options.Authentication)
                taskset.Defines.Add("DEFINED_ENABLE_AUTHENTICATION")

            if (Options.CustomAuthentication)
                taskset.Defines.Add("DEFINED_ENABLE_CUSTOM_AUTHENTICATION")

            if (Options.FieldSecurity)
                taskset.Defines.Add("DEFINED_ENABLE_FIELD_SECURITY")

            if (Options.CaseSensitiveUrls)
                taskset.Defines.Add("DEFINED_ENABLE_CASE_SENSITIVE_URL")

            if (Options.CrossDomainBrowsing)
                taskset.Defines.Add("DEFINED_ENABLE_CORS")

            if (Options.IISSupport)
                taskset.Defines.Add("DEFINED_ENABLE_IIS_SUPPORT")

            if (Options.ReadOnlyProperties)
                taskset.Defines.Add("DEFINED_ENABLE_READ_ONLY_PROPERTIES")

            if (Options.ODataSelect || Options.ODataFilter || Options.ODataOrderBy || Options.ODataTop || Options.ODataSkip || Options.ODataRelations)
                taskset.Defines.Add("DEFINED_PARAM_OPTIONS_PRESENT")

        endmethod
        
        private static structureAndFileStructures, @List<string>
        private static structureAndFileAliases, @List<string>
        
        private method addStructureAndFileStructures, void
            task, @CodeGenTask 
        proc
            ;; One time only per code generation pass

            if (structureAndFileStructures == ^null)
            begin
                structureAndFileStructures = new List<string>()
                structureAndFileAliases = new List<string>()
                data row, @StructureRow
                foreach row in Options.Structures.Where(lambda (row) { row.ProcessingMode.Equals("Structure and File") })
                begin
                    structureAndFileStructures.Add(row.Name)
                    structureAndFileAliases.Add(String.IsNullOrWhiteSpace(row.Alias) ? row.Name : row.Alias)
                end
            end

            ;; Add the structures to the current task

            data ix, int
            for ix from 0 thru structureAndFileStructures.Count - 1
            begin
                task.Structures.Add(structureAndFileStructures[ix])
                task.Aliases.Add(structureAndFileAliases[ix])
            end

        endmethod
        
        private static structureOnlyStructures, @List<string>
        private static structureOnlyAliases, @List<string>
        
        private method addStructureOnlyStructures, void
            task, @CodeGenTask 
        proc

            ;; One time only per code generation pass

            if (structureOnlyStructures == ^null)
            begin
                structureOnlyStructures = new List<string>()
                structureOnlyAliases = new List<string>()
                data row, @StructureRow
                foreach row in Options.Structures.Where(lambda (row) { row.ProcessingMode.Equals("Structure Only") })
                begin
                    structureOnlyStructures.Add(row.Name)
                    structureOnlyAliases.Add(String.IsNullOrWhiteSpace(row.Alias) ? row.Name : row.Alias)
                end
            end

            ;; Add the structures to the current task

            data ix, int
            for ix from 0 thru structureOnlyStructures.Count - 1
            begin
                task.Structures.Add(structureOnlyStructures[ix])
                task.Aliases.Add(structureOnlyAliases[ix])
            end

        endmethod
        
        private static customCodeStructures, @List<string>
        private static customCodeAliases, @List<string>
        
        private method addCustomCodeStructures, void
            task, @CodeGenTask 
        proc

            ;; One time only per code generation pass

            if (customCodeStructures == ^null)
            begin
                customCodeStructures = new List<string>()
                customCodeAliases = new List<string>()

                data row, @StructureRow
                foreach row in Options.Structures.Where(lambda (row) { row.ProcessingMode.Equals("Custom Code Only") })
                begin
                    customCodeStructures.Add(row.Name)
                    customCodeAliases.Add(String.IsNullOrWhiteSpace(row.Alias) ? row.Name : row.Alias)
                end
            end

            ;; Add the structures to the current task

            data ix, int
            for ix from 0 thru customCodeStructures.Count - 1
            begin
                task.Structures.Add(customCodeStructures[ix])
                task.Aliases.Add(customCodeAliases[ix])
            end

        endmethod
        
        private method addStandardOptions, void
            task, @CodeGenTask 
        proc
            addNoReplaceOptions(task)
            task.ReplaceFiles = true
        endmethod
        
        private method addNoReplaceOptions, void
            task, @CodeGenTask 
        proc
            task.UserTokenFile = Options.UserTokensFile
            task.IncludeOverlayFields = Options.FieldOverlays
            task.UseAlternateFieldNames = Options.AlternateFieldNames
        endmethod
        
.endregion

    endclass

endnamespace


import CodeGen.Engine
import HarmonyCoreGenerator.Model
import Microsoft.VisualStudio.Threading
import MvvmTools
import System
import System.Collections.Generic
import System.Collections.ObjectModel
import System.IO
import System.Linq
import System.Windows
import System.Windows.Input
import System.Xml.Linq

namespace HarmonyCoreGenerator.ViewModel

    public partial class GeneratorViewModel

.region "GenerateODataCodeCommand"

        private _GenerateODataCodeCommand, @ICommand

        public property GenerateODataCodeCommand, @ICommand
            method get
            proc
                lambda execute(param)
                begin
                    generateODataCode()
                end
                lambda canExecute(param)
                begin
                    mreturn _SolutionOpen
                end
                if (_GenerateODataCodeCommand == ^null)
                    _GenerateODataCodeCommand = new RelayCommand(execute, canExecute)
                mreturn _GenerateODataCodeCommand
            endmethod
        endproperty

        private async method generateODataCode, void
        proc
            ;; Ensure the code generation page is visible
            SelectedTabIndex = (int)MainWindowTabPages.CodeGeneration

            ;;Make sure we're in the solution folder
            Directory.SetCurrentDirectory(_SolutionFolder)

            if (Options.UnsavedChanges)
            begin
                if (MessageBox.Show("Save configuration changes before generating?","There are Unsaved Changes",MessageBoxButton.YesNo,MessageBoxImage.Question,MessageBoxResult.Yes) == MessageBoxResult.Yes)
                begin
                    saveSettings()
                end
            end

            StatusBarText = "Generating OData Code..."

            CodeGenOutput.Clear()

            data taskset = new CodeGenTaskSet()
            &    {
            &    Description = "Code generation tasks for Harmony Core solution.",
            &    RepositoryMainFile = Options.RepositoryMainFile,
            &    RepositoryTextFile = Options.RepositoryTextFile,
            &    TemplateFolder = Options.TemplatesFolder,
            &    EchoCommands = true,
            &    ListGeneratedFiles = true,
            &    LoggingLevel = CodeGenLoggingLevel
            &    }

            ;;Add defined values based on options selected in the UI
            setOdataDefines(taskset)

            ;;Add event handlers to grab task set output
            addhandler(taskset.TaskSetMessage,TaskSetMessage)
            addhandler(taskset.TaskSetComplete,TaskSetComplate)

            ;;Define code generation tasks based on options selected in the UI

            data task, @CodeGenTask

            ;;---------------------------------------------------------------------------------------------
            ;; OData

            ;; OData model & metadata classes

            task = new CodeGenTask()
            task.Description = "Generate model and metadata classes"
            task.Templates.Add("ODataModel")
            task.Templates.Add("ODataMetaData")
            task.OutputFolder = Options.ModelsFolder
            task.Namespace = "Services.Models"
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addCustomCodeStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; OData controllers

            task = new CodeGenTask()
            task.Description = "Generate controller classes"
            task.Templates.Add("ODataController")
            task.OutputFolder = Options.ControllersFolder
            task.Namespace = "Services.Controllers"
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; DBContext

            task = new CodeGenTask()
            task.Description = "Generate the DBContext class"
            task.Templates.Add("ODataDbContext")
            task.OutputFolder = Options.ModelsFolder
            task.Namespace = "Services.Models"
            task.MultipleStructures = true
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; EdbBuilder and Startup classes

            task = new CodeGenTask()
            task.Description = "Generate the EdmBuilder and Startup classes"
            task.Templates.Add("ODataEdmBuilder")
            task.Templates.Add("ODataStartup")
            task.OutputFolder = Options.ServicesFolder
            task.Namespace = "Services"
            task.MultipleStructures = true
            task.UserTokens.Add(new UserToken("CONTROLLERS_NAMESPACE", "Services.Controllers"))
            task.UserTokens.Add(new UserToken("MODELS_NAMESPACE", "Services.Models"))
            addStructureAndFileStructures(task)
            addStructureOnlyStructures(task)
            addStandardOptions(task)
            taskset.Tasks.Add(task)

            ;; Self hosting program & environment

            if (Options.GenerateSelfHost)
            begin
                task = new CodeGenTask()
                task.Description = "Generate self hosting program and environment"
                task.Templates.Add("ODataSelfHost")
                task.Templates.Add("ODataSelfHostEnvironment")
                task.OutputFolder = Options.SelfHostFolder
                task.Namespace = "Services.Host"
                task.MultipleStructures = true
                task.UserTokens.Add(new UserToken("SERVICES_NAMESPACE", "Services"))
                task.UserTokens.Add(new UserToken("MODELS_NAMESPACE", "Services.Models"))
                addStructureAndFileStructures(task)
                ;; TODO: if we have a parameter file structure we need to add that here also
                addStandardOptions(task)
                taskset.Tasks.Add(task)
            end

            ;; Swagger documentation

            if (Options.VersioningOrSwagger == VersioningOrSwaggerMode.GenerateSwaggerDoc)
            begin
                task = new CodeGenTask()
                task.Description = "Generate swagger documentation"
                task.Templates.Add("ODataSwaggerYaml")
                task.OutputFolder = Path.Combine(Options.ServicesFolder, "wwwroot")
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                task = new CodeGenTask()
                task.Description = "Generate swagger complex types documentation"
                task.Templates.Add("ODataSwaggerType")
                task.OutputFolder = Path.Combine(Options.ServicesFolder, "wwwroot")
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)
            end

            ;; Postman tests

            if (Options.GeneratePostmanTests)
            begin
                task = new CodeGenTask()
                task.Description = "Generate Postman tests"
                task.Templates.Add("ODataPostManTests")
                task.OutputFolder = _SolutionFolder
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)
            end

            ;;---------------------------------------------------------------------------------------------
            ;; Unit tests

            if (Options.GenerateUnitTests)
            begin
                ;; Client-side model, data loader and unit tests

                task = new CodeGenTask()
                task.Description = "Generate client-side models, data loaders and unit tests"
                task.Templates.Add("ODataClientModel")
                task.Templates.Add("ODataTestDataLoader")
                task.Templates.Add("ODataUnitTests")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                ;; Test environment

                task = new CodeGenTask()
                task.Description = "Generate test environment"
                task.Templates.Add("ODataTestEnvironment")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                ;; TODO: if we have a parameter file structure we need to add that here also
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                ;; Unit test environment and hosting program

                task = new CodeGenTask()
                task.Description = "Generate unit test environment and hosting program"
                task.Templates.Add("ODataUnitTestEnvironment")
                task.Templates.Add("ODataUnitTestHost")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                ;; Test constants properties

                task = new CodeGenTask()
                task.Description = "Generate test constants class"
                task.Templates.Add("ODataTestConstantsProperties")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addStandardOptions(task)
                taskset.Tasks.Add(task)

                ;; Test constants values (one time, no replace)

                task = new CodeGenTask()
                task.Description = "Generate test constants values"
                task.Templates.Add("ODataTestConstantsValues")
                task.OutputFolder = Options.UnitTestFolder
                task.Namespace = "Services.Test"
                task.MultipleStructures = true
                addStructureAndFileStructures(task)
                addStructureOnlyStructures(task)
                addNoReplaceOptions(task)
                taskset.Tasks.Add(task)
            end

            ;;---------------------------------------------------------------------------------------------
            ;; Execute the OData tasks

            try
            begin
                data success, boolean
                data codegen = new CodeGenerator(taskset)

                ;;Get us off the UI thread
                await System.Threading.Tasks.TaskScheduler.Default

                ;;Generate the code
                success = codegen.GenerateCode()

                ;;Get back onto the UI thread
                await HarmonyCoreGenerator.App.JTF.SwitchToMainThreadAsync()

                ;;Save the taskset to a file so we can manually generate from it later
                taskset.SaveToFile(_ODataTaskSetFile)

                ;;Add new files to the Visual Studio Solutions
                data messages, @ObservableCollection<LogEntry>
                updateProjectFiles(taskset,messages)

                ;;Display details of files added to projects
                CodeGenOutput.AddRange(messages)

                ;;Update the status bar
                StatusBarText = success ? "Success" : "Errors occured during code generation"
            end
            catch (e, @Exception)
            begin
                StatusBarText = String.Format("Unexpected error during code generation. Error was '{0}'",e.Message)
            end
            endtry

            structureAndFileStructures = ^null
            structureAndFileAliases = ^null

        endmethod

.endregion

.region "Helper methods"

        private method setOdataDefines, void
            taskset, @CodeGenTaskSet 
        proc
            taskset.Defines.Clear()

            if (Options.FullCollectionEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_GET_ALL") 
            end

            if (Options.PrimaryKeyEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_GET_ONE") 
            end

            if (Options.CreateTestFiles)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_CREATE_TEST_FILES") 
            end

            if (Options.VersioningOrSwagger == VersioningOrSwaggerMode.GenerateSwaggerDoc)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_SWAGGER_DOCS") 
            end

            if (Options.VersioningOrSwagger == VersioningOrSwaggerMode.ApiVersioning)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_API_VERSIONING") 
            end

            if (Options.AlternateKeyEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_ALTERNATE_KEYS") 
            end

            if (Options.CollectionCountEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_COUNT") 
            end

            if (Options.IndividualPropertyEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_PROPERTY_ENDPOINTS") 
            end

            if (Options.DocumentPropertyEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_PROPERTY_VALUE_DOCS") 
            end

            if (Options.ODataSelect)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_SELECT") 
            end

            if (Options.ODataFilter)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_FILTER") 
            end

            if (Options.ODataOrderBy)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_ORDERBY") 
            end

            if (Options.ODataTop)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_TOP") 
            end

            if (Options.ODataSkip)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_SKIP") 
            end

            if (Options.ODataRelations)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_RELATIONS") 
            end

            if (Options.PutEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_PUT") 
            end

            if (Options.PostEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_POST") 
            end

            if (Options.PatchEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_PATCH") 
            end

            if (Options.DeleteEndpoints)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_DELETE") 
            end

            if (Options.StoredProcedureRouting)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_SPROC") 
            end

            if (Options.AdapterRouting)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_ADAPTER_ROUTING") 
            end

            if (Options.Authentication)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_AUTHENTICATION") 
            end

            if (Options.CustomAuthentication)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_CUSTOM_AUTHENTICATION") 
            end

            if (Options.FieldSecurity)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_FIELD_SECURITY") 
            end

            if (Options.CaseSensitiveUrls)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_CASE_SENSITIVE_URL") 
            end

            if (Options.CrossDomainBrowsing)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_CORS") 
            end

            if (Options.IISSupport)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_IIS_SUPPORT") 
            end

            if (Options.ReadOnlyProperties)
            begin
                taskset.Defines.Add("DEFINED_ENABLE_READ_ONLY_PROPERTIES") 
            end

            if (Options.ODataSelect || Options.ODataFilter || Options.ODataOrderBy || Options.ODataTop || Options.ODataSkip || Options.ODataRelations)
            begin
                taskset.Defines.Add("DEFINED_PARAM_OPTIONS_PRESENT") 
            end

        endmethod

        ;;; <summary>
        ;;; Extracts a list of all source files generated by a task set and
        ;;; adds them to the appropriate Visual Studio project if necessary.
        ;;; </summary>
        ;;; <param name="taskset">Completed CodeGen taskset to check</param>
        private method updateProjectFiles, void
            required in taskset, @CodeGenTaskSet
            required out messages, @ObservableCollection<LogEntry>
        proc
            ;;Initialize the return messages collection
            messages = new ObservableCollection<LogEntry>()

            ;;Extract a list of all source files generated by the taskset
            data task, @CodeGenTask
            data newFile, string
            data allNewFiles = new List<String>()

            foreach task in taskset.Tasks
            begin
                foreach newFile in task.FilesGenerated
                begin
                    if (Path.GetExtension(newFile).ToLower().Equals(".dbl"))
                    begin
                        allNewFiles.Add(newFile)
                    end
                end
            end

            ;;Determine which project each of the new files belongs to

            data servicesFiles = new List<String>()
            data controllersFiles = new List<String>()
            data modelsFiles = new List<String>()
            data hostFiles = new List<String>()
            data isolatedFiles = new List<String>()
            data unitTestFiles = new List<String>()
            data traditionalBridgeFiles = new List<String>()

            data sourceFilePath, string
            data removeString, string
            data index, int
            data tmpFile, string

            foreach sourceFilePath in allNewFiles
            begin
                if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.ServicesFolder))) then
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    servicesFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
                else if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.ControllersFolder))) then
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    controllersFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
                else if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.SelfHostFolder))) then
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    hostFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
                else if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.IsolatedFolder))) then
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    isolatedFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
                else if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.ModelsFolder))) then
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    modelsFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
                else if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.UnitTestFolder))) then
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    unitTestFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
                else if (sourceFilePath.StartsWith(removeString=String.Format("{0}\",Options.TraditionalBridgeFolder)))
                begin
                    index = sourceFilePath.IndexOf(removeString)
                    traditionalBridgeFiles.Add((index < 0) ? sourceFilePath : sourceFilePath.Remove(index, removeString.Length))
                end
            end

            ;;Add any new files to the projects

            if (servicesFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.ServicesFolder,Options.ServicesProject),servicesFiles)
                if (servicesFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.ServicesProject))
                    foreach tmpFile in servicesFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (controllersFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.ControllersFolder,Options.ControllersProject),controllersFiles)
                if (controllersFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.ControllersProject))
                    foreach tmpFile in controllersFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (modelsFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.ModelsFolder,Options.ModelsProject),modelsFiles)
                if (modelsFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.ModelsProject))
                    foreach tmpFile in modelsFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (hostFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.SelfHostFolder,Options.SelfHostProject),hostFiles)
                if (hostFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.SelfHostProject))
                    foreach tmpFile in hostFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (isolatedFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.IsolatedFolder,Options.IsolatedProject),isolatedFiles)
                if (isolatedFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.IsolatedProject))
                    foreach tmpFile in isolatedFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (unitTestFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.UnitTestFolder,Options.UnitTestProject),unitTestFiles)
                if (unitTestFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.UnitTestProject))
                    foreach tmpFile in unitTestFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (traditionalBridgeFiles.Count > 0)
            begin
                updateProjectFile(Path.Combine(Options.TraditionalBridgeFolder,Options.TraditionalBridgeProject),traditionalBridgeFiles)
                if (unitTestFiles.Count != 0)
                begin
                    messages.Add(new LogEntry(""))
                    messages.Add(new LogEntry("New files were added to " + Options.TraditionalBridgeProject))
                    foreach tmpFile in traditionalBridgeFiles
                    begin
                        messages.Add(new LogEntry(" - " + tmpFile))
                    end
                end
            end

            if (messages.Count == 0)
            begin
                messages.Add(new LogEntry(""))
                messages.Add(new LogEntry("No new source files were added to projects"))
            end

        endmethod

        ;;; <summary>
        ;;; Adds any new source files to a Visual Studio project
        ;;; </summary>
        ;;; <param name="aProjectFile">Full file spec of project file to check.</param>
        ;;; <param name="aSourceFiles">Collection of source files to check.</param>
        private method updateProjectFile, void
            required in aProjectFile, string
            required inout aSourceFiles, @List<String>
        proc

            data sourceFilesAdded = new List<String>()

            ;;Load the project file and get the root namespace of the document
            data xDoc = XDocument.Load(aProjectFile)
            data testNs = xDoc.Root.GetDefaultNamespace()

            ;;Find all <ItemGroup> elements
            data itemGroups = xDoc.Descendants(testNs + "ItemGroup")

            ;;Find the <ItemGroup> that contains <Compile> elements
            data itemGroupsWithCompileItems = itemGroups.Where(lambda (ig) { ig.Descendants(testNs + "Compile").Count() > 0 })

            ;;Build a list of new <Compile> elements to add
            data newItems = new List<XElement>()
            begin
                data newFile, string
                foreach newFile in aSourceFiles
                begin
                    ;;If we're adding to an existing <ItemList> we need to make sure that
                    ;;this file is not already included.
                    if (itemGroupsWithCompileItems.Count() > 0)
                    begin
                        data itemGroup = itemGroupsWithCompileItems.FirstOrDefault()
                        if (itemGroup.Descendants().Any(lambda(xe) { xe.FirstAttribute.Value.Equals(newFile) }))
                        begin
                            nextloop 
                        end
                    end
                    ;;Add a new <Compile> element for the file
                    data newItem = new XElement(testNs + "Compile")
                    newItem.SetAttributeValue("Include", newFile)
                    newItems.Add(newItem)

                    ;;Tell the calling routine that we added this file
                    sourceFilesAdded.Add(newFile)
                end
            end

            ;;Did we find any new items for the project?
            if (newItems.Count > 0)
            begin
                ;;Did we find an <ItemGroup> with existing <Compile> elements?
                if (itemGroupsWithCompileItems.Count() > 0) then
                begin
                    ;;Yes, add the new items to it
                    itemGroupsWithCompileItems.FirstOrDefault().Add(newItems.ToArray())
                end
                else
                begin
                    ;;No, add a new item group after the last one and add new items to it.
                    data lastItemGroup = itemGroups.LastOrDefault()
                    lastItemGroup.AddAfterSelf(new XElement(testNs + "ItemGroup", newItems.ToArray()))
                end
            
                ;;Save the updated project file
                ;;Don't use xDoc.Save(aProjectFile) becsuse it adds an XML declaration to the project file.
                File.WriteAllText(aProjectFile,xDoc.ToString())
            end

            ;;Tell the calling routine what we did
            aSourceFiles = sourceFilesAdded

        endmethod

        private static structureAndFileStructures, @List<string>
        private static structureAndFileAliases, @List<string>
        
        private method addStructureAndFileStructures, void
            task, @CodeGenTask 
        proc
            ;; One time only per code generation pass

            if (structureAndFileStructures == ^null)
            begin
                structureAndFileStructures = new List<string>()
                structureAndFileAliases = new List<string>()
                data row, @ODataStructureRow
                foreach row in Options.ODataStructures.Where(lambda (row) { row.ProcessingMode.Equals("Structure and File") })
                begin
                    structureAndFileStructures.Add(row.Name)
                    structureAndFileAliases.Add(String.IsNullOrWhiteSpace(row.Alias) ? row.Name : row.Alias)
                end
            end

            ;; Add the structures to the current task

            data ix, int
            for ix from 0 thru structureAndFileStructures.Count - 1
            begin
                task.Structures.Add(structureAndFileStructures[ix])
                task.Aliases.Add(structureAndFileAliases[ix])
            end

        endmethod
        
        private static structureOnlyStructures, @List<string>
        private static structureOnlyAliases, @List<string>
        
        private method addStructureOnlyStructures, void
            task, @CodeGenTask 
        proc

            ;; One time only per code generation pass

            if (structureOnlyStructures == ^null)
            begin
                structureOnlyStructures = new List<string>()
                structureOnlyAliases = new List<string>()
                data row, @ODataStructureRow
                foreach row in Options.ODataStructures.Where(lambda (row) { row.ProcessingMode.Equals("Structure Only") })
                begin
                    structureOnlyStructures.Add(row.Name)
                    structureOnlyAliases.Add(String.IsNullOrWhiteSpace(row.Alias) ? row.Name : row.Alias)
                end
            end

            ;; Add the structures to the current task

            data ix, int
            for ix from 0 thru structureOnlyStructures.Count - 1
            begin
                task.Structures.Add(structureOnlyStructures[ix])
                task.Aliases.Add(structureOnlyAliases[ix])
            end

        endmethod

        private static customCodeStructures, @List<string>
        private static customCodeAliases, @List<string>
        
        private method addCustomCodeStructures, void
            task, @CodeGenTask 
        proc

            ;; One time only per code generation pass

            if (customCodeStructures == ^null)
            begin
                customCodeStructures = new List<string>()
                customCodeAliases = new List<string>()

                data row, @ODataStructureRow
                foreach row in Options.ODataStructures.Where(lambda (row) { row.ProcessingMode.Equals("Custom Code Only") })
                begin
                    customCodeStructures.Add(row.Name)
                    customCodeAliases.Add(String.IsNullOrWhiteSpace(row.Alias) ? row.Name : row.Alias)
                end
            end

            ;; Add the structures to the current task

            data ix, int
            for ix from 0 thru customCodeStructures.Count - 1
            begin
                task.Structures.Add(customCodeStructures[ix])
                task.Aliases.Add(customCodeAliases[ix])
            end

        endmethod

.endregion

.region "Event handlers"

        ;;; <summary>
        ;;; Event handler to log as each code generation task begins
        ;;; </summary>
        ;;; <param name="message">Task that is beginning</param>
        public async method TaskSetMessage, void
            message, @String
        proc
            await HarmonyCoreGenerator.App.JTF.SwitchToMainThreadAsync()
            CodeGenOutput.Add(new LogEntry(message))
        endmethod

        ;;; <summary>
        ;;; Event handler to log as each code generation taskset ends
        ;;; </summary>
        ;;; <param name="taskset">Taskset that is beginning</param>
        public async method TaskSetComplate, void
            taskset, @CodeGenTaskSet
        proc
            await HarmonyCoreGenerator.App.JTF.SwitchToMainThreadAsync()
            removehandler(taskset.TaskSetMessage,TaskSetMessage)
            removehandler(taskset.TaskSetComplete,TaskSetComplate)
        endmethod

.endregion

    endclass

endnamespace

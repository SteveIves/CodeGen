;;*****************************************************************************
;;
;; Title:       FieldTokenTests.dbl
;;
;; Type:        Unit test class
;;
;; Description: Unit tests for CodeGenEngine.ExpandFieldToken()
;;
;; Date:        27th November 2012
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import Microsoft.VisualStudio.TestTools.UnitTesting
import System

namespace CodeGen.UnitTests

	{TestClass}
	public class FieldTokenTests

		private mStr			,@CodeGen.RepositoryAPI.RpsStructure
		private mFieldOne		,@CodeGen.RepositoryAPI.RpsField
		private mFieldTwo		,@CodeGen.RepositoryAPI.RpsField
		private mFieldThree		,@CodeGen.RepositoryAPI.RpsField
		private mFieldFour		,@CodeGen.RepositoryAPI.RpsField
		private mFieldFive		,@CodeGen.RepositoryAPI.RpsField
		private mFieldSix		,@CodeGen.RepositoryAPI.RpsField
		private mFieldSeven		,@CodeGen.RepositoryAPI.RpsField
		private mFieldEight		,@CodeGen.RepositoryAPI.RpsField
		private mFieldNine		,@CodeGen.RepositoryAPI.RpsField
		private mFieldTen		,@CodeGen.RepositoryAPI.RpsField
		private mFieldEleven	,@CodeGen.RepositoryAPI.RpsField
		private mFieldTwelve	,@CodeGen.RepositoryAPI.RpsField
		private mFieldThirteen	,@CodeGen.RepositoryAPI.RpsField
		private mFieldFourteen	,@CodeGen.RepositoryAPI.RpsField
		private mFieldFifteen	,@CodeGen.RepositoryAPI.RpsField
		private mMsg			,String

		{TestInitialize}
		public method Initialize, void
			endparams
		proc
			;;Make sure we don't try to display anything to the screen
			CodeGen.Engine.Env.SuppressLogging = true

			;;Load the UNIT_TEST repository structure
			mStr = new CodeGen.RepositoryAPI.RpsStructure("UNIT_TEST")

			;;Run the structure through CheckStructure() because it sets up
			;;some stuff that is needed in order to successfully process some tokens
			if (!CodeGen.Engine.CheckStructure(mStr))
				throw new Exception("CodeGen.Engine.CheckStructure failed to validate structure UNIT_TEST")

			;;Get handles on the fields we'll use during our tests
			mFieldOne      = mStr.Fields[0]		;A1
			mFieldTwo      = mStr.Fields[1]		;D1 enumerated with selections
			mFieldThree    = mStr.Fields[2]		;D2.1 with max min range
			mFieldFour     = mStr.Fields[3]		;D8 date
			mFieldFive     = mStr.Fields[4]		;D5.2 with a display format
			mFieldSix      = mStr.Fields[5]		;A1 with a selection window
			mFieldSeven    = mStr.Fields[6]		;A10 based on a tamplate TEMPLATE_ONE
			mFieldEight    = mStr.Fields[7]		;I1
			mFieldNine     = mStr.Fields[8]		;I2
			mFieldTen      = mStr.Fields[9]		;I4
			mFieldEleven   = mStr.Fields[10]	;I8
			mFieldTwelve   = mStr.Fields[11]	;[2]A1
			mFieldThirteen = mStr.Fields[12]	;[2,2]A1
			mFieldFourteen = mStr.Fields[13]	;[2,2,2]A1
			mFieldFifteen  = mStr.Fields[14]	;[2,2,2,2]A1
			
			;;Configure CodeGen for repository processing
			CodeGen.Engine.Env.CurrentStructure = mStr
			CodeGen.Engine.Env.RpsInUse = true

		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Altname, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ALTNAME>","FIELD_1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_ArriveM, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ARRIVEM>","FIELD_ONE_ARRIVE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_BaseName, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_BASENAME>","FIELD_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_BreakMode, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_BREAK_MODE>","None"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_ChangeM, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_CHANGEM>","FIELD_ONE_CHANGE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Col, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_COL>","20"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_CsDefault, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_CSDEFAULT>",'""'),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_CsType, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_CSTYPE>","string"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_CsConvert, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_CSCONVERT>","decimal.TryParse"),mMsg)
		endmethod

		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Default, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_DEFAULT>","D"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Description, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_DESC>","Field one is an A1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_DrillM, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_DRILLM>","FIELD_ONE_DRILL"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Element, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ELEMENT>",""),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Element0_01, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ELEMENT0>","0"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_EnumLength, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_ENUMLENGTH>","7"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_EnumWidth, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_ENUMWIDTH>",string(mFieldTwo.EnumeratedDisplayLength * CodeGen.Engine.Env.CharacterWidth)),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_FormatName, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldFive,5,5,"<FIELD_FORMATNAME>","DOLLARS"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Heading, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_HEADING>","Field one report heading"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_HelpId, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_HELPID>","FIELD_ONE_HELP_ID"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_HyperM, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_HYPERM>","FIELD_ONE_HYPER"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_InfoLine, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_INFOLINE>","This is field one"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_LongDesc, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_LDESC>","Field one long description.@MAPF=CONV;@UNMAPF=UNCONV;@MAP=OTHER_FIELD;"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_LeaveM, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_LEAVEM>","FIELD_ONE_LEAVE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MaxValue01, void
			endparams
		proc
			;;This token is not supported for alpha fields, so the token should not get replaced.
			;;In CodeGen this would cause an error to be reported.
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_MAXVALUE>","<FIELD_MAXVALUE>"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MaxValue02, void
			endparams
		proc
			;;This field is a D1 with an enumerated selection list, therefor the
			;;min value is based on the enumerated value of the last selection
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_MAXVALUE>","3"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MaxValue03, void
			endparams
		proc
			;;This field is a D2.1 with a numeric range of 2 to 8, so the min value
			;;should be based on the numeric range.
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_MAXVALUE>","8.0000000000"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MaxValue04, void
			endparams
		proc
			;;This field is a D5.2 with negatives allowed
			Assert.IsTrue(doTest(mFieldFive,5,5,"<FIELD_MAXVALUE>","999.99"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MaxValue05, void
			endparams
		proc
			;;This field is an I4 with negatives allowed
			Assert.IsTrue(doTest(mFieldTen,10,10,"<FIELD_MAXVALUE>","2147483647"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MinValue01, void
			endparams
		proc
			;;This token is not supported for alpha fields, so the token should not get replaced.
			;;In CodeGen this would cause an error to be reported.
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_MINVALUE>","<FIELD_MINVALUE>"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MinValue02, void
			endparams
		proc
			;;This field is a D1 with an enumerated selection list, therefor the
			;;min value is based on the enumerated value of the first selection
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_MINVALUE>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MinValue03, void
			endparams
		proc
			;;This field is a D2.1 with a numeric range of 2 to 8, so the min value
			;;should be based on the numeric range.
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_MINVALUE>","2.0000000000"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MinValue04, void
			endparams
		proc
			;;This field is a D5.2 with negatives allowed
			Assert.IsTrue(doTest(mFieldFive,5,5,"<FIELD_MINVALUE>","-999.99"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MinValue05, void
			endparams
		proc
			;;This field is an I4 with negatives allowed
			Assert.IsTrue(doTest(mFieldTen,10,10,"<FIELD_MINVALUE>","-2147483648"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Name, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_NAME>","FIELD_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_NoEchoChar, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_NOECHO_CHAR>","~"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_OcDefault, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_OCDEFAULT>",'@""'),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_OcType, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_OCTYPE>","NSString"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_OriginalName, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ORIGINAL_NAME>","FIELD_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Path, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_PATH>","UNIT_TEST.FIELD_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PathConv, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_PATH_CONV>","%UNCONV(UNIT_TEST.FIELD_ONE)"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PixelCol, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_PIXEL_COL>",string((mFieldOne.FieldColumn*CodeGen.Engine.Env.CharacterWidth)-(CodeGen.Engine.Env.CharacterWidth-1))),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PixelRow, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_PIXEL_ROW>",string(((mFieldOne.FieldRow+mFieldOne.ArrayDimension[1]-1)*CodeGen.Engine.Env.CharacterHeight)-(CodeGen.Engine.Env.CharacterHeight-1))),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PixelWidth, void
			endparams
		proc
			;TODO: Also need to test this with a field with a selection list
			;TODO: Also need to test this with a field with an enumerated numeric field
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_PIXEL_WIDTH>","12"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PixelWidthSelections, void
			endparams
		proc
			data expectedWidth, int, mFieldTwo.SelectionListMaxLength * CodeGen.Engine.Env.CharacterWidth
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_PIXEL_WIDTH>",expectedWidth.ToString()),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_DrillPixelCol, void
			endparams
		proc
			;TODO: Also need to test this with a field with a selection list
			;TODO: Also need to test this with a field with an enumerated numeric field
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_DRILL_PIXEL_COL>","240"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_InputLength, void
			endparams
		proc
			;TODO: Lots of different tests needed here
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_INPUT_LENGTH>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_OdbcName, void
			endparams
		proc
			;TODO: Need to test this with array fields
			;TODO: Need to test this with group fields
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ODBCNAME>","FIELD_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Position, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_POSITION>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Position0, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_POSITION_ZERO>","0"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Precision, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_PRECISION>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Precision2, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_PRECISION2>",".1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Prompt, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_PROMPT>","Field one"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_RangeMax, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_RANGE_MAX>","8.0000000000"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_RangeMin, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldThree,3,3,"<FIELD_RANGE_MIN>","2.0000000000"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Regex, void
			endparams
		proc
			;;TODO: Need LOTS more tests for this one with various field types
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_REGEX>","^.{1,1}$"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Row, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_ROW>","5"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Selections, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_SELECTIONS>",'"Option1","Option2","Option3"'),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Selections1, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_SELECTIONS1>",'"Option1|Option2|Option3"'),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_SelLength, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldTwo,2,2,"<FIELD_SELLENGTH>","7"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_SelWnd, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldSix,6,6,"<FIELD_SELWND>","OPTIONS"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Size, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_SIZE>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Spec, void
			endparams
		proc
			;TODO: Need tests for various other field types
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_SPEC>","A1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_SqlName, void
			endparams
		proc
			;TODO: Need to test with array and group fields
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_SQLNAME>","FIELD_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_SqlType, void
			endparams
		proc
			;TODO: Need to test with fields of other data types
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_SQLTYPE>","VARCHAR(1)"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Template, void
			endparams
		proc
			;TODO: Need to test with a field based on a template
			Assert.IsTrue(doTest(mFieldSeven,7,7,"<FIELD_TEMPLATE>","TEMPLATE_ONE"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_TkScript, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_TKSCRIPT>",".field FIELD_ONE, pos(5,10), fpos(5,20)"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Type, void
			endparams
		proc
			;TODO: Need to test with other field types
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_TYPE>","A"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_TypeName, void
			endparams
		proc
			;TODO: Need to test with other field types
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_TYPE_NAME>","ALPHA"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_UserText, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_UTEXT>","Field one user text"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_VbDefault, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_VBDEFAULT>",'""'),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_VbType, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD_VBTYPE>","String"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Number, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD#>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_Number0, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD#_ZERO>","0"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_NumberLogical, void
			endparams
		proc
			;TODO: Test with array fields and fields after arrays / groups
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD#LOGICAL>","1"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_NumberLogicalZero, void
			endparams
		proc
			;TODO: Test with array fields and fields after arrays / groups
			Assert.IsTrue(doTest(mFieldOne,1,1,"<FIELD#LOGICAL_ZERO>","0"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MappedField, void
			endparams
		proc
			;TODO: Also test with a field without a mapping
			Assert.IsTrue(doTest(mFieldOne,1,1,"<MAPPED_FIELD>","OTHER_FIELD"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MappedPath, void
			endparams
		proc
			;TODO: Also test with a field without a mapping
			Assert.IsTrue(doTest(mFieldOne,1,1,"<MAPPED_PATH>","OTHER_STRUCTURE.OTHER_FIELD"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_MappedPathConv, void
			endparams
		proc
			;TODO: Also test with a field without a mapping
			Assert.IsTrue(doTest(mFieldOne,1,1,"<MAPPED_PATH_CONV>","%CONV(OTHER_STRUCTURE.OTHER_FIELD)"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PromptCol, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<PROMPT_COL>","10"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PromptPixelCol, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<PROMPT_PIXEL_COL>","109"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PromptPixelRow, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<PROMPT_PIXEL_ROW>","101"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PromptPixelWidth, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<PROMPT_PIXEL_WIDTH>","108"),mMsg)
		endmethod
		
		{TestMethod}
		{TestCategory("Field Loop Token Tests")}
		public method FieldToken_PromptRow, void
			endparams
		proc
			Assert.IsTrue(doTest(mFieldOne,1,1,"<PROMPT_ROW>","5"),mMsg)
		endmethod
		
.region "Support methods"

		private method doTest, Boolean
			required in fld			,@CodeGen.RepositoryAPI.RpsField
			required in fldNum		,int	;One based here, but 0-based in ExpandFieldToken()
			required in fldNumLog	,int
			required in inBuffer	,String
			required in expBuffer	,String
			endparams
		proc
			data ok				,Boolean
			data mainBuffer		,a32768	,inBuffer
			data expectedResult	,a32768	,expBuffer
			data tokenStart		,int	,instr(1,mainBuffer,"<") 
			data tokenEnd		,int	,instr(tokenStart,mainBuffer,">")
			data errStatus		,int	,0

			mMsg = "PROCESSING: " + atrim(mainBuffer) + " for field " + fld.Name + " EXPECTED: " + atrim(expectedResult)

			if (ok=CodeGen.Engine.ExpandFieldToken(mStr,fld,fldNum-1,fldNumLog,tokenStart,tokenEnd,false,mainBuffer,errStatus))
			begin
				if (instr(1,mainBuffer,"~~~ REMOVE THIS RECORD ~~~"))
					mainBuffer = mainBuffer - "~~~ REMOVE THIS RECORD ~~~"
			end

			;;If token replacement failed it's probably because of an invalid token, or the
			;;use of a token that isn't supported for this type of field. In this case the
			;;token will still be in the buffer. If that's what we expected then we're OK.
			ok = (mainBuffer.eqs.expectedResult)

			mMsg = mMsg + " ACTUAL: " + atrim(mainBuffer)

			mreturn ok

		endmethod

.endregion

	endclass

endnamespace


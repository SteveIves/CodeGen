<CODEGEN_FILENAME><Structure_Name>.cs</CODEGEN_FILENAME>
;//****************************************************************************
;//
;// Title:       cs_class.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: This template generates a C# data class to represent a
;//              Synergy Repository structure.
;//
;// Date:        19th March 2007
;//
;// Author:      Steve Ives, Synergex Professional Services Group
;//              http://www.synergex.com
;//
;//****************************************************************************
;//
;// Copyright (c) 2012, Synergex International, Inc.
;// All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
//*****************************************************************************
//
// Title:       <Structure_Name>.cs
//
// Author:      <AUTHOR>
//
// Company:     <COMPANY>
//
//*****************************************************************************
//
// WARNING:     This code was generated by CodeGen. Any changes that you make
//              to this file will be lost if the code is regenerated.
//
//*****************************************************************************
//
using System;

namespace <NAMESPACE>
{
    public class <Structure_Name>
    {
        public <Structure_Name>()
        {
        }

        public <Structure_Name>(string SynergyRecord)
        {
            parseRecord(SynergyRecord);
        }

        #region Private fields (storage for properties)

        <FIELD_LOOP>
        private <FIELD_CSTYPE> p_<Field_Sqlname>;
        </FIELD_LOOP>

        #endregion

        #region Public properties (expose data to consumers)

        <FIELD_LOOP>
        //<FIELD_DESC>
        public <FIELD_CSTYPE> <Field_Sqlname>
        {
            get
            {
                return p_<Field_Sqlname>;
            }
            set
            {
                <IF NUMERIC>
                <IF NOTDATE>
                if ((value>=<FIELD_MINVALUE>)&&(value<=<FIELD_MAXVALUE>))
                {
                    p_<Field_Sqlname> = value;
                }
                else
                {
                    throw new Exception("Value must be in the range <FIELD_MINVALUE> to <FIELD_MAXVALUE>.");
                }
                </IF>
                <IF DATE>
                p_<Field_Sqlname> = value;
                </IF>
                </IF>
                <IF NOTNUMERIC>
                p_<Field_Sqlname> = value;
                </IF>
            }
        }

        </FIELD_LOOP>

        //Expose the full Synergy record
        public string Record
        {
            get { return buildRecord(); }
            set { parseRecord(value); }
        }

        #endregion

        #region Utility methods

        private void parseRecord(string SynergyRecord)
        {
            <FIELD_LOOP>
            <IF ALPHA>
            p_<Field_Sqlname> = SynergyRecord.Substring(<FIELD_POSITION_ZERO>,<FIELD_SIZE>).Trim();
            </IF>
            <IF DECIMAL>
            <IF NOPRECISION>
            p_<Field_Sqlname> = Int32.Parse(SynergyRecord.Substring(<FIELD_POSITION_ZERO>,<FIELD_SIZE>));
            </IF>
            <IF PRECISION>
            p_<Field_Sqlname> = decimalFromAlpha(SynergyRecord.Substring(<FIELD_POSITION_ZERO>,<FIELD_SIZE>), <FIELD_PRECISION>);
            </IF>
            </IF>
            <IF DATE>
            p_<Field_Sqlname> = dateFromAlpha(SynergyRecord.Substring(<FIELD_POSITION_ZERO>,<FIELD_SIZE>));
            </IF>
            <IF TIME>
            p_<Field_Sqlname> = timeFromAlpha(SynergyRecord.Substring(<FIELD_POSITION_ZERO>,<FIELD_SIZE>));
            </IF>
            </FIELD_LOOP>
        }

        private string buildRecord()
        {
            string newRecord="";
            <FIELD_LOOP>
            <IF ALPHA>
            newRecord = newRecord.Insert(newRecord.Length, stringToAlpha(p_<Field_Sqlname>, <FIELD_SIZE>));
            </IF>
            <IF DECIMAL>
            <IF NOPRECISION>
            newRecord = newRecord.Insert(newRecord.Length, numericToAlpha(p_<Field_Sqlname>, <FIELD_SIZE>));
            </IF>
            <IF PRECISION>
            newRecord = newRecord.Insert(newRecord.Length, numericToAlpha(p_<Field_Sqlname>, <FIELD_SIZE>, <FIELD_PRECISION>));
            </IF>
            </IF>
            <IF DATE>
            newRecord = newRecord.Insert(newRecord.Length, dateToAlpha(p_<Field_Sqlname>, <FIELD_SIZE>));
            </IF>
            <IF TIME>
            newRecord = newRecord.Insert(newRecord.Length, timeToAlpha(p_<Field_Sqlname>, <FIELD_SIZE>));
            </IF>
            </FIELD_LOOP>

            return newRecord;
        }

        private string stringToAlpha(string svar, int len)
        {
            string avar;
            avar = svar.Trim();
            if (avar.Length<len)
                avar = avar.PadRight(len,char.Parse(" "));
            return avar;
        }

        private int intFromAlpha(string intval)
        {
            //TODO: Parsing int from a string is not implemented yet!
            int retVal = 0;
            return retVal;
        }

        private string numericToAlpha(int dvar, int len)
        {
            string mask = "";
            string avar;
            bool neg = (dvar<0);

            if (neg) dvar = -dvar;

            //Create a format mask
            mask = mask.PadLeft(len,char.Parse("0"));

            //Format the integer field using the format mask
            avar = dvar.ToString(mask);

            //Apply special encoding for negative numbers
            if (neg)
            {
                string negchar="";
                switch (avar.Substring(len-1,1))
                {
                    case "0":
                        negchar="p";
                        break;
                    case "1":
                        negchar="q";
                        break;
                    case "2":
                        negchar="r";
                        break;
                    case "3":
                        negchar="s";
                        break;
                    case "4":
                        negchar="t";
                        break;
                    case "5":
                        negchar="u";
                        break;
                    case "6":
                        negchar="v";
                        break;
                    case "7":
                        negchar="w";
                        break;
                    case "8":
                        negchar="x";
                        break;
                    case "9":
                        negchar="y";
                        break;
                }
                avar = avar.Substring(0, len - 1) + negchar;
            }

            return avar;
        }

        private long longFromAlpha(string longval)
        {
            //TODO: Parsing long from a string is not implemented yet!
            long retVal=0;
            return retVal;
        }

        private string numericToAlpha(long dvar, int len)
        {
            string mask = "";
            string avar;
            bool neg = (dvar < 0);

            if (neg) dvar = -dvar;

            //Create a format mask
            mask = mask.PadLeft(len, char.Parse("0"));

            //Format the integer field using the format mask
            avar = dvar.ToString(mask);

            //Apply special encoding for negative numbers
            if (neg)
            {
                string negchar = "";
                switch (avar.Substring(len - 1, 1))
                {
                    case "0":
                        negchar = "p";
                        break;
                    case "1":
                        negchar = "q";
                        break;
                    case "2":
                        negchar = "r";
                        break;
                    case "3":
                        negchar = "s";
                        break;
                    case "4":
                        negchar = "t";
                        break;
                    case "5":
                        negchar = "u";
                        break;
                    case "6":
                        negchar = "v";
                        break;
                    case "7":
                        negchar = "w";
                        break;
                    case "8":
                        negchar = "x";
                        break;
                    case "9":
                        negchar = "y";
                        break;
                }
                avar = avar.Substring(0, len - 1) + negchar;
            }

            return avar;
        }

        private decimal decimalFromAlpha(string decval, int prec)
        {
            //TODO: Parsing decimals from strings is not implemented yet!
            decimal retVal = 0;
            return retVal;
        }

        private string numericToAlpha(decimal dvar, int len, int prec)
        {

            //TODO: This routine needs to round the precision value from .NET based on the precision defined in Synergy

            //Record if the value is negative, and make it positive
            bool neg = (dvar < 0);
            if (neg) dvar = -dvar;

            //Remove the decimal point
            long lval=0;
            switch (prec)
            {
                case 1:
                    lval = (long)(dvar * 10);
                    break;
                case 2:
                    lval = (long)(dvar * 100);
                    break;
                case 3:
                    lval = (long)(dvar * 1000);
                    break;
                case 4:
                    lval = (long)(dvar * 10000);
                    break;
                case 5:
                    lval = (long)(dvar * 100000);
                    break;
                case 6:
                    lval = (long)(dvar * 1000000);
                    break;
                case 7:
                    lval = (long)(dvar * 10000000);
                    break;
                case 8:
                    lval = (long)(dvar * 100000000);
                    break;
                case 9:
                    lval = (long)(dvar * 1000000000);
                    break;
                case 10:
                    lval = (long)(dvar * 10000000000);
                    break;
            }

            //Define a numeric format mask of the correct length
            string mask = "";
            mask = mask.PadLeft(len, char.Parse("0"));

            //Format the numeric field using the format mask
            string avar;
            avar = lval.ToString(mask);

            //Apply Synergy negative number encoding
            if (neg)
            {
                string negchar = "";
                switch (avar.Substring(len - 1, 1))
                {
                    case "0":
                        negchar = "p";
                        break;
                    case "1":
                        negchar = "q";
                        break;
                    case "2":
                        negchar = "r";
                        break;
                    case "3":
                        negchar = "s";
                        break;
                    case "4":
                        negchar = "t";
                        break;
                    case "5":
                        negchar = "u";
                        break;
                    case "6":
                        negchar = "v";
                        break;
                    case "7":
                        negchar = "w";
                        break;
                    case "8":
                        negchar = "x";
                        break;
                    case "9":
                        negchar = "y";
                        break;
                }
                avar = avar.Substring(0, len - 1) + negchar;
            }
            return avar;
        }

        private DateTime dateFromAlpha(string dateString)
        {
            int year;
            int month;
            int day;
            DateTime retDate = new DateTime();
            switch (dateString.Length)
            {
                case 6: //YYMMDD
                    year = Int32.Parse(dateString.Substring(1, 2));
                    if (year <= 50) { year += 2000; } else { year += 1900; }
                    month = Int32.Parse(dateString.Substring(3, 2));
                    day = Int32.Parse(dateString.Substring(5, 2));
                    retDate = new DateTime(year, month, day);
                    break;
                case 8: //YYYYMMDD
                    year = Int32.Parse(dateString.Substring(1, 4));
                    month = Int32.Parse(dateString.Substring(5, 2));
                    day = Int32.Parse(dateString.Substring(7, 2));
                    retDate = new DateTime(year, month, day);
                    break;
            }
            return retDate;
        }

        private string dateToAlpha(DateTime dDate, int len)
        {
            string sDate="";
            int year = dDate.Year;
            int month =dDate.Month;
            int day=dDate.Day;
            switch (len)
            {
                case 6: //YYMMDD
                    sDate = sDate.Insert(sDate.Length, (year.ToString("0000").Substring(2,2)));
                    sDate = sDate.Insert(sDate.Length, month.ToString("00"));
                    sDate = sDate.Insert(sDate.Length, day.ToString("00"));
                    break;
                case 8: //YYYYMMDD
                    sDate = sDate.Insert(sDate.Length, year.ToString("0000"));
                    sDate = sDate.Insert(sDate.Length, month.ToString("00"));
                    sDate = sDate.Insert(sDate.Length, day.ToString("00"));
                    break;
            }
            return sDate;
        }

        private DateTime timeFromAlpha(string timeString)
        {
            int hour;
            int minute;
            int second;
            DateTime retDate = new DateTime();

            switch (timeString.Length)
            {
                case 4: //HHMM
                    hour = Int32.Parse(timeString.Substring(1, 2));
                    minute = Int32.Parse(timeString.Substring(3, 2));
                    retDate = new DateTime(1,1,1,hour,minute,0);
                    break;
                case 6: //HHMMSS
                    hour = Int32.Parse(timeString.Substring(1, 2));
                    minute = Int32.Parse(timeString.Substring(3, 2));
                    second = Int32.Parse(timeString.Substring(5, 2));
                    retDate = new DateTime(1,1,1,hour,minute,second);
                    break;
            }
            return retDate;
        }

        private string timeToAlpha(DateTime dTime, int len)
        {
            int hour = dTime.Hour; ;
            int minute=dTime.Minute;
            int second=dTime.Second;
            string sTime="";
            switch (len)
            {
                case 4: //HHMM
                    sTime = sTime.Insert(sTime.Length, dTime.Hour.ToString("00"));
                    sTime = sTime.Insert(sTime.Length, dTime.Minute.ToString("00"));
                    break;
                case 6: //HHMMSS
                    sTime = sTime.Insert(sTime.Length, dTime.Hour.ToString("00"));
                    sTime = sTime.Insert(sTime.Length, dTime.Minute.ToString("00"));
                    sTime = sTime.Insert(sTime.Length, dTime.Second.ToString("00"));
                    break;
            }
            return sTime;
        }

        #endregion
    }
}


;; *****************************************************************************
;; 
;;  Title:       Token.dbl
;; 
;;  Type:        Class
;; 
;;  Description: Classes and enumerations to descrive a token.
;; 
;;  Date:        30th August 2014
;; 
;;  Author:      Jeff Greene, Synergex Development
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************
import System
import System.Collections.Generic

.array 0

namespace CodeGen.Engine

    public enum TokenModifier
        XfCase
        MixedCase
        PascalCase
        CamelCase
        None
        LowerCase
    endenum

    public class Token

		public File					,string
		public StartColumn			,int
		public EndColumn			,int
		public StartLineNumber		,int
		public EndLineNumber		,int
		public Closer				,boolean
		public Value				,string
		public TypeOfToken			,TokenType
		public Modifier				,TokenModifier
		public Bucket				,@object
		public RequiresRepository	,boolean
		public RequiresNamespace	,boolean
		
		public method Token
            aFile				,string 
            aStartIndex			,int 
            aEndIndex			,int 
            aCloser				,boolean 
            aValue				,string 
            aType				,TokenType 
            aModifier			,TokenModifier 
            aBucket				,@object 
			aLineStarts			,[#]int
			aRequiresRepository	,boolean
			aRequiresNamespace	,boolean
			endparams
        proc
            File = aFile
            StartLineNumber = GetLineNumber(aStartIndex, aLineStarts)
            StartColumn = aStartIndex - aLineStarts[StartLineNumber]
            EndLineNumber = GetLineNumber(aEndIndex, aLineStarts)
            StartColumn = aEndIndex - aLineStarts[EndLineNumber]
            Closer = aCloser
            Value = aValue
			TypeOfToken = aType
            Modifier = aModifier
			Bucket = aBucket
			RequiresRepository = aRequiresRepository
			RequiresNamespace = aRequiresNamespace
		endmethod

        private static method GetLineNumber, int
            position	, int 
            lineStarts	, [#]int 
            endparams
        proc
            data index = Array.BinarySearch(lineStarts, position)
            if (index < 0)
            begin
                ;; less than zero means we didnt match exactly a line start but the ones complement will give us the nearest following line start
                ;; we want the nearest prior, so do the ones complement then subtract one from it to get the right position
				index = (~index) - 1
			end
            mreturn index
        endmethod

        public override method ToString, string
            endparams
        proc
			using TypeOfToken select
			
			(TokenType.FileHeader, TokenType.PreProcessor),
            begin
                if (Closer) then
					mreturn String.Format("{0}: </{1}>", TypeOfToken, Value)
                else
					mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
            end
			
            (TokenType.Text),
				mreturn String.Format("{0}: {1}", TypeOfToken, Value.Replace(%char(13), "<CR>").Replace(%char(10), "<LF>").Replace(%char(9), "<TAB>"))
			
			(TokenType.Generic, TokenType.StructureInfo, TokenType.FieldLoop, TokenType.FieldSelectionLoop, TokenType.KeyLoop, TokenType.KeySegmentLoop, TokenType.EnumLoop, TokenType.EnumMemberLoop, TokenType.RelationLoop, TokenType.ButtonLoop, TokenType.FileLoop, TokenType.TagLoop, TokenType.StructureLoop, TokenType.LoopUtility, TokenType.Window, TokenType.Counter, TokenType.User),
				mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
			
            (TokenType.Control),
            begin
                if (Closer) then
					mreturn String.Format("{0}: </{1}>", TypeOfToken, Value)
                else
					mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
            end
			
			(TokenType.Expression),
            begin
				mreturn String.Format("{0}: {1}", TypeOfToken, Value)
            end
            
            (TokenType.Loop, TokenType.NotInLoop),
            begin
                if (Closer) then
					mreturn String.Format("{0}: </{1}>", TypeOfToken, Value)
                else
					mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
            end
			
			(),
				mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
			
			endusing
		
		endmethod
	
	endclass

endnamespace


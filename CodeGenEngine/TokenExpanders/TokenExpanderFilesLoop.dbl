;; *****************************************************************************
;; 
;;  Title:       TokenExpanderFilesLoop.dbl
;; 
;;  Type:        Partial class
;; 
;;  Description: Expands files loop token nodes (different to file loop as top
;;               level and contains all files, not just structure files)
;; 
;;  Date:        17th September 2019
;; 
;;  Author:      Mark Brugnoli-Vinten
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.Linq
import System.Text
import System.Threading.Tasks
import CodeGen.RepositoryAPI

.array 0

namespace CodeGen.Engine

    public partial class TokenExpander

        filesLoopTokenExpanders, @Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, string>>

        private method registerFilesLoopTokens, void
            endparams
		proc

			filesLoopTokenExpanders = new Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, string>>()

            filesLoopTokenExpanders.Add("FSLOOP_ADDRESSING", expandFSloopAddressing)
            filesLoopTokenExpanders.Add("FSLOOP_CHANGE_TRACKING", expandFSloopChangeTracking)
            filesLoopTokenExpanders.Add("FSLOOP_COMPRESSION", expandFSloopCompression)
            filesLoopTokenExpanders.Add("FSLOOP_DENSITY", expandFSloopDensity)
            filesLoopTokenExpanders.Add("FSLOOP_DESC", expandFSloopDesc)
            filesLoopTokenExpanders.Add("FSLOOP_NAME", expandFSloopName)
			filesLoopTokenExpanders.Add("FSLOOP_NAME_NOEXT", expandFSloopNameNoExt)
			filesLoopTokenExpanders.Add("FSLOOP_ODBC_NAME", expandFSloopOdbcName)
            filesLoopTokenExpanders.Add("FSLOOP_PAGESIZE", expandFSloopPageSize)
            filesLoopTokenExpanders.Add("FSLOOP_RECORDSIZE", expandFSloopRecordSize)
            filesLoopTokenExpanders.Add("FSLOOP_RECTYPE", expandFSloopRecType)
			filesLoopTokenExpanders.Add("FSLOOP_RPS_NAME", expandFSloopRpsName)
			filesLoopTokenExpanders.Add("FSLOOP_STATIC_RFA", expandFSloopStaticRfa)
            filesLoopTokenExpanders.Add("FSLOOP_STORED_GRFA", expandFSloopStoredGrfa)
            filesLoopTokenExpanders.Add("FSLOOP_TYPE", expandFSloopType)
			filesLoopTokenExpanders.Add("FSLOOP_UTEXT", expandFSloopUserText)

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="tkn"></param>
        ;;; <param name="template"></param>
        ;;; <param name="loops"></param>
        ;;; <param name="specific"></param>
        ;;; <returns></returns>
        public static method ExpandFilesLoopToken, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            specific, @Func<RpsFile, string> 
            endparams
        proc
            lambda isFilesLoop(node) node .is. FilesLoopNode
            data loop, @FilesLoopNode
            if ((loops != ^null) && (loops.Count() > 0))
                loop = ^as(loops.FirstOrDefault(isFilesLoop), FilesLoopNode)
            
            data currentFile, @RpsFile
            if (loop != ^null)
                currentFile = loop.CurrentFile

            if (currentFile == ^null)
            begin
                if (template.Context.CurrentFile == ^null || !template.Context.FilesFirstMode)
                begin
                    throw new ApplicationException(String.Format("Attempt to use files loop token <{0}> with no current file!",tkn.Value))
                end
                currentFile = template.Context.CurrentFile
            end
            mreturn specific(currentFile)
        endmethod

        private static method expandFSloopAddressing, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile)
            begin
                data value, string, ""
                using (currentFile.Addressing) select
                (RpsFileAddressing.Addressing32Bit),
                    value = "32"
                (RpsFileAddressing.Addressing40Bit),
                    value = "40"
                endusing
                mreturn value
            end
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopChangeTracking, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.ChangeTracking ? "YES" : " NO"
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopCompression, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.RecordCompression ? "YES" : "NO"
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopDensity, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.Density.ToString()
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopDesc, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.Description
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.FileSpec
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopNameNoExt, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile)
            begin
                data value, string, currentFile.FileSpec
                ;; Remove the file extension
                if (value.Contains("."))
                    value = value.Substring(0, value.LastIndexOf("."))
                mreturn value
            end
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

		private static method expandFSloopOdbcName, string
			tkn, @Token 
			template, @FileNode 
			loops, @IEnumerable<LoopNode> 
			endparams
		proc
			lambda doExpand(currentFile)
			begin
				mreturn currentFile.OdbcTableNames[0]
			end
			mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
		endmethod

        private static method expandFSloopPageSize, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile)
            begin
                data value, string, ""
                using (currentFile.PageSize) select
                (RpsFilePageSize.PageSize512),
                    value = "512"
                (RpsFilePageSize.PageSize1024),
                    value = "1024"
                (RpsFilePageSize.PageSize2048),
                    value = "2048"
                (RpsFilePageSize.PageSize4096),
                    value = "4096"
                (RpsFilePageSize.PageSize8192),
                    value = "8192"
                (RpsFilePageSize.PageSize16384),
                    value = "16384"
                (RpsFilePageSize.PageSize32768),
                    value = "32768"
                (),
                    value = "4096"
                endusing
                mreturn value
            end
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopRecordSize, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile)
            begin
                mreturn currentFile.RecordSize.ToString()
            end

            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod
        
        private static method expandFSloopRecType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile)
            begin
                data value, string, ""
                using (currentFile.RecordType) select
                (RpsRecordType.FixedLength),
                    value = "FIXED"
                (RpsRecordType.MultipleFixedLength),
                    value = "MULTIPLE"
                (RpsRecordType.VariableLength),
                    value = "VARIABLE"
                endusing
                mreturn value
            end
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopRpsName, string
			tkn, @Token 
			template, @FileNode 
			loops, @IEnumerable<LoopNode> 
			endparams
		proc
			lambda doExpand(currentFile)
			begin
				mreturn currentFile.Name
			end
			mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
		endmethod

        private static method expandFSloopStaticRfa, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.StaticRFA ? "YES" : "NO"
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopStoredGrfa, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.StoredGRFA ? "YES" : "NO"
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.FileType
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFSloopUserText, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(currentFile) currentFile.UserText
            mreturn ExpandFilesLoopToken(tkn, template, loops, doExpand)
		endmethod

	endclass

endnamespace
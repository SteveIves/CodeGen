;; *****************************************************************************
;; 
;;  Title:       TokenExpanderParameterLoop.dbl
;; 
;;  Type:        Partial class
;; 
;;  Description: Expands parameter loop token nodes
;; 
;;  Date:        20th March 2018
;; 
;;  Author:      Steve Ives, Synergex Professional Services Group
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2018, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.Linq
import System.Text
import System.Threading.Tasks
import CodeGen.Engine
import CodeGen.MethodCatalogAPI
import CodeGen.RepositoryAPI

.array 0

namespace CodeGen.Engine

    public partial class TokenExpander

        parameterLoopTokenExpanders, @Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, string>>

        private method registerParameterLoopTokens, void
            endparams
        proc
            parameterLoopTokenExpanders = new Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, string>>()
            parameterLoopTokenExpanders.Add("PARAMETER_ATTRIBUTE", expandParameterAttribute)
            parameterLoopTokenExpanders.Add("PARAMETER_NAME", expandParameterName)
            parameterLoopTokenExpanders.Add("PARAMETER_NUMBER", expandParameterNumber)
            parameterLoopTokenExpanders.Add("PARAMETER_COMMENT", expandParameterComment)
            parameterLoopTokenExpanders.Add("PARAMETER_TYPE", expandParameterType)
            parameterLoopTokenExpanders.Add("PARAMETER_TSTYPE", expandParameterTsType)
            parameterLoopTokenExpanders.Add("PARAMETER_DEFINITION", expandParameterDefinition)
            parameterLoopTokenExpanders.Add("PARAMETER_DEFINITION_NOARRAY", expandParameterDefinitionNoarray)
            parameterLoopTokenExpanders.Add("PARAMETER_SIZE", expandParameterSize)
            parameterLoopTokenExpanders.Add("PARAMETER_PRECISION", expandParameterPrecision)
            parameterLoopTokenExpanders.Add("PARAMETER_ENUM", expandParameterEnum)
            parameterLoopTokenExpanders.Add("PARAMETER_STRUCTURE", expandParameterStructure)
            parameterLoopTokenExpanders.Add("PARAMETER_STRUCTURE_NOPLURAL", expandParameterStructure)
            parameterLoopTokenExpanders.Add("PARAMETER_STRUCTURE_PLURAL", expandParameterStructure)
            parameterLoopTokenExpanders.Add("PARAMETER_COERCE_TYPE", expandParameterCoerceType)
            parameterLoopTokenExpanders.Add("PARAMETER_DATE_FORMAT", expandParameterDateFormat)
            parameterLoopTokenExpanders.Add("PARAMETER_COLLECTION_TYPE", expandParameterCollectionType)
            parameterLoopTokenExpanders.Add("PARAMETER_DATA_TABLE", expandParameterDataTable)
            parameterLoopTokenExpanders.Add("PARAMETER_DIRECTION", expandParameterDirection)
            parameterLoopTokenExpanders.Add("PARAMETER_DIRECTION_PAD", expandParameterDirection)
            parameterLoopTokenExpanders.Add("PARAMETER_PASS_BY", expandParameterPassBy)
            parameterLoopTokenExpanders.Add("PARAMETER_REQUIRED", expandParameterRequired)
            parameterLoopTokenExpanders.Add("PARAMETER_SAMPLE_DATA", expandParameterSampleData)
            parameterLoopTokenExpanders.Add("PARAMETER_SAMPLE_DATA_ESCAPED", expandParameterSampleDataEscaped)
        endmethod

        public static method ExpandParameterLoopToken, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            specific, @Func<Smc, SmcInterface, SmcMethod, SmcParameter, string> 
            endparams
        proc
            lambda isParameterLoop(node) node .is. ParameterLoopNode
            data loop, @ParameterLoopNode, ^as(loops.First(isParameterLoop), ParameterLoopNode)
            mreturn specific(template.Context.Taskset.MethodCatalog,loop.CurrentInterface, loop.CurrentMethod, loop.CurrentParameter)
        endmethod

        private static method expandParameterAttribute, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                data typeValue = ""
                data coercedValue = ""
                data nullableValue = ""
                data formatValue = ""
                data collectionTypeValue = ""
                data structureValue = ""
                data dataTableValue = ""

                using param.Type select
                (ParameterType.Handle),
                    typeValue = ",type=SynType.handle"
                (ParameterType.BinaryHandle),
                    typeValue = ",type=SynType.binaryhandle"
                endusing

                using meth.ReturnValue.CoerceType select
                (CoerceType.Boolean),
                    coercedValue = ",cType=xfType.Boolean"
                (CoerceType.Byte),
                    coercedValue = ",cType=xfType.byte"
                (CoerceType.DateTime),
                    coercedValue = ",cType=xfType.DateTime"
                (CoerceType.DateTimeNullable),
                begin
                    coercedValue = ",cType=xfType.DateTime"
                    nullableValue = ",nullable=true"
                end
                (CoerceType.Decimal),
                    coercedValue = ",cType=xfType.decimal"
                (CoerceType.DecimalNullable),
                begin
                    coercedValue = "cType=xfType.decimal"
                    nullableValue = ",nullable=true"
                end
                (CoerceType.Double),
                    coercedValue = ",cType=xfType.double"
                (CoerceType.Float),
                    coercedValue = ",cType=xfType.float"
                (CoerceType.Int),
                    coercedValue = ",cType=xfType.int"
                (CoerceType.Long),
                    coercedValue = ",cType=xfType.long"
                (CoerceType.Sbyte),
                    coercedValue = ",cType=xfType.sbyte"
                (CoerceType.Short),
                    coercedValue = ",cType=xfType.short"
                (CoerceType.Uint),
                    coercedValue = ",cType=xfType.uint"
                (CoerceType.Ulong),
                    coercedValue = ",cType=xfType.ulong"
                (CoerceType.Ushort),
                    coercedValue = ",cType=xfType.ushort"
                endusing

                using meth.ReturnValue.DateFormat select
                (DateFormat.YYYYMMDD),
                    formatValue = ",format=xfFormat.YYYYMMDD"
                (DateFormat.YYMMDD),
                    formatValue = ",format=xfFormat.YYMMDD"
                (DateFormat.YYYYJJJ),
                    formatValue = ",format=xfFormat.YYYYJJJ"
                (DateFormat.YYJJJ),
                    formatValue = ",format=xfFormat.YYJJJ"
                (DateFormat.HHMMSS),
                    formatValue = ",format=xfFormat.HHMMSS"
                (DateFormat.HHMM),
                    formatValue = ",format=xfFormat.HHMM"
                (DateFormat.YYYYMMDDHHMISS),
                    formatValue = ",format=xfFormat.YYYYMMDDHHMISS"
                (DateFormat.YYYYMMDDHHMISSUUUUUU),
                    formatValue = ",format=xfFormat.YYYYMMDDHHMISSUUUUUU"
                endusing

                using param.CollectionType select
                (ParameterCollectionType.None,ParameterCollectionType.Array),
                begin
                    nop
                end
                (ParameterCollectionType.ArrayList,ParameterCollectionType.MemoryHandle),
                begin
                    using param.Type select
                    (ParameterType.Alpha),
                        collectionTypeValue = ",collectionType=xfCollectType.alpha"
                    (ParameterType.Decimal),
                        collectionTypeValue = ",collectionType=xfCollectType.decimal"
                    (ParameterType.ImpliedDecimal),
                        collectionTypeValue = ",collectionType=xfCollectType.impdec"
                    (ParameterType.Integer),
                        collectionTypeValue = ",collectionType=xfCollectType.integer"
                    (ParameterType.String),
                        collectionTypeValue = ",collectionType=xfCollectType.string"
                    (ParameterType.Structure),
                    begin
                        collectionTypeValue = ",collectionType=xfCollectType.structure"

                        data strPrefix = String.Empty
                        data strName = param.StructureName

                        ;; PARAMDEFSTR tweak
                        if (template.Context.CurrentTask.Tweaks.Count > 0 && template.Context.CurrentTask.Tweaks.Contains("PARAMDEFSTR"))
                        begin
                            strPrefix =  "str"
                            strName = StringTools.PascalCase(param.StructureName.EndsWith("S") ? param.StructureName.Substring(0,param.StructureName.Length-1) : param.StructureName)
                        end

                        structureValue = String.Format(',structure="{0}{1}"',strPrefix,strName)
                    end
                    endusing
                end
                endusing

                dataTableValue = param.DataTable ? ",dataTable=true" : ""

                mreturn String.Format('{0}xfParameter(name="{1}"{2}{3}{4}{5}{6}{7}{8}){9}',"{",param.Name,typeValue,coercedValue,nullableValue,formatValue,collectionTypeValue,structureValue,dataTableValue,"}")
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.Name
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterNumber, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.Number.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterComment, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.Comment
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.Type.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterTsType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            ;;Because of the syntax required for arrays and collections in TypeScript,
            ;;we can't return those things here, they must be constructed with template
            ;;file logic. So here we just return the base type for the parameter
            lambda doExpand(catalog,iface,meth,param)
            begin
                data collectionSuffix = String.Empty
                if (param.CollectionType != ParameterCollectionType.None)
                    collectionSuffix = "[]"

                using param.Type select
                (ParameterType.Alpha),
                    mreturn String.Format("string{0}",collectionSuffix)
                (ParameterType.Enumeration),
                    mreturn "number"
                (ParameterType.Handle),
                    mreturn "string"
                (ParameterType.Integer),
                begin
                    if (param.CoerceType == CoerceType.Boolean) then
                        mreturn String.Format("boolean{0}",collectionSuffix)
                    else
                        mreturn String.Format("number{0}",collectionSuffix)
                end
                (ParameterType.Decimal),
                begin
                    if (param.DateFormat != DateFormat.None) then
                    begin
                        if (param.CoerceType == CoerceType.DateTimeNullable) then
                            mreturn String.Format("Nullable<Date>{0}",collectionSuffix)
                        else
                            mreturn String.Format("Date{0}",collectionSuffix)
                    end
                    else if (param.CoerceType == CoerceType.Boolean) then
                        mreturn String.Format("boolean{0}",collectionSuffix)
                    else
                        mreturn String.Format("number{0}",collectionSuffix)
                end
                (ParameterType.Structure),
                begin
                    data structureType = StringTools.PascalCase(param.StructureName.EndsWith("S") ? param.StructureName.Substring(0,param.StructureName.Length-1) : param.StructureName)
                    mreturn String.Format("{0}{1}",structureType,collectionSuffix)
                end
                (ParameterType.BinaryHandle),
                    mreturn "string"
                (ParameterType.ImpliedDecimal),
                    mreturn String.Format("number{0}",collectionSuffix)
                (ParameterType.String),
                    mreturn String.Format("string{0}",collectionSuffix)
                (),
                    mreturn ""
                endusing
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterDefinition, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using param.CollectionType select
                (ParameterCollectionType.None,ParameterCollectionType.Array),
                begin
                    data arraySpec = param.CollectionType == ParameterCollectionType.Array ? "[*]" : String.Empty

                    using param.Type select
                    (ParameterType.Alpha),
                    begin
                        mreturn String.Format("{0}a{1}",arraySpec,param.Size)
                    end
                    (ParameterType.Decimal),
                    begin
                        mreturn String.Format("{0}d{1}",arraySpec,param.Size)
                    end
                    (ParameterType.Enumeration),
                    begin
                        mreturn param.EnumName
                    end
                    (ParameterType.Handle, ParameterType.BinaryHandle),
                    begin
                        mreturn "D_HANDLE"
                    end
                    (ParameterType.ImpliedDecimal),
                    begin
                        mreturn String.Format("{0}d{1}.{2}",arraySpec,param.Size,param.Precision)
                    end
                    (ParameterType.Integer),
                    begin
                        mreturn String.Format("{0}i{1}",arraySpec,param.Size)
                    end
                    (ParameterType.String),
                    begin
                        mreturn "string"
                    end
                    (ParameterType.Structure),
                    begin
                        data strPrefix = String.Empty
                        data strName = param.StructureName

                        ;; PARAMDEFSTR tweak
                        if (template.Context.CurrentTask.Tweaks.Contains("PARAMDEFSTR"))
                        begin
                            strPrefix =  "str"
                            strName = StringTools.PascalCase(param.StructureName.EndsWith("S") ? param.StructureName.Substring(0,param.StructureName.Length-1) : param.StructureName)
                        end
                        mreturn String.Format("{0}{1}{2}",arraySpec,strPrefix,strName)
                    end
                    endusing
                end
                (ParameterCollectionType.MemoryHandle),
                begin
                    mreturn "D_HANDLE"
                end
                (ParameterCollectionType.ArrayList),
                begin
                    mreturn "@ArrayList"
                end
                endusing

            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterDefinitionNoarray, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using param.CollectionType select
                (ParameterCollectionType.None,ParameterCollectionType.Array),
                begin
                    using param.Type select
                    (ParameterType.Alpha),
                    begin
                        mreturn String.Format("a{0}",param.Size)
                    end
                    (ParameterType.Decimal),
                    begin
                        mreturn String.Format("a{0}",param.Size)
                    end
                    (ParameterType.Enumeration),
                    begin
                        mreturn param.EnumName
                    end
                    (ParameterType.Handle, ParameterType.BinaryHandle),
                    begin
                        mreturn "D_HANDLE"
                    end
                    (ParameterType.ImpliedDecimal),
                    begin
                        mreturn String.Format("d{0}.{1}",param.Size,param.Precision)
                    end
                    (ParameterType.Integer),
                    begin
                        mreturn String.Format("i{0}",param.Size)
                    end
                    (ParameterType.String),
                    begin
                        mreturn "string"
                    end
                    (ParameterType.Structure),
                    begin
                        data strPrefix = String.Empty
                        data strName = param.StructureName

                        ;; PARAMDEFSTR tweak
                        if (template.Context.CurrentTask.Tweaks.Count > 0 && template.Context.CurrentTask.Tweaks.Contains("PARAMDEFSTR"))
                        begin
                            strPrefix =  "str"
                            strName = StringTools.PascalCase(param.StructureName.EndsWith("S") ? param.StructureName.Substring(0,param.StructureName.Length-1) : param.StructureName)
                        end
                        mreturn String.Format("{0}{1}",strPrefix,strName)
                    end
                    endusing
                end
                (ParameterCollectionType.MemoryHandle),
                begin
                    mreturn "D_HANDLE"
                end
                (ParameterCollectionType.ArrayList),
                begin
                    mreturn "@ArrayList"
                end
                endusing

            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterSize, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using param.Type select
                (ParameterType.Alpha,ParameterType.Decimal,ParameterType.ImpliedDecimal,ParameterType.Integer,ParameterType.Enumeration),
                    mreturn param.Size.ToString()
                (ParameterType.Handle,ParameterType.BinaryHandle,ParameterType.String),
                    mreturn 0
                (ParameterType.Structure),
                begin
                    lambda isParameterLoop(node) (node .is. ParameterLoopNode)
                    data loop, @ParameterLoopNode, ^as(loops.First(isParameterLoop), ParameterLoopNode)
                    mreturn loop.CurrentStructure.Length.ToString()
                end
                endusing
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterPrecision, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.Precision > 0 ? param.Precision.ToString() : String.Empty
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterEnum, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.EnumName
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterStructure, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using tkn.Value select
                ("PARAMETER_STRUCTURE_NOPLURAL"),
                begin
                    data strPrefix = String.Empty
                    data strName = param.StructureName.EndsWith("S") ? param.StructureName.Substring(0,param.StructureName.Length-1) : param.StructureName

                    ;; PARAMDEFSTR tweak
                    if (template.Context.CurrentTask.Tweaks.Count > 0 && template.Context.CurrentTask.Tweaks.Contains("PARAMDEFSTR"))
                    begin
                        strPrefix =  "STR_"
                    end

                    mreturn String.Format("{0}{1}",strPrefix,strName)
                end
                ("PARAMETER_STRUCTURE_PLURAL"),
                begin
                    data strPrefix = String.Empty
                    data strName = param.StructureName.EndsWith("S") ? param.StructureName : String.Format("{0}S",param.StructureName)

                    ;; PARAMDEFSTR tweak
                    if (template.Context.CurrentTask.Tweaks.Count > 0 && template.Context.CurrentTask.Tweaks.Contains("PARAMDEFSTR"))
                    begin
                        strPrefix =  "STR_"
                    end

                    mreturn String.Format("{0}{1}",strPrefix,strName)
                end
                (), ;"PARAMETER_STRUCTURE"
                begin
                    data strPrefix = String.Empty
                    data strName = param.StructureName

                    ;; PARAMDEFSTR tweak
                    if (template.Context.CurrentTask.Tweaks.Count > 0 && template.Context.CurrentTask.Tweaks.Contains("PARAMDEFSTR"))
                    begin
                        strPrefix =  "STR_"
                    end

                    mreturn String.Format("{0}{1}",strPrefix,strName)
                end
                endusing
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterCoerceType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.CoerceType.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterDateFormat, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.DateFormat.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterCollectionType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.CollectionType.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterDataTable, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.DataTable.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterDirection, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using tkn.Value select
                ("PARAMETER_DIRECTION_PAD"),
                    mreturn param.Direction.ToString().ToUpper().PadRight(5)
                ("PARAMETER_DIRECTION"),
                    mreturn param.Direction.ToString().ToUpper()
                endusing
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterPassBy, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.PassBy.ToString()
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterRequired, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param) param.Required ? "REQUIRED" : "OPTIONAL"
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterSampleData, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using param.Type select
                (ParameterType.Alpha),
                begin
                    mreturn '"Z"'
                end
                (ParameterType.BinaryHandle),
                begin
                    mreturn '""'
                end
                (ParameterType.Decimal),
                begin
                    mreturn '9'
                end
                (ParameterType.ImpliedDecimal),
                begin
                    mreturn '9.9'
                end
                (ParameterType.Enumeration),
                begin
                    mreturn '""'
                end
                (ParameterType.Handle),
                begin
                    mreturn '""'
                end
                (ParameterType.Integer),
                begin
                    mreturn '9'
                end
                (ParameterType.String),
                begin
                    mreturn '"Z"'
                end
                (ParameterType.Structure),
                begin
                    mreturn '""'
                end
                endusing
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandParameterSampleDataEscaped, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(catalog,iface,meth,param)
            begin
                using param.Type select
                (ParameterType.Alpha),
                begin
                    mreturn '\"Z\"'
                end
                (ParameterType.BinaryHandle),
                begin
                    mreturn '\"\"'
                end
                (ParameterType.Decimal),
                begin
                    mreturn '9'
                end
                (ParameterType.ImpliedDecimal),
                begin
                    mreturn '9.9'
                end
                (ParameterType.Enumeration),
                begin
                    mreturn '\"\"'
                end
                (ParameterType.Handle),
                begin
                    mreturn '\"\"'
                end
                (ParameterType.Integer),
                begin
                    mreturn '9'
                end
                (ParameterType.String),
                begin
                    mreturn '\"Z\"'
                end
                (ParameterType.Structure),
                begin
                    mreturn '\"\"'
                end
                endusing
            end
            mreturn ExpandParameterLoopToken(tkn, template, loops, doExpand)
        endmethod

    endclass

endnamespace

;; *****************************************************************************
;; 
;;  Title:       LoopExpander.dbl
;; 
;;  Type:        Class
;; 
;;  Description: Implements logic to iterate various template file loop constructs
;; 
;;  Date:        30th August 2014
;; 
;;  Authors:     Steve Ives, Synergex Professional Services Group
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.IO
import System.Linq
import CodeGen.MethodCatalogAPI
import CodeGen.RepositoryAPI

.array 0

namespace CodeGen.Engine

	public static class LoopExpander

        private static loopProcessors, @Dictionary<string, Action<LoopNode, FileNode, IEnumerable<LoopNode>, ITreeNodeVisitor>>

        static method LoopExpander
        proc

            loopProcessors = new Dictionary<string, Action<LoopNode, FileNode, IEnumerable<LoopNode>, ITreeNodeVisitor>>()

            loopProcessors.Add("FIELD_LOOP", processFieldLoop)
            loopProcessors.Add("KEY_LOOP", processKeyLoop)
            loopProcessors.Add("ALTERNATE_KEY_LOOP", processAlternateKeyLoop)
            loopProcessors.Add("PRIMARY_KEY", processPrimaryKeyLoop)
			loopProcessors.Add("UNIQUE_KEY", processUniqueKeyLoop)
            loopProcessors.Add("ENUM_LOOP", processEnumLoop)
            loopProcessors.Add("ENUM_LOOP_STRUCTURE", processStructureEnumLoop)
            loopProcessors.Add("RELATION_LOOP", processRelationLoop)
			loopProcessors.Add("FROM_KEY_SEGMENT_LOOP", processFromKeySegmentLoop)
			loopProcessors.Add("FROM_KEY_SEGMENT_LOOP_RESTRICTED", processFromKeySegmentLoopRestricted)
			loopProcessors.Add("TO_KEY_SEGMENT_LOOP", processToKeySegmentLoop)
			loopProcessors.Add("TO_KEY_SEGMENT_LOOP_RESTRICTED", processToKeySegmentLoopRestricted)
			loopProcessors.Add("BUTTON_LOOP", processButtonLoop)
            loopProcessors.Add("FILE_LOOP", processFileLoop)
			loopProcessors.Add("TAG_LOOP", processTagLoop)
            loopProcessors.Add("SELECTION_LOOP", processFieldSelectionLoop)
            loopProcessors.Add("SEGMENT_LOOP", processKeySegmentLoop)
            loopProcessors.Add("SEGMENT_LOOP_FILTER", processKeySegmentFilterLoop)
            loopProcessors.Add("FIRST_SEGMENT", processFirstKeySegmentLoop)
            loopProcessors.Add("SECOND_SEGMENT", ProcessSecondKeySegmentLoop)
            loopProcessors.Add("ENUM_MEMBER_LOOP", processEnumMemberLoop)
			loopProcessors.Add("STRUCTURE_LOOP", processStructureLoop)
			loopProcessors.Add("INTERFACE_LOOP", processInterfaceLoop)
			loopProcessors.Add("METHOD_LOOP", processMethodLoop)
			loopProcessors.Add("PARAMETER_LOOP", processParameterLoop)

        endmethod

        ;;; <summary>
        ;;; This method is called by TreeExpander whenever a loop node is encountered in the tree.
        ;;; It determines which method should be used to expand the loop and calls that method.
        ;;; </summary>
        ;;; <param name="node"></param>
        ;;; <param name="file"></param>
        ;;; <param name="loopContext"></param>
        ;;; <param name="visitor"></param>
        public static method ProcessLoop, void
            required in node,			@LoopNode 
			required in tpl,			@FileNode 
			required in loopContext,	@IEnumerable<LoopNode> 
			required in visitor,		@ITreeNodeVisitor 
        proc
            if (loopProcessors.ContainsKey(node.OpenToken.Value)) then
                loopProcessors[node.OpenToken.Value](node, tpl, loopContext, visitor)
            else
                throw new ApplicationException(String.Format("CODEGEN BUG: LoopExpander doesn't define a processor for <{0}>!", node.OpenToken.Value))
        endmethod

        private static method processFieldLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, FieldLoopNode)
            data context = template.Context
			
			;;Make sure we have a current structure. We could get here at runtime if the developer tries to use a field loop
			;;within a parameter loop, with a non-structure parameter!
			if (context.CurrentStructure == ^null)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because there is no current structure!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

			;;Make sure the current structure has fields
			if (context.CurrentStructure.Fields.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no fields!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
			
			loop.MaxIndex = context.CurrentStructure.Fields.Count - 1
			
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} fields", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
			
			data ix, int
			for ix from 0 thru context.CurrentStructure.Fields.Count - 1
			begin
				loop.CurrentField = context.CurrentStructure.Fields[ix]
				loop.CurrentIndex = ix
				expander.Visit(node.Body)
			end
		
		endmethod

        private static method processKeyLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
			data context = template.Context

            if (template.Context.CurrentStructure.Keys.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, template.Context.CurrentStructure.Name))
			
			loop.MaxIndex = template.Context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

			data ix, int
			loop.FirstUniqueKeyNumber = -1
			for ix from 0 thru template.Context.CurrentStructure.Keys.Count - 1
			begin
				;;Skip any Foreign keys
				if (template.Context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
					nextloop
				;;Look for the first unique key
				if (template.Context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
				begin
					loop.FirstUniqueKeyNumber = ix
					exitloop
				end
			end

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
			
			for ix from 0 thru template.Context.CurrentStructure.Keys.Count - 1
			begin
				;;Skip any Foreign keys
				if (template.Context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
					nextloop

				loop.CurrentKey = template.Context.CurrentStructure.Keys[ix]
				loop.CurrentIndex = ix
				expander.Visit(node.Body)
			end
		
		endmethod

        private static method processAlternateKeyLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
			
			if (template.Context.CurrentStructure.Keys.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, template.Context.CurrentStructure.Name))
			
			data ix, int

			loop.MaxIndex = template.Context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

			loop.FirstUniqueKeyNumber = -1
			for ix from 0 thru template.Context.CurrentStructure.Keys.Count - 1
			begin
				;;Skip any Foreign keys
				if (template.Context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
					nextloop
				;;Look for the first unique key
				if (template.Context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
				begin
					loop.FirstUniqueKeyNumber = ix
					exitloop
				end
			end

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			for ix from 0 thru template.Context.CurrentStructure.Keys.Count - 1
			begin
				;; Skip the first key and any alternate keys
				if ((ix == 0) || (template.Context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign))
					nextloop

				;; Then process as normal
				loop.CurrentKey = template.Context.CurrentStructure.Keys[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
			
        endmethod

        private static method processPrimaryKeyLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
			data loop = ^as(node, KeyLoopNode)
			data context = template.Context

            if (template.Context.CurrentStructure.Keys.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, template.Context.CurrentStructure.Name))
			
			if ((template.Context.CurrentTask.PrimaryKeyNumber > 0) && (template.Context.CurrentTask.PrimaryKeyNumber > (template.Context.CurrentStructure.Keys.Count - 1)))
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed using alternate key {3} because structure {4} only has {5} keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, template.Context.CurrentTask.PrimaryKeyNumber, template.Context.CurrentStructure.Name, template.Context.CurrentStructure.Keys.Count + 1))
			
			loop.CurrentKey = template.Context.CurrentStructure.Keys[template.Context.CurrentTask.PrimaryKeyNumber]
            loop.CurrentIndex = template.Context.CurrentTask.PrimaryKeyNumber
			loop.MaxIndex = template.Context.CurrentTask.PrimaryKeyNumber

			data ix, int
			loop.FirstUniqueKeyNumber = -1
			for ix from 0 thru template.Context.CurrentStructure.Keys.Count - 1
			begin
				;;Skip any Foreign keys
				if (template.Context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
					nextloop
				;;Look for the first unique key
				if (template.Context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
				begin
					loop.FirstUniqueKeyNumber = ix
					exitloop
				end
			end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 key", string.Format("<{0}>", loop.OpenToken.Value)))
			
			expander.Visit(node.Body)
				
        endmethod

		private static method processUniqueKeyLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
		proc
			data loop = ^as(node, KeyLoopNode)
			data context = template.Context
			
			if (template.Context.CurrentStructure.Keys.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, template.Context.CurrentStructure.Name))
			
			if (!template.Context.CurrentStructure.Keys.Any(lambda (k) {(k.Duplicates == RpsKeyDuplicates.NoDuplicates) && (k.KeyType == RpsKeyType.Access)}))
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no unique keys!",node.OpenToken.Value,node.OpenToken.StartLineNumber,template.Context.CurrentTemplateBaseName,template.Context.CurrentStructure.Name))
			
			loop.CurrentKey = template.Context.CurrentStructure.Keys.First(lambda (k) {k.Duplicates == RpsKeyDuplicates.NoDuplicates})
			loop.CurrentIndex = template.Context.CurrentStructure.Keys.IndexOf(loop.CurrentKey)
			loop.MaxIndex = loop.CurrentIndex
			
			data ix, int
			loop.FirstUniqueKeyNumber = -1
			for ix from 0 thru template.Context.CurrentStructure.Keys.Count - 1
			begin
				;;Skip any Foreign keys
				if (template.Context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
					nextloop
				;;Look for the first unique key
				if (template.Context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
				begin
					loop.FirstUniqueKeyNumber = ix
					exitloop
				end
			end

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 key", string.Format("<{0}>", loop.OpenToken.Value)))
			
			expander.Visit(node.Body)
			
		endmethod
		
		private static method processEnumLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, EnumLoopNode)
			data context = template.Context

			if (template.Context.Repository == ^null)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no repository is being processed!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))
			
			if (template.Context.Repository.Enumerations.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no enumerations are defined!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))
			
			loop.MaxIndex = template.Context.Repository.Enumerations.Count - 1

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enums", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			data ix, int
			for ix from 0 thru template.Context.Repository.Enumerations.Count - 1
			begin
				loop.CurrentEnumeration = template.Context.Repository.Enumerations[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
			
        endmethod

        private static method processStructureEnumLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, EnumLoopNode)
			data context = template.Context

			if (template.Context.Repository.Enumerations.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no enumerations are defined!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))

			;;Build a collection of enums that are referred to by the current structure
			data enumsToProcess = new RpsEnumCollection(template.Context.CurrentStructure.Name)

			loop.MaxIndex = enumsToProcess.Count - 1
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enums", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			;;Anything to do?
			if (loop.MaxIndex == -1)
				mreturn

			;;Yes, process the subset of enumerations
			data ix, int
			for ix from 0 thru loop.MaxIndex
			begin
				loop.CurrentEnumeration = enumsToProcess[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
			
        endmethod

        private static method processRelationLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, RelationLoopNode)
            data context = template.Context
			
			if (template.Context.CurrentStructure.Relations.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no relations!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, template.Context.CurrentStructure.Name))
			
			loop.MaxIndex = template.Context.CurrentStructure.Relations.Count - 1

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} relations", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			data ix, int
			for ix from 0 thru template.Context.CurrentStructure.Relations.Count - 1
			begin
				loop.CurrentRelation = template.Context.CurrentStructure.Relations[ix]
				loop.CurrentIndex = ix

				;;Locate the "from key" information
				lambda isFromKey(k) k.Name == loop.CurrentRelation.FromKey
				loop.FromKey = template.Context.CurrentStructure.Keys.First(isFromKey)

				;;Locate the "to structure" information
                lambda isToStructure(s) s.Name == loop.CurrentRelation.ToStructure
                loop.ToStructure = template.Context.Structures.First(isToStructure)

				;Load the "to key" information
				lambda isToKey(k) k.Name == loop.CurrentRelation.ToKey
				loop.ToKey = loop.ToStructure.Keys.First(isToKey)

				expander.Visit(node.Body)
			end
			
        endmethod

        private static method processButtonLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            ;; TODO: Button loops need context data
			
			data loop = ^as(node, ButtonLoopNode)
            data context = template.Context
			
			template.Context.Buttons = new WscButtonCollection()
			
			if ((template.Context.Buttons == ^null) || (template.Context.Buttons.Count == 0))
				mreturn

            loop.MaxIndex = template.Context.Buttons.Count - 1
			
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} buttons", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
			
			data ix, int
			for ix from 0 thru template.Context.Buttons.Count - 1
			begin
				loop.CurrentButton = template.Context.Buttons[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
			
        endmethod

        private static method processFileLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, FileLoopNode)
            data context = template.Context
			
			if (context.CurrentStructure.Files.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} is not assigned to any files!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, context.CurrentStructure.Name))
			
			loop.MaxIndex = context.CurrentStructure.Files.Count - 1

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} files", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			data ix, int
			for ix from 0 thru context.CurrentStructure.Files.Count - 1
			begin
				loop.CurrentFile = context.CurrentStructure.Files[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
			
        endmethod

        private static method processTagLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data loop = ^as(node, TagLoopNode)
            data context = template.Context
			
			loop.MaxIndex = template.Context.CurrentStructure.Tags.Count - 1
			
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} tags", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
			
			;; Tag loops just do nothing if no tags are defined!
			data ix, int
			for ix from 0 thru template.Context.CurrentStructure.Tags.Count - 1
			begin
				loop.CurrentTag = template.Context.CurrentStructure.Tags[ix]
				loop.CurrentIndex = ix
				
				expander.Visit(node.Body)
					
			end
			
        endmethod

        private static method processFieldSelectionLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. FieldLoopNode}), FieldLoopNode)
            data loop = ^as(node, SelectionLoopNode)
			data context = template.Context

            if (outerLoop.CurrentField.SelectionList.Count > 0)
            begin
                loop.MaxIndex = outerLoop.CurrentField.SelectionList.Count - 1
				loop.CurrentField = outerLoop.CurrentField

				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} selections", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

				data ix, int
				for ix from 0 thru outerLoop.CurrentField.SelectionList.Count - 1
				begin
					loop.CurrentSelection = outerLoop.CurrentField.SelectionList[ix]
					loop.CurrentIndex = ix
					
					expander.Visit(node.Body)
						
				end
			end

        endmethod

        private static method processKeySegmentLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
			data context = template.Context

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                loop.CurrentKey = outerLoop.CurrentKey
                loop.MaxIndex = outerLoop.CurrentKey.Segments.Count - 1
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
				
				data ix, int
				for ix from 0 thru outerLoop.CurrentKey.Segments.Count - 1
				begin
					loop.CurrentSegment = outerLoop.CurrentKey.Segments[ix]
					loop.CurrentIndex = ix
					loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

					expander.Visit(node.Body)
				end
				
			end

        endmethod

        private static method getFieldForSegment, @RpsField
            required in str, @RpsStructure 
            required in seg, @RpsKeySegment 
        proc
			if (seg.SegmentType == RpsKeySegmentType.Field) then
			begin
				try
                begin
                    mreturn str.Fields.First(lambda (fld) { fld.OriginalName == seg.Field })
				end
				catch (ex, @Exception)
				begin
					throw new ApplicationException(String.Format("When processing structure {0} key segment field {1} was not found.", str.Name, seg.Field))
				end
				endtry
			end
			else
				mreturn ^null
        endmethod

        private static method processKeySegmentFilterLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context
			
			if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                loop.CurrentKey = outerLoop.CurrentKey
                loop.MaxIndex = outerLoop.CurrentKey.Segments.Count - 2
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
				
				data ix, int, 0
                while (ix < outerLoop.CurrentKey.Segments.Count - 1) do
                begin
                    loop.CurrentSegment = outerLoop.CurrentKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)
					
					expander.Visit(node.Body)
						
                    ^incr(ix, true)
                end
			end

        endmethod

        private static method processFirstKeySegmentLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context
			
			if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                ;; Only process the first segment
                loop.CurrentKey = outerLoop.CurrentKey
                loop.CurrentSegment = outerLoop.CurrentKey.Segments[0]
                loop.CurrentIndex = 0
                loop.MaxIndex = 0
                loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 segment", string.Format("<{0}>", loop.OpenToken.Value)))
				
				expander.Visit(node.Body)
			end

        endmethod

        private static method ProcessSecondKeySegmentLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
			data context = template.Context

            if (outerLoop.CurrentKey.Segments.Count > 1)
            begin
                ;; Only process the second segment
                loop.CurrentKey = outerLoop.CurrentKey
                loop.CurrentSegment = outerLoop.CurrentKey.Segments[1]
                loop.CurrentIndex = 1
                loop.MaxIndex = 1
                loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 segment", string.Format("<{0}>", loop.OpenToken.Value)))

				expander.Visit(node.Body)
			end

        endmethod

        private static method processEnumMemberLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. EnumLoopNode}), EnumLoopNode)
            data loop = ^as(node, EnumMemberLoopNode)
			data context = template.Context

            loop.CurrentEnumeration = outerLoop.CurrentEnumeration
			loop.MaxIndex = outerLoop.CurrentEnumeration.Members.Count - 1

			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enum members", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			data ix, int
			for ix from 0 thru outerLoop.CurrentEnumeration.Members.Count - 1
			begin
				loop.CurrentMember = loop.CurrentEnumeration.Members[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end

        endmethod

		private static method processFromKeySegmentLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
		proc
			data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
			data loop = ^as(node, RelationSegmentLoopNode)
			data context = template.Context

			if (outerLoop.FromKey.Segments.Count > 0)
			begin
				loop.CurrentRelation = outerLoop.CurrentRelation
				loop.CurrentKey = outerLoop.FromKey
				loop.MaxIndex = outerLoop.FromKey.Segments.Count - 1
				loop.ToStructure = outerLoop.ToStructure
				loop.ToKey = outerLoop.ToKey
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
				
				data ix, int
				for ix from 0 thru outerLoop.FromKey.Segments.Count - 1
				begin
					loop.CurrentSegment = outerLoop.FromKey.Segments[ix]
					loop.CurrentIndex = ix
					loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

					expander.Visit(node.Body)
				end
			end
		endmethod

		private static method processFromKeySegmentLoopRestricted, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
		proc
			data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
			data loop = ^as(node, RelationSegmentLoopNode)
			data context = template.Context

			if (outerLoop.FromKey.Segments.Count > 0)
			begin
				loop.CurrentRelation = outerLoop.CurrentRelation
				loop.CurrentKey = outerLoop.FromKey
				loop.MaxIndex = outerLoop.FromKey.Segments.Count - 1
				loop.ToStructure = outerLoop.ToStructure
				loop.ToKey = outerLoop.ToKey
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

				data lengthSoFar = 0
				
				data ix, int
				for ix from 0 thru outerLoop.FromKey.Segments.Count - 1
				begin
					loop.CurrentSegment = outerLoop.FromKey.Segments[ix]
					loop.CurrentIndex = ix
					loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

					lengthSoFar += loop.CurrentSegment.Length
					if (lengthSoFar == outerLoop.ToKey.Size)
						loop.MaxIndex = loop.CurrentIndex

					expander.Visit(node.Body)

					if (lengthSoFar == outerLoop.ToKey.Size)
						exitloop
				end
			end
		endmethod

		private static method processToKeySegmentLoop, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
		proc
			data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
			data loop = ^as(node, RelationSegmentLoopNode)
			data context = template.Context

			if (outerLoop.ToKey.Segments.Count > 0)
			begin
				loop.CurrentRelation = outerLoop.CurrentRelation
				loop.CurrentKey = outerLoop.ToKey
				loop.MaxIndex = outerLoop.ToKey.Segments.Count - 1
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
				
				data ix, int
				for ix from 0 thru outerLoop.ToKey.Segments.Count - 1
				begin
					loop.CurrentSegment = outerLoop.ToKey.Segments[ix]
					loop.CurrentIndex = ix
					loop.CurrentField = getFieldForSegment(outerLoop.ToStructure, loop.CurrentSegment)

					expander.Visit(node.Body)
				end
			end
		endmethod

		private static method processToKeySegmentLoopRestricted, void
			required in node,		@LoopNode 
			required in template,	@FileNode 
			required in loops,		@IEnumerable<LoopNode> 
			required in expander,	@ITreeNodeVisitor 
		proc
			data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
			data loop = ^as(node, RelationSegmentLoopNode)
			data context = template.Context

			data lengthSoFar = 0

			if (outerLoop.ToKey.Segments.Count > 0)
			begin
				loop.CurrentRelation = outerLoop.CurrentRelation
				loop.CurrentKey = outerLoop.ToKey
				loop.MaxIndex = outerLoop.ToKey.Segments.Count - 1
				
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))
				
				data ix, int
				for ix from 0 thru outerLoop.ToKey.Segments.Count - 1
				begin
					loop.CurrentSegment = outerLoop.ToKey.Segments[ix]
					loop.CurrentIndex = ix
					loop.CurrentField = getFieldForSegment(outerLoop.ToStructure, loop.CurrentSegment)

					lengthSoFar += loop.CurrentSegment.Length
					if (lengthSoFar == outerLoop.FromKey.Size)
						loop.MaxIndex = loop.CurrentIndex

					expander.Visit(node.Body)

					if (lengthSoFar == outerLoop.FromKey.Size)
						exitloop
				end
			end
		endmethod

		private static method processStructureLoop, void
			required in node, @LoopNode 
			required in template, @FileNode 
			required in loops, @IEnumerable<LoopNode> 
			required in expander, @ITreeNodeVisitor 
        proc
            data loop = ^as(node, StructureLoopNode)
            data context = template.Context
            data task = context.CurrentTask
			
			if (!context.MultiStructureMode)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because multi-structure mode (-ms) has not been enabled!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
			
			loop.MaxIndex = context.Structures.Count - 1

            ;; Debug log beginning of structure loop
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} structures", string.Format("<{0}>", loop.OpenToken.Value), context.Structures.Count))

			data ix, int
			for ix from 0 thru context.Structures.Count - 1
			begin
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1}", String.Format("Structure {0}/{1}", ix + 1, context.Structures.Count - 1), context.Structures[ix].Name), true, false)
				context.CurrentStructure = context.Structures[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end

            ;; Debug log end of structure loop
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} ->", string.Format("</{0}>", loop.CloseToken.Value)))
		
		endmethod
	
		private static method processInterfaceLoop, void
			required in node, @LoopNode 
			required in template, @FileNode 
			required in loops, @IEnumerable<LoopNode> 
			required in expander, @ITreeNodeVisitor 
		proc
			data loop = ^as(node, InterfaceLoopNode)
			data context = template.Context
			data taskSet = context.Taskset
			data task = context.CurrentTask
			
			;;Make sure we have SMC data
			if (taskSet.MethodCatalog == ^null)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))

			if (taskSet.MethodCatalog.Interfaces.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))
			
			loop.MaxIndex = taskSet.MethodCatalog.Interfaces.Count - 1
			
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} interfaces", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			data ix, int
			for ix from 0 thru taskSet.MethodCatalog.Interfaces.Count - 1
			begin
				loop.CurrentInterface = taskSet.MethodCatalog.Interfaces[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
		
		endmethod

		private static method processMethodLoop, void
			required in node, @LoopNode 
			required in template, @FileNode 
			required in loops, @IEnumerable<LoopNode> 
			required in expander, @ITreeNodeVisitor 
		proc
			data loop = ^as(node, MethodLoopNode)
			data context = template.Context
			data taskset = context.Taskset
			data task = context.CurrentTask
			data currentInterface, @SmcInterface
			try
			begin
				data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. InterfaceLoopNode}), InterfaceLoopNode)
				currentInterface = outerLoop.CurrentInterface
			end
			catch (e, @InvalidOperationException)
			begin
				;;We're not using an <INTERFACE_LOOP> so there is no "outer" loop
				currentInterface = taskset.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.Equals(taskset.Interface)})
			end
			endtry
			
			;;Make sure we have SMC data
			if (taskSet.MethodCatalog == ^null)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))

			if (taskSet.MethodCatalog.Interfaces.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))
			
			if (currentInterface.Methods.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the current interface contains no method definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))
			
			loop.MaxIndex = currentInterface.Methods.Count - 1
			
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} methods", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			data ix, int
			for ix from 0 thru currentInterface.Methods.Count - 1
			begin
				loop.CurrentInterface = currentInterface
				loop.CurrentMethod = currentInterface.Methods[ix]
				loop.CurrentIndex = ix

				expander.Visit(node.Body)
			end
		
		endmethod

		private static method processParameterLoop, void
			required in node, @LoopNode 
			required in template, @FileNode 
			required in loops, @IEnumerable<LoopNode> 
			required in expander, @ITreeNodeVisitor 
		proc
			data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. MethodLoopNode}), MethodLoopNode)
			data loop = ^as(node, ParameterLoopNode)
			data context = template.Context
			data taskSet = context.Taskset
			data task = context.CurrentTask
			data currentInterface, @SmcInterface

			;;Get a handle on the current SMC Interface. This is either the current interface being processed in
			;;an outer interface loop, or the interface specified via the -interface command line option if no
			;;interface loop is being used.
			try
			begin
				data outerOuterLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. InterfaceLoopNode}), InterfaceLoopNode)
				currentInterface = outerOuterLoop.CurrentInterface
			end
			catch (e, @InvalidOperationException)
			begin
				;;We're not using an <INTERFACE_LOOP> so there is no "outer outer" loop
				currentInterface = taskset.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.Equals(taskset.Interface)})
			end
			endtry
			
			;;Make sure we have SMC data
			if (taskSet.MethodCatalog == ^null)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))

			if (taskSet.MethodCatalog.Interfaces.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))
			
			if (currentInterface.Methods.Count == 0)
				throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the current interface contains no method definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName))

			;;If there are no parameters, do nothing!
			if (outerLoop.CurrentMethod.Parameters.Count == 0)
			begin
				context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> no parameters", string.Format("<{0}>", loop.OpenToken.Value)))
				mreturn
			end

			loop.MaxIndex = outerLoop.CurrentMethod.Parameters.Count - 1			
			
			context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} parameters", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

			;;Maintain lists of the enums and structures we have already encountered so we can support <IF FIRST_INSTANCE_OF_...>
			data processedEnums = new List<string>()
			data processedStructures = new List<string>()

			data ix, int
			for ix from 0 thru outerLoop.CurrentMethod.Parameters.Count - 1
			begin
				loop.CurrentInterface = currentInterface
				loop.CurrentMethod = outerLoop.CurrentMethod
				loop.CurrentParameter = outerLoop.CurrentMethod.Parameters[ix]
				loop.CurrentIndex = ix
				loop.FirstEnumInstance = false
				loop.FirstStructureInstance = false

				;;If the parameter being processed is an enum paramerter then make the enum data available
				if (loop.CurrentParameter.Type == ParameterType.Enumeration) then
				begin
					data enumName = loop.CurrentParameter.EnumName

					;;Is this the first time we have encountered this structure?
					loop.FirstEnumInstance = !processedEnums.Contains(enumName)

					try
					begin
						loop.CurrentEnum = new RpsEnum(enumName)
					end
					catch (ex, @Exception)
					begin
						throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because method {3} parameter {4} ({5}) refers to repository enum {6} which was not found!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, loop.CurrentMethod.Name, ix+1, loop.CurrentParameter.Name, enumName))
					end
					endtry

					;;Record that we have processed this structure
					processedEnums.Add(enumName)
				end
				else
					loop.CurrentEnum = ^null

				;;If the parameter being processed is a structure paramerter then make the structure data available
				if (loop.CurrentParameter.Type == ParameterType.Structure) then
				begin
					data structureName = loop.CurrentParameter.StructureName

					;;Is this the first time we have encountered this structure?
					loop.FirstStructureInstance = !processedStructures.Contains(structureName)

					try
					begin
						loop.CurrentStructure = new RpsStructure(structureName,context.CurrentTask.UseAlternateFieldNames)
					end
					catch (ex, @Exception)
					begin
						throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because method {3} parameter {4} ({5}) refers to repository structure {6} which was not found!", node.OpenToken.Value, node.OpenToken.StartLineNumber, template.Context.CurrentTemplateBaseName, loop.CurrentMethod.Name, ix+1, loop.CurrentParameter.Name, structureName))
					end
					endtry

					;;Record that we have processed this structure
					processedStructures.Add(structureName)
				end
				else
					loop.CurrentStructure = ^null

				expander.Visit(node.Body)
			end

			;;Make sure we don't leave a current structure behind
			context.CurrentStructure = ^null
		
		endmethod

	endclass

endnamespace

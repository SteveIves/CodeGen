;; *****************************************************************************
;; 
;;  Title:       LoopExpander.dbl
;; 
;;  Type:        Class
;; 
;;  Description: Implements logic to iterate various template file loop constructs
;; 
;;  Date:        30th August 2014
;; 
;;  Authors:     Steve Ives, Synergex Professional Services Group
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.IO
import System.Linq
import CodeGen.MethodCatalogAPI
import CodeGen.RepositoryAPI

.array 0

namespace CodeGen.Engine

    public static class LoopExpander

        private static loopProcessors, @Dictionary<string, Action<LoopNode, FileNode, IEnumerable<LoopNode>, ITreeNodeVisitor>>

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        static method LoopExpander
        proc
            ;; Declare the methods responsible for processing each type of loop

            loopProcessors = new Dictionary<string, Action<LoopNode, FileNode, IEnumerable<LoopNode>, ITreeNodeVisitor>>()

            loopProcessors.Add("FIELD_LOOP", processFieldLoop)
            loopProcessors.Add("KEY_LOOP", processKeyLoop)
            loopProcessors.Add("KEY_LOOP_UNIQUE", processKeyLoopUnique)
            loopProcessors.Add("ALTERNATE_KEY_LOOP", processAlternateKeyLoop)
            loopProcessors.Add("ALTERNATE_KEY_LOOP_UNIQUE", processAlternateKeyLoopUnique)
            loopProcessors.Add("FOREIGN_KEY_LOOP", processForeignKeyLoop)
            loopProcessors.Add("PARTIAL_KEY_LOOP", processPartialKeyLoop)
            loopProcessors.Add("PRIMARY_KEY", processPrimaryKeyLoop)
            loopProcessors.Add("UNIQUE_KEY", processUniqueKeyLoop)
            loopProcessors.Add("ENUM_LOOP", processEnumLoop)
            loopProcessors.Add("ENUM_LOOP_STRUCTURE", processStructureEnumLoop)
            loopProcessors.Add("RELATION_LOOP", processRelationLoop)
            loopProcessors.Add("RELATION_LOOP_RESTRICTED", processRelationLoop)
            loopProcessors.Add("FROM_KEY_SEGMENT_LOOP", processFromKeySegmentLoop)
            loopProcessors.Add("FROM_KEY_SEGMENT_LOOP_RESTRICTED", processFromKeySegmentLoopRestricted)
            loopProcessors.Add("TO_KEY_SEGMENT_LOOP", processToKeySegmentLoop)
            loopProcessors.Add("TO_KEY_SEGMENT_LOOP_RESTRICTED", processToKeySegmentLoopRestricted)
            loopProcessors.Add("BUTTON_LOOP", processButtonLoop)
            loopProcessors.Add("FILE_LOOP", processFileLoop)
            loopProcessors.Add("TAG_LOOP", processTagLoop)
            loopProcessors.Add("SELECTION_LOOP", processFieldSelectionLoop)
            loopProcessors.Add("SEGMENT_LOOP", processKeySegmentLoop)
            loopProcessors.Add("SEGMENT_LOOP_FILTER", processKeySegmentFilterLoop)
            loopProcessors.Add("FIRST_SEGMENT", processFirstKeySegmentLoop)
            loopProcessors.Add("SECOND_SEGMENT", ProcessSecondKeySegmentLoop)
            loopProcessors.Add("ENUM_MEMBER_LOOP", processEnumMemberLoop)
            loopProcessors.Add("STRUCTURE_LOOP", processStructureLoop)
            loopProcessors.Add("INTERFACE_LOOP", processInterfaceLoop)
            loopProcessors.Add("METHOD_LOOP", processMethodLoop)
            loopProcessors.Add("PARAMETER_LOOP", processParameterLoop)

        endmethod

        ;;; <summary>
        ;;; This method is called by TreeExpander whenever a loop node is encountered in the tree.
        ;;; It determines which method should be used to expand the loop and calls that method.
        ;;; </summary>
        ;;; <param name="node"></param>
        ;;; <param name="tpl"></param>
        ;;; <param name="loopContext"></param>
        ;;; <param name="visitor"></param>
        public static method ProcessLoop, void
            required in node,           @LoopNode 
            required in tpl,            @FileNode 
            required in loopContext,    @IEnumerable<LoopNode> 
            required in visitor,        @ITreeNodeVisitor 
        proc
            ;; Lookup the processing method for the loop needing to be processed
            if (loopProcessors.ContainsKey(node.OpenToken.Value)) then
            begin
                ;; And call it
                loopProcessors[node.OpenToken.Value](node, tpl, loopContext, visitor)
            end
            else
            begin
                ;; Not found (CodeGen bug)
                throw new ApplicationException(String.Format("CODEGEN BUG: LoopExpander doesn't define a loop processor method for <{0}>!", node.OpenToken.Value))
            end
        endmethod

        private static method processFieldLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, FieldLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            ;;Make sure we have a current structure. We could get here at runtime if the developer tries to use a field loop
            ;;within a parameter loop, with a non-structure parameter!
            if (currentStructure == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because there is no current structure!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            ;;Make sure the current structure has fields
            if (currentStructure.Fields.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no fields!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))

            loop.MaxIndex = currentStructure.Fields.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} fields", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru currentStructure.Fields.Count - 1
            begin
                loop.SetCurrentField(currentStructure.Fields[ix])
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        ;;This method is different to the others here. It is caled during the processing of the <FIELD_GROUP_EXPAND> field loop token
        public static method ProcessGroup, string
            required in tkn, @Token
            required in template, @FileNode
            required in loops, @IEnumerable<LoopNode>
            required in str, @RpsStructure
            required in field, @RpsField
        proc
            data context = template.Context
            data task = context.CurrentTask
            data loop = ^as(loops.Last(), FieldLoopNode)
            data groupStructure = String.IsNullOrWhiteSpace(field.GroupStructure) ? new RpsStructure(field.GroupFields,field.Name) : new RpsStructure(field.GroupStructure)
            data saveMaxIndex = loop.MaxIndex
            data saveCurrentIndex = loop.CurrentIndex

            ;;Configure the environment for the new group
            context.SetCurrentStructure(groupStructure)
            loop.AddNestedField(groupStructure.Fields.First())
            loop.MaxIndex = groupStructure.Fields.Count - 1
            loop.CurrentIndex = 0

            data expanderOutput = new StringWriter()
            data expander = new TreeExpander(template, loops, expanderOutput)

            LoopExpander.ProcessLoop(loop, template, loops, expander)

            ;;Restore the environment to its previous state
            context.ClearCurrentStructure()
            loop.RemoveNestedField()
            loop.MaxIndex = saveMaxIndex
            loop.CurrentIndex = saveCurrentIndex

            mreturn expanderOutput.ToString()

        endmethod

        private static method processKeyLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            ;;Do we have any keys?
            if (currentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            loop.MaxIndex = currentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (currentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop

                loop.CurrentKey = currentStructure.Keys[ix]
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        private static method processKeyLoopUnique, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            ;;This is like a key loop, except that it will exclude any keys that
            ;;use the exact same segments as a key that has already been processed.

            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            ;;Start with all the access keys from the structure
            data accessKeys, @List<RpsKey>, currentStructure.Keys.Where<RpsKey>(lambda(theKey) { theKey.KeyType == RpsKeyType.Access }).ToList()

            ;;Check we have at least one key
            if (accessKeys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no alternate keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            ;;Remove any keys with identical segment combinations

            data prevKeysSegments = new List<RpsKeySegmentCollection>()
            data otherKeySegments, @RpsKeySegmentCollection 
            data thisLoopFinalKeys = new List<RpsKey>()

            ;;Iterate through the candidate keys
            data ix, int
            for ix from 0 thru accessKeys.Count - 1
            begin
                ;;Assume the key has a unique signature
                data segmentsMatchAnotherKey = false

                ;;If we havent processed any other keys yet then we can't have a duplicate, so this one gets included
                if (prevKeysSegments.Count > 0)
                begin
                    ;;We have processed other keys, make sure this keys segments don't match any we have already processed
                    data thisKeySegments, @RpsKeySegmentCollection, accessKeys[ix].Segments

                    data iy, int
                    for iy from 0 thru prevKeysSegments.Count - 1
                    begin
                        ;;Look for a difference
                        otherKeySegments = prevKeysSegments[iy]

                        ;;Different number of segments?
                        if (thisKeySegments.Count == otherKeySegments.Count)
                        begin
                            ;;Same segment count, could be a duplicate. Look at each segment
                            data thisKeySeg, @RpsKeySegment
                            data otherKeySeg, @RpsKeySegment

                            data iz, int
                            data allSegmentsMatch = true

                            ;;Iterate through the segments looking for a diff
                            for iz from 0 thru thisKeySegments.Count - 1
                            begin
                                thisKeySeg = thisKeySegments[iz]
                                otherKeySeg = otherKeySegments[iz]

                                using thisKeySeg.SegmentType select
                                (RpsKeySegmentType.Field),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Field) || (!otherKeySeg.Field.Equals(thisKeySeg.Field)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.Literal),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Literal) || (!otherKeySeg.LiteralValue.Equals(thisKeySeg.LiteralValue)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.External),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'External' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                (RpsKeySegmentType.RecordNumber),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'Record Number' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                endusing
                            end

                            if (allSegmentsMatch)
                            begin
                                segmentsMatchAnotherKey = true
                                exitloop
                            end
                        end
                    end
                end

                prevKeysSegments.Add(accessKeys[ix].Segments)

                if (!segmentsMatchAnotherKey)
                begin
                    thisLoopFinalKeys.Add(accessKeys[ix])
                end
            end

            ;;See if we have a unique key amongst the remaining keys
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru thisLoopFinalKeys.Count - 1
            begin
                ;;Look for the first unique key
                if (thisLoopFinalKeys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            ;;And process the remaining keys

            loop.MaxIndex = thisLoopFinalKeys.Count -1
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            for ix from 0 thru loop.MaxIndex
            begin
                loop.CurrentKey = thisLoopFinalKeys[ix]
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        private static method processAlternateKeyLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (currentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            data ix, int

            loop.MaxIndex = currentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (currentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;; Skip the first key and any foreign keys
                if ((ix == 0) || (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign))
                    nextloop

                ;; Then process as normal
                loop.CurrentKey = currentStructure.Keys[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processAlternateKeyLoopUnique, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            ;;This is like an alternate key loop, except that it will exclude any keys that
            ;;use the exact same segments as a key that has already been processed.

            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            ;;Start with all the access keys from the structure
            data accessKeys, @List<RpsKey>, currentStructure.Keys.Where<RpsKey>(lambda(theKey) { theKey.KeyType == RpsKeyType.Access }).ToList()

            ;;Check we have at least one alternate key
            if (accessKeys.Count < 2)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no alternate keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            ;;Remove any keys with identical segment combinations
            ;;Originally this excluded the primary key, but now, matches to the primary key are also excluded.

            data prevKeysSegments = new List<RpsKeySegmentCollection>()
            data otherKeySegments, @RpsKeySegmentCollection 
            data thisLoopFinalKeys = new List<RpsKey>()

            ;;Iterate through the candidate keys
            data ix, int
            for ix from 0 thru accessKeys.Count - 1
            begin
                ;;Assume the key has a unique signature
                data segmentsMatchAnotherKey = false

                ;;If we havent processed any other keys yet then we can't have a duplicate, so this one gets included
                if (prevKeysSegments.Count > 0)
                begin
                    ;;We have processed other keys, make sure this keys segments don't match any we have already processed
                    data thisKeySegments, @RpsKeySegmentCollection, accessKeys[ix].Segments

                    data iy, int
                    for iy from 0 thru prevKeysSegments.Count - 1
                    begin
                        ;;Look for a difference
                        otherKeySegments = prevKeysSegments[iy]

                        ;;Different number of segments?
                        if (thisKeySegments.Count == otherKeySegments.Count)
                        begin
                            ;;Same segment count, could be a duplicate. Look at each segment
                            data thisKeySeg, @RpsKeySegment
                            data otherKeySeg, @RpsKeySegment

                            data iz, int
                            data allSegmentsMatch = true

                            ;;Iterate through the segments looking for a diff
                            for iz from 0 thru thisKeySegments.Count - 1
                            begin
                                thisKeySeg = thisKeySegments[iz]
                                otherKeySeg = otherKeySegments[iz]

                                using thisKeySeg.SegmentType select
                                (RpsKeySegmentType.Field),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Field) || (!otherKeySeg.Field.Equals(thisKeySeg.Field)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.Literal),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Literal) || (!otherKeySeg.LiteralValue.Equals(thisKeySeg.LiteralValue)))
                                    begin
                                    allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.External),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'External' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                (RpsKeySegmentType.RecordNumber),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'Record Number' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                endusing
                            end

                            if (allSegmentsMatch)
                            begin
                                segmentsMatchAnotherKey = true
                                exitloop
                            end
                        end
                    end
                end

                prevKeysSegments.Add(accessKeys[ix].Segments)

                if (!segmentsMatchAnotherKey)
                begin
                    thisLoopFinalKeys.Add(accessKeys[ix])
                end
            end

            ;;Remove the primary key from processing
            thisLoopFinalKeys.Remove(accessKeys.First())

            ;;See if we have a unique key amongst the remaining keys
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru thisLoopFinalKeys.Count - 1
            begin
                ;;Look for the first unique key
                if (thisLoopFinalKeys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            ;;And process the remaining keys

            loop.MaxIndex = thisLoopFinalKeys.Count -1
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            for ix from 0 thru loop.MaxIndex
            begin
                loop.CurrentKey = thisLoopFinalKeys[ix]
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        private static method processForeignKeyLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            loop.MaxIndex = currentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Foreign }) -1

            ;;If we don't have any foreign keys then we're done!
            if (loop.MaxIndex == -1)
                mreturn

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data currentKey, @RpsKey
            loop.CurrentIndex = -1

            foreach currentKey in currentStructure.Keys
            begin
                ;;Only process foreign keys
                if (currentKey.KeyType == RpsKeyType.Foreign)
                begin
                    loop.CurrentKey = currentKey
                    loop.CurrentIndex += 1
                    expander.Visit(node.Body)
                end
            end

        endmethod

        private static method processPartialKeyLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            ; If there are no multi-segment access keys, we're done
            if (currentStructure.Keys.Count<RpsKey>(lambda(k) { k.KeyType == RpsKeyType.Access && k.Segments.Count > 1 }) == 0)
                mreturn

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (currentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            data keysToProcess = new List<KeyValuePair<int,int>>()

            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                data thisKey = currentStructure.Keys[ix]

                ;;Skip any Foreign or single-segment keys
                if (thisKey.KeyType == RpsKeyType.Foreign || thisKey.Segments.Count == 1)
                    nextloop

                ;;Skip any keys that don't have a matching CODEGEN_PARTIAL_KEY_n token in the structure long description
                data longDescription = currentStructure.LongDescription
                data partialKeyToken = String.Format("CODEGEN_PARTIAL_KEY_{0}",ix)
                if (!longDescription.Contains(partialKeyToken))
                    nextloop

                ;;Does the CODEGEN_PARTIAL_KEY_n token restrict the key segments to use?
                longDescription = longDescription.Substring(longDescription.IndexOf(partialKeyToken)+partialKeyToken.Length)
                data iy, int

                if (String.IsNullOrWhiteSpace(longDescription) || longDescription.Substring(0,1)!="=") then
                begin
                    ;;No, all segments
                    for iy from thisKey.Segments.Count-1 thru 1 by -1
                    begin
                        keysToProcess.Add(new KeyValuePair<int,int>(ix,iy))
                    end
                end
                else
                begin
                    ;;Yes, restricted segments. Strip off the = and make sure we have a comma-delimited list of integers followed by a ;
                    longDescription = longDescription.Substring(1)
                    data semiPos = longDescription.IndexOf(";")
                    if (semiPos == -1)
                    begin
                        throw new ApplicationException(String.Format("An invalid {0} token was encountered while processing structure {1}",partialKeyToken,currentStructure.Name))
                    end
                    ;;Strip off the ; and everything after
                    longDescription = longDescription.Substring(0,semiPos)
                    ;;If there is nothing left, it's a problem
                    if (String.IsNullOrWhiteSpace(longDescription))
                    begin
                        throw new ApplicationException(String.Format("An invalid {0} token was encountered while processing structure {1}",partialKeyToken,currentStructure.Name))
                    end
                    ;;All that should be left is a comma-delimited list of integers
                    data segmentNumbersStringArray = longDescription.Split(",")
                    data segmentNumberInt, int
                    for iy from segmentNumbersStringArray.Length -1 thru 0 by -1
                    begin
                        if (int.TryParse(segmentNumbersStringArray[iy],segmentNumberInt)) then
                        begin
                            ;;Highest segment number can't be more than the total number of segments - 1, and can't be less than 1.
                            if (segmentNumberInt < 1 || segmentNumberInt > thisKey.Segments.Count - 1)
                            begin
                                throw new ApplicationException(String.Format("An invalid highest segment number {0} was encountered while {1} for structure {2}",segmentNumberInt,partialKeyToken,currentStructure.Name))
                            end
                            keysToProcess.Add(new KeyValuePair<int,int>(ix,segmentNumberInt))
                        end
                        else
                        begin
                            throw new ApplicationException(String.Format("An invalid {0} token was encountered while processing structure {1}",partialKeyToken,currentStructure.Name))
                        end
                    end
                end
            end

            ;;Now process the loop, potentially processing the same key multiple times

            loop.MaxIndex = keysToProcess.Count - 1
            loop.CurrentIndex = -1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data keyToProcess, @KeyValuePair<int,int>

            foreach keyToProcess in keysToProcess
            begin
                ;;Select the key and current loop index
                loop.CurrentKey = currentStructure.Keys[keyToProcess.Key]
                loop.CurrentIndex += 1

                ;;Specify the highest segment number to be processed
                loop.HighestSegmentToProcess = keyToProcess.Value

                expander.Visit(node.Body)
            end

        endmethod

        private static method processPrimaryKeyLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (currentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            if ((context.CurrentTask.PrimaryKeyNumber > 0) && (context.CurrentTask.PrimaryKeyNumber > (currentStructure.Keys.Count - 1)))
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed using alternate key {3} because structure {4} only has {5} keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentTask.PrimaryKeyNumber, currentStructure.Name, currentStructure.Keys.Count + 1))

            loop.CurrentKey = currentStructure.Keys[context.CurrentTask.PrimaryKeyNumber]
            loop.CurrentIndex = context.CurrentTask.PrimaryKeyNumber
            loop.MaxIndex = context.CurrentTask.PrimaryKeyNumber

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (currentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 key", string.Format("<{0}>", loop.OpenToken.Value)))

            expander.Visit(node.Body)

        endmethod

        private static method processUniqueKeyLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (currentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            if (!currentStructure.Keys.Any(lambda (k) {(k.Duplicates == RpsKeyDuplicates.NoDuplicates) && (k.KeyType == RpsKeyType.Access)}))
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no unique keys!",node.OpenToken.Value,node.OpenToken.StartLineNumber,context.CurrentTemplateBaseName,currentStructure.Name))
            end

            loop.CurrentKey = currentStructure.Keys.First(lambda (k) {k.Duplicates == RpsKeyDuplicates.NoDuplicates})
            loop.CurrentIndex = currentStructure.Keys.IndexOf(loop.CurrentKey)
            loop.MaxIndex = loop.CurrentIndex

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru currentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (currentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (currentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 key", string.Format("<{0}>", loop.OpenToken.Value)))

            expander.Visit(node.Body)

        endmethod

        private static method processEnumLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, EnumLoopNode)
            data context = template.Context

            if (context.Repository == ^null)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no repository is being processed!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
            end

            if (context.Repository.Enumerations.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no enumerations are defined!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
            end

            loop.MaxIndex = context.Repository.Enumerations.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enums", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.Repository.Enumerations.Count - 1
            begin
                loop.CurrentEnumeration = context.Repository.Enumerations[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processStructureEnumLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, EnumLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (context.Repository.Enumerations.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no enumerations are defined!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
            end

            ;;Build a collection of enums that are referred to by the current structure
            data enumsToProcess = new RpsEnumCollection(currentStructure.Name)

            loop.MaxIndex = enumsToProcess.Count - 1
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enums", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            ;;Anything to do?
            if (loop.MaxIndex == -1)
                mreturn

            ;;Yes, process the subset of enumerations
            data ix, int
            for ix from 0 thru loop.MaxIndex
            begin
                loop.CurrentEnumeration = enumsToProcess[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processRelationLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, RelationLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (currentStructure.Relations.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no relations!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            loop.MaxIndex = currentStructure.Relations.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} relations", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru currentStructure.Relations.Count - 1
            begin
                loop.CurrentRelation = currentStructure.Relations[ix]
                loop.CurrentIndex = ix

                ;;Locate the "from key" information
                lambda isFromKey(k) k.Name == loop.CurrentRelation.FromKey
                loop.FromKey = context.GetCurrentStructure().Keys.First(isFromKey)

                ;;Load the "to structure" information
                lambda isToStructure(s) s.Name == loop.CurrentRelation.ToStructure
                loop.ToStructure = context.Structures.FirstOrDefault(isToStructure)

                ;;If the to structure was not found then it's not currently being processed
                ;;so we'll load it directly from the repository
                if (loop.ToStructure == ^null)
                begin
                    if (node.OpenToken.Value.Equals("RELATION_LOOP_RESTRICTED")) then
                    begin
                        ;;We don't have a "to structure" and we're processing a RELATION_LOOP_RESTRICTED
                        ;;so we'll just skip this relation
                        nextloop
                    end
                    else
                    begin
                        ;;If the to structure was not found then it's not currently being processed
                        ;;so we'll load it directly from the repository
                        loop.ToStructure = new RpsStructure(loop.CurrentRelation.ToStructure,context.CurrentTask.UseAlternateFieldNames)
                    end
                end

                ;Load the "to key" information
                lambda isToKey(k) k.Name == loop.CurrentRelation.ToKey
                loop.ToKey = loop.ToStructure.Keys.First(isToKey)

                expander.Visit(node.Body)
            end

        endmethod

        private static method processButtonLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            ;; TODO: Button loops need context data

            data loop = ^as(node, ButtonLoopNode)
            data context = template.Context

            context.Buttons = new WscButtonCollection()

            if ((context.Buttons == ^null) || (context.Buttons.Count == 0))
                mreturn

            loop.MaxIndex = context.Buttons.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} buttons", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.Buttons.Count - 1
            begin
                loop.CurrentButton = context.Buttons[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processFileLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, FileLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (currentStructure.Files.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} is not assigned to any files!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, currentStructure.Name))
            end

            loop.MaxIndex = currentStructure.Files.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} files", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru currentStructure.Files.Count - 1
            begin
                loop.CurrentFile = currentStructure.Files[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processTagLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, TagLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            loop.MaxIndex = currentStructure.Tags.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} tags", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            ;; Tag loops just do nothing if no tags are defined!
            data ix, int
            for ix from 0 thru currentStructure.Tags.Count - 1
            begin
                loop.CurrentTag = currentStructure.Tags[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processFieldSelectionLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. FieldLoopNode}), FieldLoopNode)
            data loop = ^as(node, SelectionLoopNode)
            data context = template.Context

            if (outerLoop.GetCurrentField().SelectionList.Count > 0)
            begin
                loop.MaxIndex = outerLoop.GetCurrentField().SelectionList.Count - 1
                loop.CurrentField = outerLoop.GetCurrentField()

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} selections", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.GetCurrentField().SelectionList.Count - 1
                begin
                    loop.CurrentSelection = outerLoop.GetCurrentField().SelectionList[ix]
                    loop.CurrentIndex = ix

                    expander.Visit(node.Body)
                end
            end

        endmethod

        private static method processKeySegmentLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                loop.CurrentKey = outerLoop.CurrentKey
                loop.MaxIndex = outerLoop.HighestSegmentToProcess ? outerLoop.HighestSegmentToProcess - 1 : outerLoop.CurrentKey.Segments.Count - 1

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru loop.MaxIndex
                begin
                    loop.CurrentSegment = outerLoop.CurrentKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(currentStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)
                end
            end

        endmethod

        private static method getFieldForSegment, @RpsField
            required in str, @RpsStructure 
            required in seg, @RpsKeySegment 
        proc
            if (seg.SegmentType == RpsKeySegmentType.Field) then
            begin
                try
                begin
                    mreturn str.Fields.First(lambda (fld) { fld.OriginalName == seg.Field })
                end
                catch (ex, @Exception)
                begin
                    throw new ApplicationException(String.Format("When processing structure {0} key segment field {1} was not found.", str.Name, seg.Field))
                end
                endtry
            end
            else
                mreturn ^null
        endmethod

        private static method processKeySegmentFilterLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                loop.CurrentKey = outerLoop.CurrentKey
                loop.MaxIndex = outerLoop.CurrentKey.Segments.Count - 2

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int, 0
                while (ix < outerLoop.CurrentKey.Segments.Count - 1) do
                begin
                    loop.CurrentSegment = outerLoop.CurrentKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(currentStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)

                    ^incr(ix, true)
                end
            end

        endmethod

        private static method processFirstKeySegmentLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                ;; Only process the first segment
                loop.CurrentKey = outerLoop.CurrentKey
                loop.CurrentSegment = outerLoop.CurrentKey.Segments[0]
                loop.CurrentIndex = 0
                loop.MaxIndex = 0
                loop.CurrentField = getFieldForSegment(currentStructure, loop.CurrentSegment)

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 segment", string.Format("<{0}>", loop.OpenToken.Value)))

                expander.Visit(node.Body)
            end

        endmethod

        private static method ProcessSecondKeySegmentLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (outerLoop.CurrentKey.Segments.Count > 1)
            begin
                ;; Only process the second segment
                loop.CurrentKey = outerLoop.CurrentKey
                loop.CurrentSegment = outerLoop.CurrentKey.Segments[1]
                loop.CurrentIndex = 1
                loop.MaxIndex = 1
                loop.CurrentField = getFieldForSegment(currentStructure, loop.CurrentSegment)

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 segment", string.Format("<{0}>", loop.OpenToken.Value)))

                expander.Visit(node.Body)
            end

        endmethod

        private static method processEnumMemberLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. EnumLoopNode}), EnumLoopNode)
            data loop = ^as(node, EnumMemberLoopNode)
            data context = template.Context

            loop.CurrentEnumeration = outerLoop.CurrentEnumeration
            loop.MaxIndex = outerLoop.CurrentEnumeration.Members.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enum members", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru outerLoop.CurrentEnumeration.Members.Count - 1
            begin
                loop.CurrentMember = loop.CurrentEnumeration.Members[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processFromKeySegmentLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (outerLoop.FromKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.FromKey
                loop.MaxIndex = outerLoop.FromKey.Segments.Count - 1
                loop.ToStructure = outerLoop.ToStructure
                loop.ToKey = outerLoop.ToKey

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.FromKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.FromKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(currentStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)
                end
            end
        endmethod

        private static method processFromKeySegmentLoopRestricted, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context
            data currentStructure = context.GetCurrentStructure()

            if (outerLoop.FromKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.FromKey
                loop.MaxIndex = outerLoop.FromKey.Segments.Count - 1
                loop.ToStructure = outerLoop.ToStructure
                loop.ToKey = outerLoop.ToKey

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data lengthSoFar = 0

                data ix, int
                for ix from 0 thru outerLoop.FromKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.FromKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(currentStructure, loop.CurrentSegment)

                    lengthSoFar += loop.CurrentSegment.Length
                    if (lengthSoFar == outerLoop.ToKey.Size)
                        loop.MaxIndex = loop.CurrentIndex

                    expander.Visit(node.Body)

                    if (lengthSoFar == outerLoop.ToKey.Size)
                        exitloop
                end
            end
        endmethod

        private static method processToKeySegmentLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context

            if (outerLoop.ToKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.ToKey
                loop.MaxIndex = outerLoop.ToKey.Segments.Count - 1

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.ToKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.ToKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(outerLoop.ToStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)
                end
            end
        endmethod

        private static method processToKeySegmentLoopRestricted, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context

            data lengthSoFar = 0

            if (outerLoop.ToKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.ToKey
                loop.MaxIndex = outerLoop.ToKey.Segments.Count - 1

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.ToKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.ToKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(outerLoop.ToStructure, loop.CurrentSegment)

                    lengthSoFar += loop.CurrentSegment.Length
                    if (lengthSoFar == outerLoop.FromKey.Size)
                        loop.MaxIndex = loop.CurrentIndex

                    expander.Visit(node.Body)

                    if (lengthSoFar == outerLoop.FromKey.Size)
                        exitloop
                end
            end
        endmethod

        private static method processStructureLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, StructureLoopNode)
            data context = template.Context
            data task = context.CurrentTask
            data currentStructure = context.GetCurrentStructure()

            if (!context.MultiStructureMode)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because multi-structure mode (-ms) has not been enabled!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            loop.MaxIndex = context.Structures.Count - 1

            ;; Debug log beginning of structure loop
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} structures", string.Format("<{0}>", loop.OpenToken.Value), context.Structures.Count))

            data ix, int
            for ix from 0 thru context.Structures.Count - 1
            begin
                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1}", String.Format("Structure {0}/{1}", ix + 1, context.Structures.Count - 1), context.Structures[ix].Name), true, false)
                context.SetCurrentStructure(context.Structures[ix])
                context.CurrentFileIndex = context.StructureFileIndex[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

            ;; Debug log end of structure loop
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} ->", string.Format("</{0}>", loop.CloseToken.Value)))

        endmethod

        private static method processInterfaceLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, InterfaceLoopNode)
            data context = template.Context
            data taskSet = context.Taskset
            data task = context.CurrentTask

            ;;Make sure we have SMC data
            if (context.MethodCatalog == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (context.MethodCatalog.Interfaces.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            loop.MaxIndex =  context.MethodCatalog.Interfaces.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} interfaces", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru loop.MaxIndex
            begin
                loop.CurrentInterface = context.MethodCatalog.Interfaces[ix]
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        private static method processMethodLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data loop = ^as(node, MethodLoopNode)
            data context = template.Context
            data taskset = context.Taskset
            data task = context.CurrentTask
            data currentInterface, @SmcInterface

            data result = loops.FirstOrDefault(lambda (loopnode) {loopnode .is. InterfaceLoopNode})
            if (result != ^null) then
            begin
                data outerLoop = ^as(result, InterfaceLoopNode)
                currentInterface = outerLoop.CurrentInterface
            end
            else
            begin
                ;;We're not using an <INTERFACE_LOOP> so there is no "outer" loop
                currentInterface = context.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.Equals(task.MethodCatalogInterface)})
            end

            ;;Make sure we have SMC data
            if (context.MethodCatalog == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (context.MethodCatalog.Interfaces.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (currentInterface.Methods.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the current interface contains no method definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            loop.MaxIndex = currentInterface.Methods.Count - 1
            loop.StructuresEncountered = new List<string>()

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} methods", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru currentInterface.Methods.Count - 1
            begin
                loop.CurrentInterface = currentInterface
                loop.CurrentMethod = currentInterface.Methods[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processParameterLoop, void
            required in node,       @LoopNode 
            required in template,   @FileNode 
            required in loops,      @IEnumerable<LoopNode> 
            required in expander,   @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. MethodLoopNode}), MethodLoopNode)
            data loop = ^as(node, ParameterLoopNode)
            data context = template.Context
            data taskSet = context.Taskset
            data task = context.CurrentTask
            data currentInterface, @SmcInterface

            ;;Get a handle on the current SMC Interface. This is either the current interface being processed in
            ;;an outer interface loop, or the interface specified via the -interface command line option if no
            ;;interface loop is being used.
        
            begin
                data result = loops.FirstOrDefault(lambda (loopnode) {loopnode .is. InterfaceLoopNode})
                if (result != ^null) then
                begin
                    data outerOuterLoop = ^as(result, InterfaceLoopNode)
                    currentInterface = outerOuterLoop.CurrentInterface
                end
                else
                begin
                    ;;We're not using an <INTERFACE_LOOP> so there is no "outer outer" loop
                    currentInterface = context.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.Equals(task.MethodCatalogInterface)})
                end
            end

            ;;Make sure we have SMC data
            if (context.MethodCatalog == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (context.MethodCatalog.Interfaces.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (currentInterface.Methods.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the current interface contains no method definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            ;;If there are no parameters, do nothing!
            if (outerLoop.CurrentMethod.Parameters.Count == 0)
            begin
                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> no parameters", string.Format("<{0}>", loop.OpenToken.Value)))
                mreturn
            end

            loop.MaxIndex = outerLoop.CurrentMethod.Parameters.Count - 1

            context.ClearCurrentStructure()
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} parameters", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            ;;Maintain lists of the enums and structures we have already encountered so we can support <IF FIRST_INSTANCE_OF_...>
            data processedEnums = new List<string>()
            data processedStructures = new List<string>()

            data ix, int
            for ix from 0 thru outerLoop.CurrentMethod.Parameters.Count - 1
            begin
                loop.CurrentInterface = currentInterface
                loop.CurrentMethod = outerLoop.CurrentMethod
                loop.CurrentParameter = outerLoop.CurrentMethod.Parameters[ix]
                loop.CurrentIndex = ix
                loop.FirstEnumInstance = false
                loop.FirstStructureInstanceInMethod = false
                loop.FirstStructureInstanceInInterface = false

                ;;If the parameter being processed is an enum paramerter then make the enum data available
                if (loop.CurrentParameter.Type == ParameterType.Enumeration) then
                begin
                    data enumName = loop.CurrentParameter.EnumName

                    ;;Is this the first time we have encountered this enum?
                    loop.FirstEnumInstance = !processedEnums.Contains(enumName)

                    try
                    begin
                        loop.CurrentEnum = new RpsEnum(enumName)
                    end
                    catch (ex, @Exception)
                    begin
                        throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because method {3} parameter {4} ({5}) refers to repository enum {6} which was not found!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, loop.CurrentMethod.Name, ix+1, loop.CurrentParameter.Name, enumName))
                    end
                    endtry

                    ;;Record that we have processed this enum
                    if (loop.FirstEnumInstance)
                        processedEnums.Add(enumName)
                end
                else
                    loop.CurrentEnum = ^null

                ;;If the parameter being processed is a structure paramerter then make the structure data available
                if (loop.CurrentParameter.Type == ParameterType.Structure) then
                begin
                    data structureName = loop.CurrentParameter.StructureName

                    ;;Is this the first time we have encountered this structure in all interfaces?
                    loop.FirstStructureInstanceInInterface = !outerLoop.StructuresEncountered.Contains(structureName)

                    ;;Is this the first time we have encountered this structure in this method?
                    loop.FirstStructureInstanceInMethod = !processedStructures.Contains(structureName)

                    try
                    begin
                        loop.CurrentStructure = new RpsStructure(structureName,context.CurrentTask.UseAlternateFieldNames)
                        context.SetCurrentStructure(loop.CurrentStructure)
                    end
                    catch (ex, @Exception)
                    begin
                        throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because method {3} parameter {4} ({5}) refers to repository structure {6} which was not found!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, loop.CurrentMethod.Name, ix+1, loop.CurrentParameter.Name, structureName))
                    end
                    endtry

                    ;;Record that we have processed this structure

                    if (loop.FirstStructureInstanceInInterface)
                        outerLoop.StructuresEncountered.Add(structureName)

                    if (loop.FirstStructureInstanceInMethod)
                        processedStructures.Add(structureName)
                end
                else
                    loop.CurrentStructure = ^null

                expander.Visit(node.Body)
            end

            ;;Make sure we don't leave a current structure behind
            context.ClearCurrentStructure()

        endmethod

    endclass

endnamespace

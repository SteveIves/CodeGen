;; *****************************************************************************
;; 
;;  Title:       LoopExpander.dbl
;; 
;;  Type:        Class
;; 
;;  Description: Implements logic to iterate various template file loop constructs
;; 
;;  Date:        30th August 2014
;; 
;;  Authors:     Steve Ives, Synergex Professional Services Group
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.IO
import System.Linq
import CodeGen.MethodCatalogAPI
import CodeGen.RepositoryAPI

.array 0

namespace CodeGen.Engine

    public static class LoopExpander

        private static loopProcessors, @Dictionary<string, Action<LoopNode, FileNode, IEnumerable<LoopNode>, ITreeNodeVisitor>>

        static method LoopExpander
        proc

            loopProcessors = new Dictionary<string, Action<LoopNode, FileNode, IEnumerable<LoopNode>, ITreeNodeVisitor>>()

            loopProcessors.Add("FIELD_LOOP", processFieldLoop)
            loopProcessors.Add("KEY_LOOP", processKeyLoop)
            loopProcessors.Add("KEY_LOOP_UNIQUE", processKeyLoopUnique)
            loopProcessors.Add("ALTERNATE_KEY_LOOP", processAlternateKeyLoop)
            loopProcessors.Add("ALTERNATE_KEY_LOOP_UNIQUE", processAlternateKeyLoopUnique)
            loopProcessors.Add("FOREIGN_KEY_LOOP", processForeignKeyLoop)
            loopProcessors.Add("PRIMARY_KEY", processPrimaryKeyLoop)
            loopProcessors.Add("UNIQUE_KEY", processUniqueKeyLoop)
            loopProcessors.Add("ENUM_LOOP", processEnumLoop)
            loopProcessors.Add("ENUM_LOOP_STRUCTURE", processStructureEnumLoop)
            loopProcessors.Add("RELATION_LOOP", processRelationLoop)
            loopProcessors.Add("RELATION_LOOP_RESTRICTED", processRelationLoop)
            loopProcessors.Add("FROM_KEY_SEGMENT_LOOP", processFromKeySegmentLoop)
            loopProcessors.Add("FROM_KEY_SEGMENT_LOOP_RESTRICTED", processFromKeySegmentLoopRestricted)
            loopProcessors.Add("TO_KEY_SEGMENT_LOOP", processToKeySegmentLoop)
            loopProcessors.Add("TO_KEY_SEGMENT_LOOP_RESTRICTED", processToKeySegmentLoopRestricted)
            loopProcessors.Add("BUTTON_LOOP", processButtonLoop)
            loopProcessors.Add("FILE_LOOP", processFileLoop)
            loopProcessors.Add("TAG_LOOP", processTagLoop)
            loopProcessors.Add("SELECTION_LOOP", processFieldSelectionLoop)
            loopProcessors.Add("SEGMENT_LOOP", processKeySegmentLoop)
            loopProcessors.Add("SEGMENT_LOOP_FILTER", processKeySegmentFilterLoop)
            loopProcessors.Add("FIRST_SEGMENT", processFirstKeySegmentLoop)
            loopProcessors.Add("SECOND_SEGMENT", ProcessSecondKeySegmentLoop)
            loopProcessors.Add("ENUM_MEMBER_LOOP", processEnumMemberLoop)
            loopProcessors.Add("STRUCTURE_LOOP", processStructureLoop)
            loopProcessors.Add("INTERFACE_LOOP", processInterfaceLoop)
            loopProcessors.Add("METHOD_LOOP", processMethodLoop)
            loopProcessors.Add("PARAMETER_LOOP", processParameterLoop)

        endmethod

        ;;; <summary>
        ;;; This method is called by TreeExpander whenever a loop node is encountered in the tree.
        ;;; It determines which method should be used to expand the loop and calls that method.
        ;;; </summary>
        ;;; <param name="node"></param>
        ;;; <param name="tpl"></param>
        ;;; <param name="loopContext"></param>
        ;;; <param name="visitor"></param>
        public static method ProcessLoop, void
            required in node,@LoopNode 
            required in tpl,@FileNode 
            required in loopContext,@IEnumerable<LoopNode> 
            required in visitor,@ITreeNodeVisitor 
        proc
            if (loopProcessors.ContainsKey(node.OpenToken.Value)) then
                loopProcessors[node.OpenToken.Value](node, tpl, loopContext, visitor)
            else
                throw new ApplicationException(String.Format("CODEGEN BUG: LoopExpander doesn't define a processor for <{0}>!", node.OpenToken.Value))
        endmethod

        private static method processFieldLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, FieldLoopNode)
            data context = template.Context

            ;;Make sure we have a current structure. We could get here at runtime if the developer tries to use a field loop
            ;;within a parameter loop, with a non-structure parameter!
            if (context.CurrentStructure == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because there is no current structure!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            ;;Make sure the current structure has fields
            if (context.CurrentStructure.Fields.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no fields!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))

            loop.MaxIndex = context.CurrentStructure.Fields.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} fields", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.CurrentStructure.Fields.Count - 1
            begin
                loop.CurrentField = context.CurrentStructure.Fields[ix]
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        private static method processKeyLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            ;;Do we have any keys?
            if (context.CurrentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            loop.MaxIndex = context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop

                loop.CurrentKey = context.CurrentStructure.Keys[ix]
                loop.CurrentIndex = ix
                expander.Visit(node.Body)
            end

        endmethod

        private static method processKeyLoopUnique, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            ;;This is like a key loop, except that it will exclude any keys that
            ;;use the exact same segments as a key that has already been processed.

            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            data ix, int

            loop.MaxIndex = context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data prevKeysSegments = new List<RpsKeySegmentCollection>()
            data otherKeySegments, @RpsKeySegmentCollection 

            ;;Iterate through all the keys in the structure
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;; Skip any foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop

                ;;If we get here we have an access key. Assume it's a duplicate and we'll look for a difference
                data segmentsMatchAnotherKey = false

                ;;If we havent processed any other keys yet then we can't have a duplicate, so this one gets included
                if (prevKeysSegments.Count > 0)
                begin
                    ;;We have processed other keys, so make sure the segments of this key don't match any we have already processed
                    data segmentsMatchThisKey, boolean
                    data thisKeySegments, @RpsKeySegmentCollection, context.CurrentStructure.Keys[ix].Segments

                    data iy, int
                    for iy from 0 thru prevKeysSegments.Count - 1
                    begin
                        ;;Assume we have a duplicate, look for a difference
                        segmentsMatchThisKey = true
                        otherKeySegments = prevKeysSegments[iy]

                        ;;Same number of segments?
                        if (thisKeySegments.Count != otherKeySegments.Count) then
                        begin
                            ;;Different segment count, not a duplicate
                            segmentsMatchThisKey = false
                        end
                        else
                        begin
                            ;;Same segment count, look at each segment
                            data thisKeySeg, @RpsKeySegment
                            data otherKeySeg, @RpsKeySegment

                            data iz, int
                            data allSegmentsMatch = true

                            ;;Iterate through the segments looking for a diff
                            for iz from 0 thru thisKeySegments.Count - 1
                            begin
                                thisKeySeg = thisKeySegments[iz]
                                otherKeySeg = otherKeySegments[iz]

                                using thisKeySeg.SegmentType select
                                (RpsKeySegmentType.Field),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Field) || (!otherKeySeg.Field.Equals(thisKeySeg.Field)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.Literal),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Literal) || (!otherKeySeg.LiteralValue.Equals(thisKeySeg.LiteralValue)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.External),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'External' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                (RpsKeySegmentType.RecordNumber),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'Record Number' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                endusing
                            end

                            if (allSegmentsMatch)
                            begin
                                segmentsMatchAnotherKey = true
                                exitloop
                            end
                        end
                    end
                end

                if (!segmentsMatchAnotherKey)
                begin
                    ;; Then process as normal
                    loop.CurrentKey = context.CurrentStructure.Keys[ix]
                    loop.CurrentIndex = ix

                    expander.Visit(node.Body)

                    prevKeysSegments.Add(loop.CurrentKey.Segments)
                end
            end

        endmethod

        private static method processAlternateKeyLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            data ix, int

            loop.MaxIndex = context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;; Skip the first key and any foreign keys
                if ((ix == 0) || (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign))
                    nextloop

                ;; Then process as normal
                loop.CurrentKey = context.CurrentStructure.Keys[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processAlternateKeyLoopUnique, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            ;;This is like an alternate key loop, except that it will exclude any keys that
            ;;use the exact same segments as a key that has already been processed.

            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            data ix, int

            loop.MaxIndex = context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Access }) -1

            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data prevKeysSegments = new List<RpsKeySegmentCollection>()
            data otherKeySegments, @RpsKeySegmentCollection 

            ;;Iterate through all the keys in the structure
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;; Skip the first key and any foreign keys
                if ((ix == 0) || (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign))
                    nextloop

                ;;If we get here we have an alternate access key. Assume it's a duplicate and we'll look for a difference
                data segmentsMatchAnotherKey = false

                ;;If we havent processed any other keys yet then we can't have a duplicate, so this one gets included
                if (prevKeysSegments.Count > 0)
                begin
                    ;;We have processed other keys, so make sure the segments of this key don't match any we have already processed
                    data segmentsMatchThisKey, boolean
                    data thisKeySegments, @RpsKeySegmentCollection, context.CurrentStructure.Keys[ix].Segments

                    data iy, int
                    for iy from 0 thru prevKeysSegments.Count - 1
                    begin
                        ;;Assume we have a duplicate, look for a difference
                        segmentsMatchThisKey = true
                        otherKeySegments = prevKeysSegments[iy]

                        ;;Same number of segments?
                        if (thisKeySegments.Count != otherKeySegments.Count) then
                        begin
                            ;;Different segment count, not a duplicate
                            segmentsMatchThisKey = false
                        end
                        else
                        begin
                            ;;Same segment count, look at each segment
                            data thisKeySeg, @RpsKeySegment
                            data otherKeySeg, @RpsKeySegment

                            data iz, int
                            data allSegmentsMatch = true

                            ;;Iterate through the segments looking for a diff
                            for iz from 0 thru thisKeySegments.Count - 1
                            begin
                                thisKeySeg = thisKeySegments[iz]
                                otherKeySeg = otherKeySegments[iz]

                                using thisKeySeg.SegmentType select
                                (RpsKeySegmentType.Field),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Field) || (!otherKeySeg.Field.Equals(thisKeySeg.Field)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.Literal),
                                begin
                                    if ((otherKeySeg.SegmentType != RpsKeySegmentType.Literal) || (!otherKeySeg.LiteralValue.Equals(thisKeySeg.LiteralValue)))
                                    begin
                                        allSegmentsMatch = false
                                    end
                                end
                                (RpsKeySegmentType.External),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'External' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                (RpsKeySegmentType.RecordNumber),
                                begin
                                    throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because an unsupported key segment type of 'Record Number' was encountered!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
                                end
                                endusing
                            end

                            if (allSegmentsMatch)
                            begin
                                segmentsMatchAnotherKey = true
                                exitloop
                            end
                        end
                    end
                end

                if (!segmentsMatchAnotherKey)
                begin
                    ;; Then process as normal
                    loop.CurrentKey = context.CurrentStructure.Keys[ix]
                    loop.CurrentIndex = ix

                    expander.Visit(node.Body)

                    prevKeysSegments.Add(loop.CurrentKey.Segments)
                end
            end

        endmethod

        private static method processForeignKeyLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            loop.MaxIndex = context.CurrentStructure.Keys.Count<RpsKey>(lambda(keyItem) { keyItem.KeyType == RpsKeyType.Foreign }) -1

            ;;If we don't have any foreign keys then we're done!
            if (loop.MaxIndex == -1)
                mreturn

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} keys", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data currentKey, @RpsKey
            loop.CurrentIndex = -1

            foreach currentKey in context.CurrentStructure.Keys
            begin
                ;;Only process foreign keys
                if (currentKey.KeyType == RpsKeyType.Foreign)
                begin
                    loop.CurrentKey = currentKey
                    loop.CurrentIndex += 1
                    expander.Visit(node.Body)
                end
            end

        endmethod

        private static method processPrimaryKeyLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            if ((context.CurrentTask.PrimaryKeyNumber > 0) && (context.CurrentTask.PrimaryKeyNumber > (context.CurrentStructure.Keys.Count - 1)))
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed using alternate key {3} because structure {4} only has {5} keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentTask.PrimaryKeyNumber, context.CurrentStructure.Name, context.CurrentStructure.Keys.Count + 1))

            loop.CurrentKey = context.CurrentStructure.Keys[context.CurrentTask.PrimaryKeyNumber]
            loop.CurrentIndex = context.CurrentTask.PrimaryKeyNumber
            loop.MaxIndex = context.CurrentTask.PrimaryKeyNumber

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 key", string.Format("<{0}>", loop.OpenToken.Value)))

            expander.Visit(node.Body)

        endmethod

        private static method processUniqueKeyLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, KeyLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Keys.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no keys!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            if (!context.CurrentStructure.Keys.Any(lambda (k) {(k.Duplicates == RpsKeyDuplicates.NoDuplicates) && (k.KeyType == RpsKeyType.Access)}))
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no unique keys!",node.OpenToken.Value,node.OpenToken.StartLineNumber,context.CurrentTemplateBaseName,context.CurrentStructure.Name))
            end

            loop.CurrentKey = context.CurrentStructure.Keys.First(lambda (k) {k.Duplicates == RpsKeyDuplicates.NoDuplicates})
            loop.CurrentIndex = context.CurrentStructure.Keys.IndexOf(loop.CurrentKey)
            loop.MaxIndex = loop.CurrentIndex

            data ix, int
            loop.FirstUniqueKeyNumber = -1
            for ix from 0 thru context.CurrentStructure.Keys.Count - 1
            begin
                ;;Skip any Foreign keys
                if (context.CurrentStructure.Keys[ix].KeyType == RpsKeyType.Foreign)
                    nextloop
                ;;Look for the first unique key
                if (context.CurrentStructure.Keys[ix].Duplicates == RpsKeyDuplicates.NoDuplicates)
                begin
                    loop.FirstUniqueKeyNumber = ix
                    exitloop
                end
            end

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 key", string.Format("<{0}>", loop.OpenToken.Value)))

            expander.Visit(node.Body)

        endmethod

        private static method processEnumLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, EnumLoopNode)
            data context = template.Context

            if (context.Repository == ^null)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no repository is being processed!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
            end

            if (context.Repository.Enumerations.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no enumerations are defined!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
            end

            loop.MaxIndex = context.Repository.Enumerations.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enums", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.Repository.Enumerations.Count - 1
            begin
                loop.CurrentEnumeration = context.Repository.Enumerations[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processStructureEnumLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, EnumLoopNode)
            data context = template.Context

            if (context.Repository.Enumerations.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no enumerations are defined!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))
            end

            ;;Build a collection of enums that are referred to by the current structure
            data enumsToProcess = new RpsEnumCollection(context.CurrentStructure.Name)

            loop.MaxIndex = enumsToProcess.Count - 1
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enums", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            ;;Anything to do?
            if (loop.MaxIndex == -1)
                mreturn

            ;;Yes, process the subset of enumerations
            data ix, int
            for ix from 0 thru loop.MaxIndex
            begin
                loop.CurrentEnumeration = enumsToProcess[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processRelationLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, RelationLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Relations.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} has no relations!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            loop.MaxIndex = context.CurrentStructure.Relations.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} relations", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.CurrentStructure.Relations.Count - 1
            begin
                loop.CurrentRelation = context.CurrentStructure.Relations[ix]
                loop.CurrentIndex = ix

                ;;Locate the "from key" information
                lambda isFromKey(k) k.Name == loop.CurrentRelation.FromKey
                loop.FromKey = context.CurrentStructure.Keys.First(isFromKey)

                ;;Load the "to structure" information
                lambda isToStructure(s) s.Name == loop.CurrentRelation.ToStructure
                loop.ToStructure = context.Structures.FirstOrDefault(isToStructure)

                ;;If the to structure was not found then it's not currently being processed
                ;;so we'll load it directly from the repository
                if (loop.ToStructure == ^null)
                begin
                    if (node.OpenToken.Value.Equals("RELATION_LOOP_RESTRICTED")) then
                    begin
                        ;;We don't have a "to structure" and we're processing a RELATION_LOOP_RESTRICTED
                        ;;so we'll just skip this relation
                        nextloop
                    end
                    else
                    begin
                        ;;If the to structure was not found then it's not currently being processed
                        ;;so we'll load it directly from the repository
                        loop.ToStructure = new RpsStructure(loop.CurrentRelation.ToStructure,context.CurrentTask.UseAlternateFieldNames)
                    end
                end

                ;Load the "to key" information
                lambda isToKey(k) k.Name == loop.CurrentRelation.ToKey
                loop.ToKey = loop.ToStructure.Keys.First(isToKey)

                expander.Visit(node.Body)
            end

        endmethod

        private static method processButtonLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            ;; TODO: Button loops need context data

            data loop = ^as(node, ButtonLoopNode)
            data context = template.Context

            context.Buttons = new WscButtonCollection()

            if ((context.Buttons == ^null) || (context.Buttons.Count == 0))
                mreturn

            loop.MaxIndex = context.Buttons.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} buttons", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.Buttons.Count - 1
            begin
                loop.CurrentButton = context.Buttons[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processFileLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, FileLoopNode)
            data context = template.Context

            if (context.CurrentStructure.Files.Count == 0)
            begin
                if (!context.Taskset.EmptyLoopFail)
                    mreturn
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because structure {3} is not assigned to any files!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, context.CurrentStructure.Name))
            end

            loop.MaxIndex = context.CurrentStructure.Files.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} files", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru context.CurrentStructure.Files.Count - 1
            begin
                loop.CurrentFile = context.CurrentStructure.Files[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processTagLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data loop = ^as(node, TagLoopNode)
            data context = template.Context

            loop.MaxIndex = context.CurrentStructure.Tags.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} tags", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            ;; Tag loops just do nothing if no tags are defined!
            data ix, int
            for ix from 0 thru context.CurrentStructure.Tags.Count - 1
            begin
                loop.CurrentTag = context.CurrentStructure.Tags[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processFieldSelectionLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. FieldLoopNode}), FieldLoopNode)
            data loop = ^as(node, SelectionLoopNode)
            data context = template.Context

            if (outerLoop.CurrentField.SelectionList.Count > 0)
            begin
                loop.MaxIndex = outerLoop.CurrentField.SelectionList.Count - 1
                loop.CurrentField = outerLoop.CurrentField

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} selections", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.CurrentField.SelectionList.Count - 1
                begin
                    loop.CurrentSelection = outerLoop.CurrentField.SelectionList[ix]
                    loop.CurrentIndex = ix

                    expander.Visit(node.Body)
                end
            end

        endmethod

        private static method processKeySegmentLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                loop.CurrentKey = outerLoop.CurrentKey
                loop.MaxIndex = outerLoop.CurrentKey.Segments.Count - 1

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.CurrentKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.CurrentKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)
                end
            end

        endmethod

        private static method getFieldForSegment, @RpsField
            required in str, @RpsStructure 
            required in seg, @RpsKeySegment 
        proc
            if (seg.SegmentType == RpsKeySegmentType.Field) then
            begin
                try
                begin
                    mreturn str.Fields.First(lambda (fld) { fld.OriginalName == seg.Field })
                end
                catch (ex, @Exception)
                begin
                    throw new ApplicationException(String.Format("When processing structure {0} key segment field {1} was not found.", str.Name, seg.Field))
                end
                endtry
            end
            else
                mreturn ^null
        endmethod

        private static method processKeySegmentFilterLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                loop.CurrentKey = outerLoop.CurrentKey
                loop.MaxIndex = outerLoop.CurrentKey.Segments.Count - 2

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int, 0
                while (ix < outerLoop.CurrentKey.Segments.Count - 1) do
                begin
                    loop.CurrentSegment = outerLoop.CurrentKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)

                    ^incr(ix, true)
                end
            end

        endmethod

        private static method processFirstKeySegmentLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context

            if (outerLoop.CurrentKey.Segments.Count > 0)
            begin
                ;; Only process the first segment
                loop.CurrentKey = outerLoop.CurrentKey
                loop.CurrentSegment = outerLoop.CurrentKey.Segments[0]
                loop.CurrentIndex = 0
                loop.MaxIndex = 0
                loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 segment", string.Format("<{0}>", loop.OpenToken.Value)))

                expander.Visit(node.Body)
            end

        endmethod

        private static method ProcessSecondKeySegmentLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. KeyLoopNode}), KeyLoopNode)
            data loop = ^as(node, SegmentLoopNode)
            data context = template.Context

            if (outerLoop.CurrentKey.Segments.Count > 1)
            begin
                ;; Only process the second segment
                loop.CurrentKey = outerLoop.CurrentKey
                loop.CurrentSegment = outerLoop.CurrentKey.Segments[1]
                loop.CurrentIndex = 1
                loop.MaxIndex = 1
                loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> 1 segment", string.Format("<{0}>", loop.OpenToken.Value)))

                expander.Visit(node.Body)
            end

        endmethod

        private static method processEnumMemberLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. EnumLoopNode}), EnumLoopNode)
            data loop = ^as(node, EnumMemberLoopNode)
            data context = template.Context

            loop.CurrentEnumeration = outerLoop.CurrentEnumeration
            loop.MaxIndex = outerLoop.CurrentEnumeration.Members.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} enum members", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru outerLoop.CurrentEnumeration.Members.Count - 1
            begin
                loop.CurrentMember = loop.CurrentEnumeration.Members[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processFromKeySegmentLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context

            if (outerLoop.FromKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.FromKey
                loop.MaxIndex = outerLoop.FromKey.Segments.Count - 1
                loop.ToStructure = outerLoop.ToStructure
                loop.ToKey = outerLoop.ToKey

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.FromKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.FromKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)
                end
            end
        endmethod

        private static method processFromKeySegmentLoopRestricted, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context

            if (outerLoop.FromKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.FromKey
                loop.MaxIndex = outerLoop.FromKey.Segments.Count - 1
                loop.ToStructure = outerLoop.ToStructure
                loop.ToKey = outerLoop.ToKey

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data lengthSoFar = 0

                data ix, int
                for ix from 0 thru outerLoop.FromKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.FromKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(context.CurrentStructure, loop.CurrentSegment)

                    lengthSoFar += loop.CurrentSegment.Length
                    if (lengthSoFar == outerLoop.ToKey.Size)
                        loop.MaxIndex = loop.CurrentIndex

                    expander.Visit(node.Body)

                    if (lengthSoFar == outerLoop.ToKey.Size)
                        exitloop
                end
            end
        endmethod

        private static method processToKeySegmentLoop, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context

            if (outerLoop.ToKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.ToKey
                loop.MaxIndex = outerLoop.ToKey.Segments.Count - 1

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.ToKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.ToKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(outerLoop.ToStructure, loop.CurrentSegment)

                    expander.Visit(node.Body)
                end
            end
        endmethod

        private static method processToKeySegmentLoopRestricted, void
            required in node,@LoopNode 
            required in template,@FileNode 
            required in loops,@IEnumerable<LoopNode> 
            required in expander,@ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. RelationLoopNode}), RelationLoopNode)
            data loop = ^as(node, RelationSegmentLoopNode)
            data context = template.Context

            data lengthSoFar = 0

            if (outerLoop.ToKey.Segments.Count > 0)
            begin
                loop.CurrentRelation = outerLoop.CurrentRelation
                loop.CurrentKey = outerLoop.ToKey
                loop.MaxIndex = outerLoop.ToKey.Segments.Count - 1

                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} segments", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

                data ix, int
                for ix from 0 thru outerLoop.ToKey.Segments.Count - 1
                begin
                    loop.CurrentSegment = outerLoop.ToKey.Segments[ix]
                    loop.CurrentIndex = ix
                    loop.CurrentField = getFieldForSegment(outerLoop.ToStructure, loop.CurrentSegment)

                    lengthSoFar += loop.CurrentSegment.Length
                    if (lengthSoFar == outerLoop.FromKey.Size)
                        loop.MaxIndex = loop.CurrentIndex

                    expander.Visit(node.Body)

                    if (lengthSoFar == outerLoop.FromKey.Size)
                        exitloop
                end
            end
        endmethod

        private static method processStructureLoop, void
            required in node, @LoopNode 
            required in template, @FileNode 
            required in loops, @IEnumerable<LoopNode> 
            required in expander, @ITreeNodeVisitor 
        proc
            data loop = ^as(node, StructureLoopNode)
            data context = template.Context
            data task = context.CurrentTask

            if (!context.MultiStructureMode)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because multi-structure mode (-ms) has not been enabled!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            loop.MaxIndex = context.Structures.Count - 1

            ;; Debug log beginning of structure loop
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} structures", string.Format("<{0}>", loop.OpenToken.Value), context.Structures.Count))

            data ix, int
            for ix from 0 thru context.Structures.Count - 1
            begin
                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1}", String.Format("Structure {0}/{1}", ix + 1, context.Structures.Count - 1), context.Structures[ix].Name), true, false)
                context.CurrentStructure = context.Structures[ix]
                context.CurrentFileIndex = context.StructureFileIndex[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

            ;; Debug log end of structure loop
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} ->", string.Format("</{0}>", loop.CloseToken.Value)))

        endmethod

        private static method processInterfaceLoop, void
            required in node, @LoopNode 
            required in template, @FileNode 
            required in loops, @IEnumerable<LoopNode> 
            required in expander, @ITreeNodeVisitor 
        proc
            data loop = ^as(node, InterfaceLoopNode)
            data context = template.Context
            data taskSet = context.Taskset
            data task = context.CurrentTask

            ;;Make sure we have SMC data
            if (taskSet.MethodCatalog == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (taskSet.MethodCatalog.Interfaces.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            loop.MaxIndex = taskSet.MethodCatalog.Interfaces.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} interfaces", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru taskSet.MethodCatalog.Interfaces.Count - 1
            begin
                loop.CurrentInterface = taskSet.MethodCatalog.Interfaces[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processMethodLoop, void
            required in node, @LoopNode 
            required in template, @FileNode 
            required in loops, @IEnumerable<LoopNode> 
            required in expander, @ITreeNodeVisitor 
        proc
            data loop = ^as(node, MethodLoopNode)
            data context = template.Context
            data taskset = context.Taskset
            data task = context.CurrentTask
            data currentInterface, @SmcInterface
            try
            begin
                data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. InterfaceLoopNode}), InterfaceLoopNode)
                currentInterface = outerLoop.CurrentInterface
            end
            catch (e, @InvalidOperationException)
            begin
                ;;We're not using an <INTERFACE_LOOP> so there is no "outer" loop
                currentInterface = taskset.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.Equals(task.Interface)})
            end
            endtry

            ;;Make sure we have SMC data
            if (taskSet.MethodCatalog == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (taskSet.MethodCatalog.Interfaces.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (currentInterface.Methods.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the current interface contains no method definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            loop.MaxIndex = currentInterface.Methods.Count - 1

            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} methods", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            data ix, int
            for ix from 0 thru currentInterface.Methods.Count - 1
            begin
                loop.CurrentInterface = currentInterface
                loop.CurrentMethod = currentInterface.Methods[ix]
                loop.CurrentIndex = ix

                expander.Visit(node.Body)
            end

        endmethod

        private static method processParameterLoop, void
            required in node, @LoopNode 
            required in template, @FileNode 
            required in loops, @IEnumerable<LoopNode> 
            required in expander, @ITreeNodeVisitor 
        proc
            data outerLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. MethodLoopNode}), MethodLoopNode)
            data loop = ^as(node, ParameterLoopNode)
            data context = template.Context
            data taskSet = context.Taskset
            data task = context.CurrentTask
            data currentInterface, @SmcInterface

            ;;Get a handle on the current SMC Interface. This is either the current interface being processed in
            ;;an outer interface loop, or the interface specified via the -interface command line option if no
            ;;interface loop is being used.
            try
            begin
                data outerOuterLoop = ^as(loops.First(lambda (loopnode) {loopnode .is. InterfaceLoopNode}), InterfaceLoopNode)
                currentInterface = outerOuterLoop.CurrentInterface
            end
            catch (e, @InvalidOperationException)
            begin
                ;;We're not using an <INTERFACE_LOOP> so there is no "outer outer" loop
                currentInterface = taskset.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.Equals(task.Interface)})
            end
            endtry

            ;;Make sure we have SMC data
            if (taskSet.MethodCatalog == ^null)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because no SMC data is available. Use the -smc command line option.", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (taskSet.MethodCatalog.Interfaces.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the SMC data contains no interface definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            if (currentInterface.Methods.Count == 0)
                throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because the current interface contains no method definitions!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName))

            ;;If there are no parameters, do nothing!
            if (outerLoop.CurrentMethod.Parameters.Count == 0)
            begin
                context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> no parameters", string.Format("<{0}>", loop.OpenToken.Value)))
                mreturn
            end

            loop.MaxIndex = outerLoop.CurrentMethod.Parameters.Count - 1

            context.CurrentStructure =^null
            context.CurrentTask.DebugLog(String.Format("   - {0,-30} -> {1} parameters", string.Format("<{0}>", loop.OpenToken.Value), loop.MaxIndex + 1))

            ;;Maintain lists of the enums and structures we have already encountered so we can support <IF FIRST_INSTANCE_OF_...>
            data processedEnums = new List<string>()
            data processedStructures = new List<string>()

            data ix, int
            for ix from 0 thru outerLoop.CurrentMethod.Parameters.Count - 1
            begin
                loop.CurrentInterface = currentInterface
                loop.CurrentMethod = outerLoop.CurrentMethod
                loop.CurrentParameter = outerLoop.CurrentMethod.Parameters[ix]
                loop.CurrentIndex = ix
                loop.FirstEnumInstance = false
                loop.FirstStructureInstance = false

                ;;If the parameter being processed is an enum paramerter then make the enum data available
                if (loop.CurrentParameter.Type == ParameterType.Enumeration) then
                begin
                    data enumName = loop.CurrentParameter.EnumName

                    ;;Is this the first time we have encountered this enum?
                    loop.FirstEnumInstance = !processedEnums.Contains(enumName)

                    try
                    begin
                        loop.CurrentEnum = new RpsEnum(enumName)
                    end
                    catch (ex, @Exception)
                    begin
                        throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because method {3} parameter {4} ({5}) refers to repository enum {6} which was not found!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, loop.CurrentMethod.Name, ix+1, loop.CurrentParameter.Name, enumName))
                    end
                    endtry

                    ;;Record that we have processed this enum
                    processedEnums.Add(enumName)
                end
                else
                    loop.CurrentEnum = ^null

                ;;If the parameter being processed is a structure paramerter then make the structure data available
                if (loop.CurrentParameter.Type == ParameterType.Structure) then
                begin
                    data structureName = loop.CurrentParameter.StructureName

                    ;;Is this the first time we have encountered this structure?
                    loop.FirstStructureInstance = !processedStructures.Contains(structureName)

                    try
                    begin
                        loop.CurrentStructure = new RpsStructure(structureName,context.CurrentTask.UseAlternateFieldNames)
                        context.CurrentStructure = loop.CurrentStructure
                    end
                    catch (ex, @Exception)
                    begin
                        throw new ApplicationException(String.Format("The <{0}> loop at line {1} in template {2} can't be processed because method {3} parameter {4} ({5}) refers to repository structure {6} which was not found!", node.OpenToken.Value, node.OpenToken.StartLineNumber, context.CurrentTemplateBaseName, loop.CurrentMethod.Name, ix+1, loop.CurrentParameter.Name, structureName))
                    end
                    endtry

                    ;;Record that we have processed this structure
                    processedStructures.Add(structureName)
                end
                else
                    loop.CurrentStructure = ^null

                expander.Visit(node.Body)
            end

            ;;Make sure we don't leave a current structure behind
            context.CurrentStructure = ^null

        endmethod

    endclass

endnamespace

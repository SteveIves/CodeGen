<CODEGEN_FILENAME><structure_name>_search.dbl</CODEGEN_FILENAME>
;//****************************************************************************
;//
;// Title:       tk_search.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: This template creates a subroutine which searches and returns
;//              a record in a master file.
;//
;// Date:        19th March 2007
;//
;// Author:      Steve Ives, Synergex Professional Services Group
;//              http://www.synergex.com
;//
;//****************************************************************************
;//
;// Copyright (c) 2012, Synergex International, Inc.
;// All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;;*****************************************************************************
;;
;; Routine:     <STRUCTURE_NAME>_SEARCH
;;
;; Description: Search for records in a master file
;;
;; Author:      <AUTHOR>
;;
;; Company:     <COMPANY>
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;
; This routine builds and processes a tab set which allows searching the master
; file based on multiple keys.  The first page of the tab set allows the user to
; select the key to be used, and optionally enter a partial value for the key
; search.  For example, for a customer file, searches may be done by account
; number, company name, city, state, zip code etc.  The user could for example
; select company name, and enter S to search for all customers beginning with S.
; When the user clicks OK or hits return, selected record is returned to the
; calling routine.
;
; The routine requires two windows to be present in the window library
; referred to by g_utlib. The names of these windows are constructed using a
; base window name which is the name of the structure:
;
;    <STRUCTURE_NAME>_CTA        ;Search criteria input window
;    <STRUCTURE_NAME>_LUP        ;Search results list input window
;
; In constructing these windows you must comply with the following requirements:
;
; Search criteria input window
; ----------------------------
;
; Must be named <STRUCTURE_NAME>_CTA and fields MUST be defined in a structure
; called <STRUCTURE_NAME>_CRITERIA
;
; The size of this window will determine the size of the search tabset.
; The first field in the window MUST be a D1 called MODE.  This field indicates
; the search mode (in other words which key to read the master file on when
; searching).  The field should normally be an enumerated selection list
; (displayed as radio buttons or a dropdown list).  The base enumeration value
; MUST be 1 and the step value MUST be 1. The field MUST specify a change method
; name of "<structure_name>_mntmode".
;
; For each selectable item in the MODE field there should be an ALPHA field of
; the appropriate size for the key value required.  These fields MUST be named
; FIELD<n> (FIELD1, FIELD2 etc.)
;
; There MUST be 2 sets defined in the window. The first set MUST be called ALL
; and MUST contain all fields in the window.  The second set MUST be called DATA
; and must contain all fields except MODE.
;
; I would recommend defining these fields in a repository structure.
;
; The keys referred to by the various MODE options MUST be encoded into the
; title of the window, as a string of D2 values.  For example, if the first
; search option uses key 2 and the second search option uses key 4, the title of
; the criteria window MUST be set to 0204
;
; An example of a search criteria window would be:
;
;       .input <STRUCTURE_NAME>_CTA, 20, 88
;       .title "0300040105"
;       .repository_structure <STRUCTURE_NAME>_CRITERIA
;       .field MODE, pos(2, 4), fpos(2, 14)
;       .field FIELD1, fpos(2, 38)
;       .field FIELD2, fpos(3, 38)
;       .field FIELD3, fpos(4, 38)
;       .field FIELD4, fpos(5, 38)
;       .field FIELD5, fpos(6, 38)
;       .set ALL, <STRUCTURE_NAME>_CRITERIA, MODE, FIELD1, FIELD2, FIELD3, FIELD4, FIELD5
;       .set DATA, <STRUCTURE_NAME>_CRITERIA, FIELD1, FIELD2, FIELD3, FIELD4, FIELD5
;       .end
;
; Search results list input window
; --------------------------------
;
; MUST be named <STRUCTURE_NAME>_LUP and MUST be one row high
;
; MUST be based on the Repository structure of the master file being maintained,
; and should contain the fields to define the columns to view in the results
; list.  Fields should have prompts and methods disabled, and should be
; positioned adjacent to each other.
;
; An example of a search results list input window would be:
;
;    .input <STRUCTURE_NAME>_LUP, 1, 67
;    .border on, dragbar(on)
;    .repository_structure <STRUCTURE_NAME>
;    .field CODE, noprompt, fpos(1, 1), nochange_method, nodrill_method
;    .field NAME, noprompt, fpos(1, 7)
;    .field CITY, noprompt, fpos(1, 33)
;    .field STATE, noprompt, fpos(1, 54), nochange_method, nodrill_method
;    .field AKEY, noprompt, fpos(1, 57)
;    .end
;
;******************************************************************************
;
subroutine <structure_name>_search

    ;Required arguments
    a_<structure_name>  ,a      ;Returned record
    a_base_title        ,a      ;Base text for tabset titles (e.g."Customer")

    ;Optional arguments
    a_channel           ,n      ;Master file update mode channel
    a_lst_header        ,a      ;Search list column headers
    a_lst_footer        ,a      ;Search list footer
    a_icon              ,a      ;Icon file name
    a_no_print          ,n      ;Suppress "Print" button
    a_no_help           ,n      ;Suppress "Help" button

    ;End of arguments

    .include "WND:tools.def"
    .include "WND:fldinf.def"
    .include "WND:setinf.def"
    .include "WND:windows.def"
    .include "DBLDIR:activex.def"
    .include "CODEGEN_INC:system.def"
    .include "CODEGEN_INC:io.def"

    ;Main data buffers
    .include "<STRUCTURE_NOALIAS>" repository, stack record="<structure_name>", nofields
    .include "<STRUCTURE_NOALIAS>_CRITERIA" repository, stack record="criteria", nofields
    .include "<STRUCTURE_NOALIAS>_CRITERIA" repository, stack record="last_criteria", nofields

    stack record ivars
        ok              ,i4     ;OK to continue
        error           ,i4     ;An error was detected
        channel         ,i4     ;Master file channel
        idi_criteria    ,i4     ;Search criteria input window
        idi_results     ,i4     ;Search list input window ID
        clsid           ,i4     ;Search list class
        idl_results     ,i4     ;Search results list
        req             ,i4     ;List processor request flag
        control         ,i4     ;Search results list AX control ID
        idt_search      ,i4     ;Search criteria / results tabset
        headers         ,i4     ;# of search list header lines
        footers         ,i4     ;# of search list footer lines
        count           ,i4     ;Local counter
        nullitem        ,i4     ;Current list item is null
        rows            ,i4     ;Height of window
        cols            ,i4     ;Width of window
        no_print        ,i4     ;Suppress "Print" button
        no_help         ,i4     ;Suppress "Help" button
    endrecord

  stack record avars
      wintitle        ,a50    ;Window title
      keynums         ,[10]d2 @wintitle   ;Array of search key numbers extracted from window title
      keynum          ,d2     ;Current key to use
      keyval          ,a80    ;Key value to match on
      winattr         ,2d3    ;Window title attributes
      msgtext         ,a80    ;Message text
    endrecord

proc

    ;Initialize data
    clear a_<structure_name>, <structure_name>
    clear criteria, last_criteria
    clear ^i(ivars), avars
    ok=true

    ;Validate required parameters

    if ((!^passed(a_base_title))||(!a_base_title))
    begin
        xcall u_msgbox("Parameter 1 (base window title) was not passed or was blank.",
        &              D_MOK+D_MICONSTOP,"Error")
        clear ok
    end

    ;Process optional parameters

    if (ok)
    begin

        if (^passed(a_lst_header)&&a_lst_header)
            headers=1

        if (^passed(a_lst_footer)&&a_lst_footer)
            footers=1

        if (^passed(a_no_print)&&a_no_print)
            no_print = TRUE

        if (^passed(a_no_help)&&a_no_help)
            no_help = TRUE

    end

    xcall e_enter

    ;Open master file (if not passed an open channel to the file)

    if (^passed(a_channel)&&a_channel&&%chopen(a_channel)) then
        channel = a_channel
    else
    begin
        xcall u_open(channel,"U:I","<FILE_NAME>",,,error)
        if (error)
        begin
            xcall u_msgbox("Failed to open file <FILE_NAME>",D_MOK+D_MICONSTOP,"Error")
            clear ok
        end
    end

    ;Build the search tabset

    if (ok)
    begin

        ;Load search criteria input window
        xcall i_ldinp(idi_criteria,,"<STRUCTURE_NAME>_CTA",D_NOPLC,,error)
        if (error) then
        begin
            xcall u_msgbox("Failed to load input window <STRUCTURE_CTA>.",D_MOK+D_MICONSTOP,"Error")
            ok=false
        end
        else
        begin
            ;Get window dimensions
            rows = %w_info(WIF_ROWS,idi_criteria)
            cols = %w_info(WIF_COLS,idi_criteria)

            ;Extract key numbers, set title & disable fields
            xcall w_info(WI_TITLE,idi_criteria,wintitle,winattr)
            xcall w_brdr(idi_criteria,WB_TITLE,"Criteria")
            xcall i_disable(D_SET,idi_criteria,"DATA")
            xcall i_enable(D_FLDS,idi_criteria,"FIELD1")
            xcall i_next(idi_criteria,,"FIELD1")
        end

        ;Create search results list
        if (ok)
        begin

            ;Load list input window
            if (ok)
            begin
                xcall i_ldinp(idi_results,,"<STRUCTURE_NAME>_LUP",D_NOPLC,,error)
                if (error) then
                begin
                    xcall u_msgbox("Failed to load input window <STRUCTURE_NAME>_LUP.",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end
                else
                    xcall w_brdr(idi_results,WB_TITLE,"Results")
            end

            ;Create list class
            if (ok)
            begin
                xcall l_class(clsid,"SEARCH_CLASS",2,2,15,headers,,footers,1,,,"<structure_name>_search_load","ACTIVEX",error)
                if (error)
                begin
                    xcall u_msgbox("Failed to create list class SEARCH_CLASS",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end
            end

            ;Create list
            if (ok)
            begin
                xcall l_create(idl_results,idi_results,<structure_name>,,"SEARCH_CLASS",,,D_NOPLC,,,,error)
                if (error)
                begin
                    xcall u_msgbox("Failed to create search list",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end

            end

            ;Configure list
            if (ok)
            begin

                ;Header
                if (headers)
                    xcall l_sect(idl_results,a_lst_header,D_HEADER)

                ;Footer
                if (footers)
                    xcall l_sect(idl_results,a_lst_footer,D_FOOTER)

                ;Customize AX control parameters
                xcall l_status(idl_results, D_LAXCTRL, control)
                xcall ax_set(control,"RowMode",1)
                xcall ax_set(control,"LightItemColor",RGB_VALUE(255,255,180))
                xcall ax_set(control,"SelBackColor",RGB_VALUE(0,0,180))

            end

        end

        ;Create search tabset

        if (ok)
        begin

            ;Create tab container and add pages

            idt_search=%ts_tabset(DTS_CREATE,"TKM_SEARCH",rows,cols)
            xcall ts_tabset(DTS_WINDOW,idt_search,idi_criteria,"<structure_name>_search_input",,"Specify search criteria")
            xcall ts_tabset(DTS_LIST,  idt_search,idl_results, "<structure_name>_search_list",,"View search results")

            ;Set tab container title

            xcall w_brdr(idt_search,WB_TITLE,%atrim(a_base_title) + " Search")

            ;Add buttons to tab container

            xcall ts_tabset(DTS_BUTTON,idt_search,"SEARCH",DSB_TEXT,"Search")
            xcall ts_tabset(DTS_BUTTON,idt_search,"SELECT", DSB_TEXT,"Select")

            if (!no_print)
                xcall ts_tabset(DTS_BUTTON,idt_search,"PRINT", DSB_TEXT,"Print")

            if (!no_help)
                xcall ts_tabset(DTS_BUTTON,idt_search,"O_HELP",DSB_TEXT,"Help")

            xcall ts_tabset(DTS_BUTTON,idt_search,"CANCEL",DSB_TEXT,"Close")
            xcall ts_tabset(DTS_BUTTONSET,idt_search,,,DSB_END,"SEARCH")

            if (wndevent_close)
            begin
                xcall u_wndevents(D_ASSIGN,wndevent_close,idt_search)
                if (^passed(a_icon)&&a_icon)
                    xcall u_icon(D_ICONSET,a_icon,1,idt_search)
            end

        end

    end

    ;Process search tabset
    if (ok)
    begin

        xcall position_window(idt_search)
        criteria = "1"
        xcall i_display(idi_criteria,"ALL",criteria)
        xcall i_next(idi_criteria,"ALL","FIELD1")
        keynum = keynums[1]
        clear keyval

        repeat
        begin

            xcall ts_process(idt_search,idt_search,channel,criteria,
            &                <structure_name>,keynums,keynum,keyval,last_criteria,
            &                no_print)

            using g_entnam select
            ("SEARCH"),
            begin
                ;Criteria page was active, go to results page
                xcall ts_tabset(DTS_ACTIVE,idt_search,2)
            end
            ("SELECT"),
            begin
                call check_null
                if (!nullitem)
                    a_<structure_name> = <structure_name>
                exitloop
            end
            ("PRINT"),
            begin
                call check_null
                if (!nullitem)
                    call print_search_results
            end
            ("CANCEL"),
                exitloop
            endusing

        end

    end

    xcall e_exit

    clear g_select

    xreturn

;---------------------------------------------------------------------------------------------------
;
check_null,

    xcall l_status(idl_results,D_LNULL,nullitem)
    if (nullitem)
    begin
        xcall u_msgbox("No records match your search criteria.\nTry different search criteria.",D_MOK+D_MICONINFO,"No Matches")
        xcall ts_tabset(DTS_ACTIVE,idt_search,1)
    end

    return

;---------------------------------------------------------------------------------------------------
;
print_search_results,

    ;Force list to completely load then position to top
    xcall w_proc(WP_HOURGLASS_ON)
    xcall u_update
    xcall u_update(FALSE)
    xcall l_queue(idl_results,D_LBOTTOM)
    xcall l_process(idl_results,req=D_LBOTTOM,<structure_name>,,channel,keynum,keyval)
    xcall w_proc(WP_HOURGLASS_OFF)
    xcall u_update(TRUE)

    ;Print the list contents
    xcall s_bld(msgtext,,"%a Search Results",a_base_title)
    xcall print_list(idl_results,<structure_name>,"TEMP:<structure_name>.smf",msgtext,,1)

    return

endsubroutine

;===================================================================================================
;
subroutine <structure_name>_search_input

    ;Arguments
    a_inpid             ,n      ;Criteria input window ID

    ;Method data
    a_tabset            ,n      ;Tabset ID
    a_channel           ,n      ;Master file channel
    a_criteria          ,a      ;Criteria record
    a_<structure_name>       ,a      ;Selected master file record
    a_keynums           ,[*]n   ;Array of key numbers
    a_keynum            ,n      ;Key number to use
    a_keyval            ,a      ;Key value to match
    a_last_criteria     ,a      ;Last used criteria
    a_no_print          ,n      ;Supress "Print" button

    ;End of arguments

.include "WND:tools.def"
.include "WND:fldinf.def"

proc

    ;Setup UI for criteria window processing

    ;xcall ui_edit(D_ON)
    ;xcall ui_okcancel(D_ON)

    xcall b_enable(a_tabset,"SEARCH")
    xcall b_disable(a_tabset,"SELECT")

    if (!a_no_print)
        xcall b_disable(a_tabset,"PRINT")

    xcall b_buttonset(a_tabset,,,,"SEARCH")

    ;Process the criteria input window

    repeat
    begin
        xcall i_input(a_inpid,"ALL",a_criteria,,,,D_NOTERM)
        if (g_setsts) then
            exitloop
        else
            xcall i_next(a_inpid,"ALL","*FRST*")

    end

    ;Reset UI

    ;xcall ui_edit(D_OFF)
    ;xcall ui_okcancel(D_OFF)

    ;Set current key number
    a_keynum = a_keynums[a_criteria(1:1)]

    ;Extract partial key value
    xcall i_fldinf(a_inpid,"FIELD"+a_criteria(1:1),,,gs_inpfld)
    a_keyval = a_criteria(gs_pos:gs_siz)

    xreturn

endsubroutine

;===================================================================================================
;This is the change method for the search mode field on the criteria page
;The criteria window that the calling passes must specify this as a change
;method on the required MODE field.  The routine enables and disables the
;appropriate filter field for the currently selected search mode (key).

function <structure_name>_mntmode ,^val ,reentrant

    ;Arguments
    a_data_entered      ,a      ;Data as entered by the user.
    a_data_stored       ,a      ;Data as stroed in variable
    a_pending_status    ,n      ;Result of Toolkit's field validations.
    .include "WND:inpinf.def"   ;Input information structure
    a_criteria          ,a      ;Input data area
    ;End of arguments

.include "WND:tools.def"

.align
stack record
    status              ,i4
    newfield            ,a10

proc

    status = a_pending_status

    ;Delete current data field content
    xcall i_init(inp_wndid,"DATA")

    ;Clear same data from input record
    clear a_criteria(2,%len(a_criteria))

    ;Disable previous and enable new data field
    newfield = "FIELD" + a_data_stored(1:1)
    xcall i_disable(D_SET,inp_wndid,"DATA")
    xcall i_enable(D_FLDS,inp_wndid,newfield)

    ;Activate new data field
    xcall i_next(inp_wndid,,newfield)

    freturn status

endfunction

;===================================================================================================
;This routine processes the list on the search results tab.
;
subroutine <structure_name>_search_list

    ;Arguments
    a_lstid             ,n      ;Search results list ID

    ;Method data
    a_tabset            ,n      ;Tabset ID
    a_channel           ,n      ;Master file channel
    a_criteria          ,a      ;Criteria record
    a_<structure_name>       ,a      ;Selected master file record
    a_keynums           ,[*]n   ;Array of key numbers
    a_keynum            ,n      ;Key number to use
    a_keyval            ,a      ;Key value to match
    a_last_criteria     ,a      ;Last used criteria
    a_no_print          ,n      ;Supress "Print" button

    ;End of arguments


.include "WND:tools.def"

stack record
    req                 ,i4     ;List processor request

proc

    ;Configure UI for search results list processing

    ;xcall ui_okcancel(D_ON)

    xcall b_disable(a_tabset,"SEARCH")
    xcall b_enable(a_tabset,"SELECT")

    if (!a_no_print)
        xcall b_enable(a_tabset,"PRINT")

    xcall b_buttonset(a_tabset,,,,"SELECT")

    ;Process the search results

    if (a_criteria!=a_last_criteria)
        xcall l_restart(a_lstid)

    xcall l_select(a_lstid,req=D_LNOP,a_<structure_name>,,,,,,,,,,,,,a_channel,a_keynum,a_keyval)

    if (!g_select)
        xcall m_signal("SELECT")

    a_last_criteria = a_criteria

    ;xcall ui_okcancel(D_OFF)

    xreturn

endsubroutine

;===================================================================================================
;This is the load method for the search results list.
;
subroutine <structure_name>_search_load

    ;Arguments
    a_listid        ,n      ;Search results list ID
    a_reqest        ,n      ;List processor request
    a_<structure_name>   ,a      ;Master file record
    a_inpid         ,n      ;Search results list input window
    a_disable       ,n      ;Current item disabled
    a_index         ,n      ;Item index being requested

    ;Method data
    a_channel       ,n      ;Master file channel
    a_keynum        ,n      ;Key number to use
    a_keyval        ,a      ;Key value to match

    ;End of arguments

.include "WND:tools.def"
.include "CODEGEN_INC:io.def"

proc

    ;If it's the first record, position to the correct starting position in
    ;the master file

    if (a_index==1)
    begin

        if (a_keyval) then
        begin
            ;Position to first match in specified key
            if (%io(IO_FIND,a_channel,,a_keynum,a_keyval,IO_PARTIAL) != IO_OK)
                a_reqest=D_LEOF
        end
        else
        begin
            ;Position to first record in specified key
            if (%io(IO_FIRST,a_channel,,a_keynum) != IO_OK)
            begin
                xcall u_msgbox("No records found",D_MOK+D_MICONINFO)
                a_reqest=D_LEOF
            end
        end

    end

    if (a_reqest!=D_LEOF)
    begin

        ;Read next record in key sequence

        repeat
        begin
            if (%io(IO_READS,a_channel,a_<structure_name>)==IO_OK) then
            begin

                ;Ignore MCBA deleted records
                if (%instr(1,a_<structure_name>,']]]]'))
                    nextloop

                ;If matching a value, make sure we're still in range
                if (a_keyval&&(%keyval(a_channel,a_<structure_name>,a_keynum)!=%atrim(a_keyval)))
                begin
                    a_reqest = D_LEOF
                    exitloop
                end

                ;Got a metching record, return it
                xcall i_display(a_inpid,,a_<structure_name>)

                exitloop

            end
            else
            begin
                ;End of file, close the list
                a_reqest = D_LEOF
                exitloop
            end
        end

    end

    xreturn

endsubroutine



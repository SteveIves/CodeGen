<CODEGEN_FILENAME><structure_name>_load.dbl</CODEGEN_FILENAME>
<PROCESS_TEMPLATE>sql_map.tpl</PROCESS_TEMPLATE>
<PROCESS_TEMPLATE>sql_insert_rows.tpl</PROCESS_TEMPLATE>
;//****************************************************************************
;//
;// Title:       sql_load_mapped.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: Template to generate a Synergy function which loads data from
;//              a data file to a database table for a mapped structure.
;//
;// Date:        12th March 2008
;//
;// Author:      Steve Ives, Synergex Professional Services Group
;//              http://www.synergex.com
;//
;//****************************************************************************
;//
;// Copyright (c) 2012, Synergex International, Inc.
;// All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;;*****************************************************************************
;;
;; Routine:     <structure_name>_load
;;
;; Author:      <AUTHOR>
;;
;; Company:     <COMPANY>
;;
;; Created:     <DATE> at <TIME>
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by <CODEGEN_VERSION>.  Any changes that
;;              you make to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;;
;; Possible return values from this routine are:
;;
;;  true    Table loaded
;;  false   Error (see a_errtxt)
;;
function <structure_name>_load ,^val

    required in  a_dbchn    ,int        ;;Connected database channel
    optional out a_errtxt   ,a          ;;Error text
    optional in  a_logex    ,boolean    ;;Log exception records
    optional in  a_terminal ,int        ;;Terminal channel to log errors on
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "<MAPPED_STRUCTURE>" repository, stack record="<mapped_structure>"
    .include "<STRUCTURE_NOALIAS>" repository, structure="<structure_name>"

    .define BUFFER_ROWS 1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok      ,boolean    ;;Return status
        filechn ,int        ;;Data file channel
        mh      ,int        ;;Memory handle containing data to insert
        ms      ,int        ;;Size of memory buffer in rows
        mc      ,int        ;;Memory buffer rows currently used
        ex_mh   ,int        ;;Memory buffer for exception records
        ex_mc   ,int        ;;Number of records in returned exception array
        ex_ch   ,int        ;;Exception log file channel
        cnt     ,int        ;;Loop counter
        errtxt  ,a512       ;;Error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Open the data file associated with the mapped structure
    begin
        open(filechn=%syn_freechn,i:i,"<MAPPED_FILE>") [ERR=fnf]
        exit
fnf,    ok = false
        errtxt = "Failed to open file <MAPPED_FILE>"
        clear filechn
    end

    if (ok)
    begin

        ;;Allocate memory buffer for the database rows
        mh = %mem_proc(DM_ALLOC,^size(<structure_name>)*(ms=BUFFER_ROWS))

        ;;Read records from the input file
        repeat
        begin

            ;;Get the next record from the input file
            reads(filechn,<mapped_structure>,eof)

            ;;Map the data into the next database record
            xcall <structure_name>_map(<mapped_structure>,^m(<structure_name>[mc+=1],mh))

            ;;If the buffer is full, write it to the database
            if (mc==ms)
                call insert_data

            if (!ok)
                exitloop

        end

eof,    ;;Any data waiting to be written?
        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(<structure_name>)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer
        mh = %mem_proc(DM_FREE,mh)

    end

    ;;Close the file
    if (filechn)
        close filechn

    ;;Close the exceptions log file
    if (ex_ch)
        close ex_ch

    ;;Return the error text
    if (^passed(a_errtxt))
        a_errtxt = errtxt

    freturn ok

insert_data,

    if (%<structure_name>_insert_rows(a_dbchn,mh,errtxt,ex_mh,a_terminal))
    begin
        ;;Any exceptions?
        if (ex_mh)
        begin
            ;;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                ;;Open the log file
                if (!ex_ch)
                    open(ex_ch=%syn_freechn,o:s,"exceptions_<structure_name>.log")
                ;;How many exceptions to log?
                ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(<structure_name>))
                ;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(<structure_name>[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to exceptions_<structure_name>.log")
            end
            else
            begin
                ;;No, report and error
                ok = false
            end
            ;;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
    end

    clear mc

    return

endfunction


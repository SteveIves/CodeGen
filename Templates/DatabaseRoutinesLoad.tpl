<CODEGEN_FILENAME><StructureName>SqlLoad.dbl</CODEGEN_FILENAME>
<PROCESS_TEMPLATE>DatabaseRoutines.tpl</PROCESS_TEMPLATE>
;//****************************************************************************
;//
;// Title:       DatabaseRoutinesLoad.tpl
;//
;// Description: Template to generate a Synergy functions which can be use to
;//              load data from an ISAM file intto a database table. This
;//              template is designed to work with UNMAPPED structures. For
;//              mapped structures use the DatabaseRoutinesLoadMapped template.
;//
;// Date:        12th March 2008
;//
;// Author:      Steve Ives, Synergex Professional Services Group
;//              http://www.synergex.com
;//
;//****************************************************************************
;//
;// Copyright (c) 2012, Synergex International, Inc.
;// All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;;*****************************************************************************
;;
;; Routine:     <StructureName>Load
;;
;; Author:      <AUTHOR>
;;
;; Company:     <COMPANY>
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;;
;; Possible return values from this routine are:
;;
;;  true    Table loaded
;;  false   Error (see a_errtxt)
;;
function <StructureName>Load ,^val

    required in    a_dbchn      ,int        ;;Connected database channel
    optional out   a_errtxt     ,a          ;;Error text
    optional in    a_logex      ,boolean    ;;Log exception records
    optional in    a_terminal   ,int        ;;Terminal channel to log errors on
    optional inout a_rows       ,int        ;;Rows to load / loaded
    optional out   a_failrows   ,int        ;;Rows that failed to load
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "<STRUCTURE_NOALIAS>" repository, structure="<structure_name>"

    .define BUFFER_ROWS 1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        filechn     ,int        ;;Data file channel
        mh          ,int        ;;Memory handle containing data to insert
        ms          ,int        ;;Size of memory buffer in rows
        mc          ,int        ;;Memory buffer rows currently used
        ex_mh       ,int        ;;Memory buffer for exception records
        ex_mc       ,int        ;;Number of records in returned exception array
        ex_ch       ,int        ;;Exception log file channel
        cnt         ,int        ;;Loop counter
        maxrows     ,int        ;;Max rows to load (for testing)
        goodrows    ,int        ;;Rows successfully inserted
        failrows    ,int        ;;Rows that failed to insert
        errtxt      ,a512       ;;Error message text
    endrecord

proc

    init local_data
    ok = true

    if (^passed(a_rows)&&a_rows) then
        maxrows = a_rows
    else
        maxrows = 0

    ;;Open the data file associated with the structure
    begin
        open(filechn=%syn_freechn,i:i,"<FILE_NAME>") [ERR=fnf]
        exit
fnf,    ok = false
        errtxt = "Failed to open file <FILE_NAME>"
        clear filechn
    end

    if (ok)
    begin
        data rowsLoaded, int, 0

        ;;Allocate memory buffer for the database rows
        mh = %mem_proc(DM_ALLOC,^size(<structure_name>)*(ms=BUFFER_ROWS))

        ;;Read records from the input file
        repeat
        begin
            ;;Get the next record from the input file
            reads(filechn,^m(<structure_name>[mc+=1],mh),eof)

            if ((maxrows)&&((rowsLoaded+=1)>maxRows))
                exitloop

            ;;If the buffer is full, write it to the database
            if (mc==ms)
                call insert_data

            if (!ok)
                exitloop
        end

eof,    ;;Any data waiting to be written?
        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(<structure_name>)*mc-=1,mh)
            call insert_data
        end

        ;;Deallocate memory buffer
        mh = %mem_proc(DM_FREE,mh)

    end

    ;;Close the file
    if (filechn)
        close filechn

    ;;Close the exceptions log file
    if (ex_ch)
        close ex_ch

    ;;Return number of rows inserted
    if (^passed(a_rows))
        a_rows = goodrows

    ;;Return number of failed rows
    if (^passed(a_failrows))
        a_failrows = failrows

    ;;Return the error text
    if (^passed(a_errtxt))
        a_errtxt = errtxt

    freturn ok

insert_data,

    if (%<StructureName>InsertRows(a_dbchn,mh,errtxt,ex_mh,a_terminal))
    begin
        ;;Any exceptions?
        if (!ex_mh) then
        begin
            goodrows += mc
        end
        else
        begin
            ;;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                ;;Open the log file
                if (!ex_ch)
                    open(ex_ch=%syn_freechn,o:s,"exceptions_<structure_name>.log")
                ;;How many exceptions to log?
                ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(<structure_name>))
                ;;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(<structure_name>[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to exceptions_<structure_name>.log")
                ;;Update the lobal counters
                goodrows += (mc-ex_mc)
                failrows += ex_mc
            end
            else
            begin
                ;;No, report and error
                ok = false
            end
            ;;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
    end

    clear mc

    return

endfunction


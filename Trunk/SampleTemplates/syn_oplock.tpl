<CODEGEN_FILENAME><Structure_Name>Oplock.dbl</CODEGEN_FILENAME>
;//****************************************************************************
;//
;// Title:       syn_oplock.tpl
;//
;// Type         CodeGen Template
;//
;// Description: This template generates a pair of Synergy functions which
;//              facilitate reading and updating an ISAM file record using an
;//              optimistic locking model.
;//
;// Date:        7th March 2008
;//
;// Author:      Steve Ives, Synergex Professional Services Group
;//              http://www.synergex.com
;//
;//****************************************************************************
;//
;// Copyright (c) 2012, Synergex International, Inc.
;// All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;;*****************************************************************************
;;
.include "<STRUCTURE_NOALIAS>" repository, structure="str<Structure_Name>", end
;;
;;*****************************************************************************
;;
;; Routine:     get<Structure_Name>.dbl
;;
;; Author:      <AUTHOR>
;;
;; Company:     <COMPANY>
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;;
function get<Structure_Name>, ^val

    a_key           ,a
    a_<structure_name>   ,str<Structure_Name>
    endparams

    stack record local_data
        errnum      ,int    ;;Returned error number, 0=success
        ch          ,int    ;;File channel
        retried     ,int    ;;Have we retried a read after lock?
    endrecord

    ;;Shared buffer to save original copy of record
    global common
        <structure_name>$original, str<Structure_Name>
    endcommon

proc

    init local_data

    ;;Clear any original saved content
    clear <structure_name>$original

    ;;Open the file
    try
        open(ch=%syn_freechn,u:i,"<FILE_NAME>")
    catch (ex, @Exception)
        errnum=-1
    endtry

    ;;Read the record
    if (!errnum)
    begin
        repeat
        begin
            try
            begin
                read(ch,<structure_name>$original,a_key)
                ;;Record read OK, unlock and return the record
                unlock ch
                a_<structure_name> = <structure_name>$original
                exitloop
            end
            catch (ex, @RecordLockedException)
            begin
                if (!retried) then
                begin
                    sleep 1
                    retried=1
                end
                else
                begin
                    errnum=2
                    exitloop
                end
            end
            catch (ex, @Exception)
            begin
                unlock ch   ;;Incase it was a "key not same"
                clear <structure_name>$original
                errnum=1
                exitloop
            end
            endtry
        end
    end

    ;;Close the file
    if (errnum!=-1)
        close ch

    freturn errnum

endfunction

;;-----------------------------------------------------------------------------
;;
function update<Structure_Name>, ^val

    <structure_name>$client, str<Structure_Name>
    endparams

    stack record local_data
        errnum      ,int    ;;Returned error number, 0=success
        ch          ,int    ;;File channel
        retried     ,int    ;;Have we retried a read after lock?
        <structure_name>$current, str<Structure_Name>
    endrecord

    ;;Shared buffer containing original copy of record
    external common
        <structure_name>$original, str<Structure_Name>
    endcommon

proc

    init local_data

    ;;Do we have a new record?
    if (!<structure_name>$client)
    begin
        ;;The new record is empty, pass the record to save
        errnum=1
    end

    ;;Do we have an original record?
    if (!errnum)
    begin
        if (!<structure_name>$original)
        begin
            ;;The original record is empty, call get_<structure_name> first!
            errnum=2
        end
    end

    ;;Did the user change the record?
    if (!errnum)
    begin
        if (<structure_name>$client!=<structure_name>$original)
        begin
            ;;Open the file
            try
                open(ch=%syn_freechn,u:i,"<FILE_NAME>")
            catch (ex, @Exception)
                errnum=-1
            endtry
        end
    end

    ;;Read and lock the current file record
    if (!errnum)
    begin
        repeat
        begin
            try
            begin
                read(ch,<structure_name>$current,%keyval(ch,<structure_name>$original,0))
                exitloop
            end
            catch (ex, @RecordLockedException)
            begin
                if (!retried) then
                begin
                    sleep 1
                    retried=1
                end
                else
                begin
                    errnum=4
                    exitloop
                end
            end
            catch (ex, @Exception)
            begin
                ;;Read failed, but not a record locked
                unlock ch   ;In case it was a "key not same"
                errnum=3
                exitloop
            end
            endtry
        end
    end

    ;;Did the record change in the file?
    if (!errnum)
    begin
        if (<structure_name>$current!=<structure_name>$original)
        begin
            ;;Someone else already changed the record
            unlock ch
            errnum=5
        end
    end

    ;;Update the record
    if (!errnum)
    begin
        try
            write(ch,<structure_name>$client)
        catch (ex, @Exception)
            errnum=6
        endtry
    end

    ;;Close the file
    if ((ch)&&(errnum!=-1))
        close ch

    ;;Clear the save buffer
    clear <structure_name>$original

    freturn errnum

endfunction

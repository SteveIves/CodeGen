;; *****************************************************************************
;; 
;;  Title:       Token.dbl
;; 
;;  Type:        Class
;; 
;;  Description: Classes and enumerations to descrive a token.
;; 
;;  Date:        30th August 2014
;; 
;;  Author:      Jeff Greene, Synergex Development
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************
import System
import System.Collections.Generic

.array 0

namespace CodeGen.Engine

    public enum TokenType
        FileHeader
        PreProcessor
        Generic
        StructureInfo
        FieldLoop
        FieldSelectionLoop
        KeyLoop
        KeySegmentLoop
        EnumLoop
        EnumMemberLoop
        RelationLoop
        ButtonLoop
        FileLoop
        TagLoop
        Window
		Counter
		CounterInstruction
        Text
        Control
        Expression
        User
        Loop
        LoopUtility
        ;; Added for expression context
        NotInLoop
        StructureLoop
    endenum

    public enum TokenModifier
        XfCase
        MixedCase
        PascalCase
        CamelCase
        None
        LowerCase
    endenum

    {Flags}
    public enum TokenValidity
        FieldLoop					, 1
        FieldSelectionLoop			, 2
        KeyLoop						, 4
        KeySegmentLoop				, 8
        EnumLoop					, 16
        EnumMemberLoop				, 32
        RelationLoop				, 64
        ButtonLoop					, 128
        FileLoop					, 256
        TagLoop						, 512
        StructureLoop				, 1024
        AnyLoop						, 2048
        NotInLoop					, 4096
        Anywhere					, 8192
    endenum

    public class TokenMeta

        public IsPaired				, boolean, false
        public Name					, string
        public TypeOfToken			, TokenType
        public Modifiers			, @Dictionary<string, TokenModifier>, new Dictionary<string, TokenModifier>()
		public SeperatedValidity	, @List<TokenValidity>
		
        public property Validity	, TokenValidity
            method set
            proc
                data expressionTypes, @List<TokenValidity>, new List<TokenValidity>()
                begin
                    data enumValue, Enum
					;foreach enumValue in Enum.GetValues(value.GetType())
					foreach enumValue in Enum.GetValues(^typeof(TokenValidity))				;TODO - IS THIS RIGHT????? LOOKS LIKE A COMPILER BUG ???
					if (value.HasFlag(enumValue))
						expressionTypes.Add((TokenValidity)enumValue)
                end
                SeperatedValidity = expressionTypes
            endmethod
        endproperty
	
	endclass

    public class Token

		public File				,string
		public StartColumn		,int
		public EndColumn		,int
		public StartLineNumber	,int
		public EndLineNumber	,int
		public Closer			,boolean
		public Value			,string
		public TypeOfToken		,TokenType
		public Modifier			,TokenModifier
		public Bucket			,@object
		
		public method Token
            aFile				,string 
            aStartIndex			,int 
            aEndIndex			,int 
            aCloser				,boolean 
            aValue				,string 
            aType				,TokenType 
            aModifier			,TokenModifier 
            aBucket				,@object 
            aLineStarts			,[#]int 
            endparams
        proc
            File = aFile
            StartLineNumber = GetLineNumber(aStartIndex, aLineStarts)
            StartColumn = aStartIndex - aLineStarts[StartLineNumber]
            EndLineNumber = GetLineNumber(aEndIndex, aLineStarts)
            StartColumn = aEndIndex - aLineStarts[EndLineNumber]
            Closer = aCloser
            Value = aValue
			TypeOfToken = aType
            Modifier = aModifier
            Bucket = aBucket
        endmethod

        private static method GetLineNumber, int
            position	, int 
            lineStarts	, [#]int 
            endparams
        proc
            data index = Array.BinarySearch(lineStarts, position)
            if (index < 0)
            begin
                ;; less than zero means we didnt match exactly a line start but the ones complement will give us the nearest following line start
                ;; we want the nearest prior, so do the ones complement then subtract one from it to get the right position
				index = (~index) - 1
			end
            mreturn index
        endmethod

        public override method ToString, string
            endparams
        proc
			using TypeOfToken select
			
			(TokenType.FileHeader, TokenType.PreProcessor),
            begin
                if (Closer) then
					mreturn String.Format("{0}: </{1}>", TypeOfToken, Value)
                else
					mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
            end
			
            (TokenType.Text),
				mreturn String.Format("{0}: {1}", TypeOfToken, Value.Replace(%char(13), "<CR>").Replace(%char(10), "<LF>").Replace(%char(9), "<TAB>"))
			
			(TokenType.Generic, TokenType.StructureInfo, TokenType.FieldLoop, TokenType.FieldSelectionLoop, TokenType.KeyLoop, TokenType.KeySegmentLoop, TokenType.EnumLoop, TokenType.EnumMemberLoop, TokenType.RelationLoop, TokenType.ButtonLoop, TokenType.FileLoop, TokenType.TagLoop, TokenType.StructureLoop, TokenType.LoopUtility, TokenType.Window, TokenType.Counter, TokenType.User),
				mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
			
            (TokenType.Control),
            begin
                if (Closer) then
					mreturn String.Format("{0}: </{1}>", TypeOfToken, Value)
                else
					mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
            end
			
			(TokenType.Expression),
            begin
				mreturn String.Format("{0}: {1}", TypeOfToken, Value)
            end
            
            (TokenType.Loop, TokenType.NotInLoop),
            begin
                if (Closer) then
					mreturn String.Format("{0}: </{1}>", TypeOfToken, Value)
                else
					mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
            end
			
			(),
				mreturn String.Format("{0}: <{1}>", TypeOfToken, Value)
			
			endusing
		
		endmethod
	
	endclass

endnamespace


;;*****************************************************************************
;;
;; Title:       ProcessButtonExpression.dbl
;;
;; Type:        Function
;;
;; Description: Processes button loop expressions
;;
;; Date:        5th November 2009
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import CodeGen.Engine
import CodeGen.RepositoryAPI
import System.Collections

namespace CodeGen.Engine

    function ProcessButtonExpression            ,boolean

        required in    BtnNbr                   ,int
        required in    TokenStart               ,int
        required in    TokenEnd                 ,int
        required inout Loop1ConditionMode       ,@ArrayList
        required inout Loop1ConditionApplies    ,@ArrayList
        required inout Loop1OutputOff           ,boolean
        required inout buffer                   ,a
        required inout ErrStatus                ,boolean
        endparams

		stack record
			result								,boolean
		endrecord
	
	proc

        Loop1ConditionMode.Add((@a)buffer(TokenStart+4,TokenEnd-1))
        Loop1ConditionApplies.Add((@boolean)false)

		result = false

        using ((a)Loop1ConditionMode[Loop1ConditionMode.Count-1]) select
		
		("CAPTION "),
            if (!String.IsNullOrWhiteSpace(Env.Buttons[BtnNbr].Caption))
                result = true
		
		("ELB "),
            if (!String.IsNullOrWhiteSpace(Env.Buttons[BtnNbr].ElbName))
                result = true
		
		("FIRST "),
			if (BtnNbr == 0)
				result = true

		("IMAGE "),
			if (!String.IsNullOrWhiteSpace(Env.Buttons[BtnNbr].ImageName))
                result = true
		
		("METHOD "),
			if (!String.IsNullOrWhiteSpace(Env.Buttons[BtnNbr].MethodName))
                result = true
		
		("QUICKSELECT "),
			if (!String.IsNullOrWhiteSpace(Env.Buttons[BtnNbr].QuickSelect))
                result = true
		
		("OKBUTTON "),
			if     (%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Name),"ok")
			&	|| (%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Caption),"ok")))
                result = true
		
		("CANCELBUTTON "),
			if     (%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Name),"cancel")
			&	|| %instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Name),"abandon")
			&	|| (%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Caption),"cancel")))
                result = true
		
		("GENERICBUTTON "),
			if     !%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Name),"ok")
			&	&& !%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Caption),"ok")
			&	&& !%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Name),"cancel")
			&	&& !%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Name),"abandon")
			&	&& !%instr(1,StringTools.LowerCase(Env.Buttons[BtnNbr].Caption),"cancel")
                result = true
		
		("MORE "),
            if (BtnNbr < Env.Buttons.Count-1)
                result = true
		
		("NOMORE "),
			if (BtnNbr == Env.Buttons.Count-1)
                result = true
		
		("COUNTER_","NOT_COUNTER_"),
			result = ProcessCounterExpression(Loop1ConditionMode)
		
		;;Presence of a user token
		("USERTOKEN_"),
		begin
			data utName, string, buffer(TokenStart+4,TokenEnd-1) - "USERTOKEN_"
			data ut, @UserToken
			
			if (Env.UserTokens==^null)
				exit
				
			foreach ut in Env.UserTokens
			begin
				if (ut.Name=="<"+utName+">")
				begin
					result = true
					exitloop
				end
			end
		end
		
		;;Absence of a user token
		("NOT_USERTOKEN_"),
		begin
			data utName, string, buffer(TokenStart+4,TokenEnd-1) - "NOT_USERTOKEN_"
			data ut, @UserToken
			data found, boolean, false
			
			if (Env.UserTokens==^null) then
			begin
				result = true
			end
			else
			begin
				foreach ut in Env.UserTokens
				begin
					if (ut.Name=="<"+utName+">")
					begin
						found=true
						exitloop
					end
				end
				result = (!found)
			end
		end

		(),
        begin
			;;If we haven't evaluated an expression by the time we get here then the only
			;;remaining possibility is that there may be a custom expression extension
			data customExpressionProcessed, Boolean, false
			
			if (Env.CustomButtonExpressions.Count>0)
			begin
				data customExpression, @CustomButtonExpression
				foreach customExpression in Env.CustomButtonExpressions
				begin
					if (customExpression.Expression.eqs.(a)Loop1ConditionMode[Loop1ConditionMode.Count-1])
					begin
						result = customExpression.Evaluate(Env.Buttons[BtnNbr])
						customExpressionProcessed = true
						exitloop
					end
				end
			end
			
			if (customExpressionProcessed)
				exit
				
			ErrStatus = Logging.Errorlog("Invalid button loop expression " + buffer(TokenStart,TokenEnd))
        end
		
		endusing

		result = result

		if (ErrStatus) then
			freturn false
		else
			freturn ProcessExpression(TokenStart,TokenEnd,Loop1ConditionMode,Loop1ConditionApplies,Loop1OutputOff,false,buffer)

    endfunction

endnamespace

;;*****************************************************************************
;;
;; Title:       ExpandSegmentToken.dbl
;;
;; Type:        Function
;;
;; Description: Expands key segment loop tokens
;;
;; Date:        5th November 2009
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import CodeGen.Engine
import CodeGen.RepositoryAPI

namespace CodeGen.Engine

    function ExpandSegmentToken         ,boolean
        required in    Segment          ,@RpsKeySegment ;;Current key segment
        required in    SegNbr           ,int            ;;Current key segment number
        required in    Fld              ,@RpsField      ;;Field referenced by current segment
        required in    TokenStart       ,int            ;;Start position of token in buffer
		required in    TokenEnd         ,int            ;;End position of token in buffer
		required in    LastSegment      ,int            ;;Is this the last segment of thy key
		required in    OutputOff		,boolean		;;Is output currently suppressed?
		required inout buffer           ,a              ;;Buffer containing token to be replaced
        endparams

        stack record
            ReplacedToken   ,boolean
        endrecord

    proc

        ReplacedToken = false

        using buffer(TokenStart,TokenEnd) select

        ("<,>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<,>",",")
            else
                ReplacedToken = ReplaceToken(buffer,"<,>","")
        end

        ("<+>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<+>","+")
            else
                ReplacedToken = ReplaceToken(buffer,"<+>","")
        end

        ("<:>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<:>",":")
            else
                ReplacedToken = ReplaceToken(buffer,"<:>","")
        end

        ("<&&>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<&&>","&&")
            else
                ReplacedToken = ReplaceToken(buffer,"<&&>","")
        end

        ("<.AND.>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<.AND.>",".AND.")
            else
                ReplacedToken = ReplaceToken(buffer,"<.AND.>","")
        end

        ("<AND>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<AND>","AND")
            else
                ReplacedToken = ReplaceToken(buffer,"<AND>","")
        end

        ("<||>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<||>","||")
            else
                ReplacedToken = ReplaceToken(buffer,"<||>","")
        end

        ("<.OR.>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<.OR.>",".OR.")
            else
                ReplacedToken = ReplaceToken(buffer,"<.OR.>","")
        end

        ("<OR>"),
        begin
            if (SegNbr<LastSegment) then
                ReplacedToken = ReplaceToken(buffer,"<OR>","OR")
            else
                ReplacedToken = ReplaceToken(buffer,"<OR>","")
        end
		
        ("<SEGMENT_CSTYPE>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_CSTYPE>",Fld.CsType)

        ("<SEGMENT_DESC>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_DESC>",Fld.Description)

        ("<SEGMENT_KIND>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_KIND>",string(Segment.SegmentType))

        ("<SEGMENT_LENGTH>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_LENGTH>",string(Segment.Length))

        ("<SEGMENT_LITVAL>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_LITVAL>",Segment.LiteralValue)

        ("<SEGMENT_NAME>","<segment_name>","<Segment_Name>","<Segment_name>","<SegmentName>","<segmentName>"),
        begin
            data SegToken, a14
            data tmpname, String
            SegToken=buffer(TokenStart,TokenEnd)
            using SegToken select
            ("<SEGMENT_NAME>"),
                tmpname=Segment.Field
            ("<segment_name>"),
                tmpname=Segment.Field.ToLower()
            ("<Segment_Name>"),
				tmpname=StringTools.MixedCase(Segment.Field)
            ("<Segment_name>"),
				tmpname=StringTools.XfCase(Segment.Field)
            ("<SegmentName>"),
				tmpname=StringTools.PascalCase(Segment.Field)
            ("<segmentName>"),
				tmpname=StringTools.CamelCase(Segment.Field)
            endusing
            ReplacedToken = ReplaceToken(buffer,SegToken,tmpname)
        end

        ("<SEGMENT_MAPPEDNAME>","<segment_mappedname>","<Segment_Mappedname>","<Segment_mappedname>","<SegmentMappedname>","<segmentMappedname>"),
        begin
            data SegToken, a20
            data tmpname, a30
            SegToken=buffer(TokenStart,TokenEnd)
            using SegToken select
            ("<SEGMENT_MAPPEDNAME>"),
                tmpname=Fld.MappedField
            ("<segment_mappedname>"),
				tmpname=StringTools.LowerCase(Fld.MappedField)
            ("<Segment_Mappedname>"),
				tmpname=StringTools.MixedCase(Fld.MappedField)
            ("<Segment_mappedname>"),
				tmpname=StringTools.XfCase(Fld.MappedField)
            ("<SegmentMappedname>"),
				tmpname=StringTools.PascalCase(Fld.MappedField)
            ("<segmentMappedname>"),
				tmpname=StringTools.CamelCase(Fld.MappedField)
            endusing
            ReplacedToken = ReplaceToken(buffer,SegToken,tmpname)
        end

        ("<SEGMENT_NUMBER>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_NUMBER>",string(SegNbr+1))

        ("<SEGMENT_ORDER>","<segment_order>"),
        begin
            data SegToken, a15
            data tmpOrder, a4
            SegToken=buffer(TokenStart,TokenEnd)
            using Segment.Order select
            (RpsKeySegmentOrder.Ascending),
                tmpOrder = "ASC"
            (RpsKeySegmentOrder.Descending),
                tmpOrder = "DESC"
            endusing
            if (SegToken=="<segment_order>")
                locase tmpOrder
            ReplacedToken = ReplaceToken(buffer,SegToken,tmpOrder)
        end

        ("<SEGMENT_POSITION>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_POSITION>",string(Segment.Position))

        ("<SEGMENT_SEQUENCE>","<segment_sequence>"),
        begin
            data SegToken, a18
            data tmpOrder, a10
            SegToken=buffer(TokenStart,TokenEnd)
            using Segment.Order select
            (RpsKeySegmentOrder.Ascending),
                tmpOrder = "ASCENDING"
            (RpsKeySegmentOrder.Descending),
                tmpOrder = "DESCENDING"
            endusing
            if (SegToken=="<segment_sequence>")
                locase tmpOrder
            ReplacedToken = ReplaceToken(buffer,SegToken,tmpOrder)
        end

		("<SEGMENT_SNTYPE>"),
			ReplacedToken = ReplaceToken(buffer,"<SEGMENT_SNTYPE>",Fld.SnType)
		
		("<SEGMENT_SPEC>","<segment_spec>"),
        begin
            data segToken, a20
            data segType, a36,""
            SegToken=buffer(TokenStart,TokenEnd)

            if (Fld.IsGroup&&!String.IsNullOrWhiteSpace(Fld.GroupStructure)&&Env.DontExpandImplicitGroups) then
            begin
                ;;We've got an implicit structure which has not been expanded
                segType = Fld.TypeCode
            end
            else
            begin
                segType=Fld.TypeCode+string(Fld.Size)
                if (Fld.Precision)
                    segType=atrim(segType)+"."+string(Fld.Precision)
                if (segToken=="<segment_spec>")
                    locase segType
            end

            ReplacedToken = ReplaceToken(buffer,segToken,segType)
        end

        ("<SEGMENT_STRUCTURE>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_STRUCTURE>",Segment.Structure )

        ("<SEGMENT_TYPE>","<segment_type>"),
        begin
            data segType, String, Segment.DataTypeName
			data segToken, String, buffer(TokenStart,TokenEnd)
			if (segToken=="<segment_type>")
                segType = segType.ToLower()
            ReplacedToken = ReplaceToken(buffer,segToken,segType)
        end

        ("<SEGMENT_VBTYPE>"),
            ReplacedToken = ReplaceToken(buffer,"<SEGMENT_VBTYPE>",Fld.VbType)
			
		("<COUNTER_"),
			ReplacedToken = ProcessCounters(buffer(TokenStart,TokenEnd),buffer,OutputOff)
		
		(),
		begin
			;;If we didn't match anything so far then lets see if we have any custom key segment loop token processors
			if (Env.CustomSegmentTokens.Count>0)
			begin
				;;We do have custom processors, look for a match
				data customToken, @CustomSegmentToken
				foreach customToken in Env.CustomSegmentTokens
				begin
					if (customToken.Token==buffer(TokenStart,TokenEnd))
					begin
						;;Found a match, expand the custom token
						ReplacedToken = customToken.Replace(Segment,SegNbr,Fld,TokenStart,TokenEnd,LastSegment,buffer)
						exitloop
					end
				end
			end
		end
		
        endusing

		if (ReplacedToken&&!buffer)
			buffer="~~~ REMOVE THIS RECORD ~~~"
		
		freturn ReplacedToken

    endfunction

endnamespace

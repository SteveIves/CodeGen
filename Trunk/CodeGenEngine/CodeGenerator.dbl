;;*****************************************************************************
;;
;; Title:       CodeGenerator.dbl
;;
;; Type:        Class
;;
;; Description: In-process callable interface to CodeGen
;;
;; Date:        
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import System
import System.Collections
import System.Collections.Generic
import System.Collections.ObjectModel
import System.IO
import Microsoft.Win32
import CodeGen.Engine
import CodeGen.RepositoryAPI

namespace CodeGen.Engine
	
	public enum LoggingLevel
		Normal,
		Verbose,
		Debug,
		DeveloperDebug
	endenum
	
	public sealed class CodeGenerator
		
		private mTaskSet						,@CodeGenTaskSet
		
		public method CodeGenerator
			required in taskset					,@CodeGenTaskSet
			endparams
		proc
			
			mTaskSet = taskset
			
			Env.Verbose = false
			Env.Debug = false
			Env.DeveloperDebug = false
			Env.SuppressLogging = false
			
			using mTaskSet.LoggingLevel select
			(LoggingLevel.Normal),
			begin
				nop
			end
			(LoggingLevel.Verbose),
			begin
				Env.Verbose = true
			end
			(LoggingLevel.Debug),
			begin
				Env.Verbose = true
				Env.Debug = true
			end
			(LoggingLevel.DeveloperDebug),
			begin
				Env.Verbose = true
				Env.Debug = true
				Env.DeveloperDebug = true
			end
			endusing
			
			;;Configure the environment (does what MAIN$CODEGEN used to do)
			configureEnvironment()
			
			;;Load Symphony extensions
			LoadSymphonyExt()
			
			;;Load other extensions
			LoadExtensions()
			
			;;Report loaded extensions (debug or developer debug mode)
			ReportExtensions()
			
			;;If we were given a repository in the task set then use it as the default repository.
			;;This repository will be used if individual tasks don't specify a repository.
			if (!String.IsNullOrWhiteSpace(mTaskset.RepositoryMainFile) && !String.IsNullOrWhiteSpace(mTaskset.RepositoryTextFile))
			begin
				data sts, i4
				xcall setlog("RPSMFIL",mTaskSet.RepositoryMainFile,sts)
				xcall setlog("RPSTFIL",mTaskSet.RepositoryTextFile,sts)
			end
			
		endmethod
		
		public method GenerateCode, Boolean
			endparams
			.include "CODEGEN_SRC:codegen.def"
		proc

			;;Raise the StartingTaskSet event
			mTaskSet.RaiseStartingTaskSet()
			
			data task, @CodeGenTask
			data taskSetComplete, Boolean, true
			
			;;Process each task
			foreach task in mTaskSet.Tasks
			begin
				;;Raise the TaskStarting event
				task.RaiseStartingTask()
				
				;;Reset the environment
				Env.Reset()

				;;Make sure that any messages that are logged while this task is executing are logged against the task
				Env.TaskMessages = task.Messages
				
				;;If this task defines a repository then use it, otherwise reset to the task set repository if specified.
				if (!String.IsNullOrWhiteSpace(task.RepositoryMainFile) && !String.IsNullOrWhiteSpace(task.RepositoryTextFile)) then
				begin
					data sts, i4
					xcall setlog("RPSMFIL",task.RepositoryMainFile,sts)
					xcall setlog("RPSTFIL",task.RepositoryTextFile,sts)
				end
				else if (!String.IsNullOrWhiteSpace(mTaskset.RepositoryMainFile) && !String.IsNullOrWhiteSpace(mTaskset.RepositoryTextFile))
				begin
					data sts, i4
					xcall setlog("RPSMFIL",mTaskSet.RepositoryMainFile,sts)
					xcall setlog("RPSTFIL",mTaskSet.RepositoryTextFile,sts)
				end
				
				;;Generate code
				task.Complete = doGenerate(task)
				
				;;Record status
				if (!task.Complete)
				begin
					task.ErrorMessage = Env.LastErrorMessage
					taskSetComplete = false
				end
				
				;;Record the files that were created by the task
				if (Env.OutputFiles!=^null)
				begin
					data outFile, String
					foreach outFile in Env.OutputFiles
					begin
						data filePath, String, Path.Combine(Env.OutputDir,outFile)
						if (!task.FilesGenerated.Contains(filePath))
							task.FilesGenerated.Add(filePath)
					end
				end
				
				;;Make sure that nothing else can be written to this tasks messages
				Env.TaskMessages = ^null
				
				;;Raise the TaskComplete event
				task.RaiseTaskComplete()
			end
			
			;;Record if everything in the task set was completed successfully
			mTaskSet.Complete = taskSetComplete
			
			;;Raise the TaskSetComplete event
			mTaskSet.RaiseTaskSetComplete()
			
			mreturn mTaskSet.Complete
			
		endmethod
		
		;;;<summary>
		;;;Performs code generation for a single task
		;;;</summary>
		private method doGenerate, Boolean
			required in task, @CodeGenTask
			endparams
			
			stack record
				ErrStatus		,boolean					;;Main error status variable
				StrNum			,int						;;Structure number being processed
				FileIndex		,[#]int						;;Array of file indexes to use
				WscFile			,String						;;UI Toolkit window script file
				ProFormaFile	,String						;;BusinessCraft ProForma file name
				Templates		,@List<String>				;;Collection of template names
				Structures		,@RpsStructureCollection	;;Collection of repository structures
				FileDef			,@RpsFile					;;Repository file definition name
			endrecord
			
			external function
				CleanScriptField, a
			endexternal
			
		proc
			
			;;-------------------------------------------------------------------------
			;;This code basically does what CodeGenLauncher normally does, except for
			;;loading extensions which has already been done, and setting the logging
			;;level which has been done for the whole taskset.
			;;-------------------------------------------------------------------------
			ErrStatus = false
			WscFile = ""
			
			;;-------------------------------------------------------------------------
			;;Echo command line?
			
			if (mTaskSet.EchoCommands)
				echoCommand(task)
			
			;;-------------------------------------------------------------------------
			;;Display heading
			
			Logging.VerboseLog("CodeGen " + CODEGEN_VERSION,true,true)
			
			;;-------------------------------------------------------------------------
			;;Display file names mode
			
			Env.ListFiles = (mTaskSet.ListGeneratedFiles&&(!Env.Verbose))
			
			;;-------------------------------------------------------------------------
			;;Do we have a custom data mappings file specified?
			
			if (!ErrStatus)
			begin
				if (!String.IsNullOrWhiteSpace(mTaskSet.DataMappingsFile))
				begin
					;;Try open the data mappings file.
					;;Don't replace this with File.Exists because we'd lose support for logical names.
					if (FileTools.FileExists(mTaskSet.DataMappingsFile)) then
					begin
						data tmpsts, i4
						xcall setlog("CODEGEN_DATAMAPPING_FILE",mTaskSet.DataMappingsFile,tmpsts)
						if (Env.DeveloperDebug)
							Logging.DebugLog("DEVDBG: Custom data mapping file set to " + mTaskSet.DataMappingsFile)
					end
					else
						ErrStatus = Logging.Errorlog("Failed to open custom data mappings file " + mTaskSet.DataMappingsFile)
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have a template folder specified via CODEGEN_TPLDIR: ?
			;;If so this overrides the default location of current directory.
			
			if (!ErrStatus)
			begin
				data tmpbuf, a256
				data length, int
				xcall getlog("CODEGEN_TPLDIR",tmpbuf,length)
				if (length)
				begin
					data tplFolder, String, tmpbuf(1:length)

					;;Make sure the path ends with either a : (logical) or \
					if (!tplFolder.EndsWith(":") && !tplFolder.EndsWith("\"))
						tplFolder += "\"

					;;Make sure the folder exists
					if (!FileTools.FolderExists(tplFolder))
					begin
						;;CODEGEN_TPLDIR: is bad, but do we care?
						if (String.IsNullOrWhiteSpace(task.TemplateFolder) && String.IsNullOrWhiteSpace(mTaskSet.TemplateFolder))
						begin
							;;Yes, we care!
							ErrStatus = Logging.ErrorLog(String.Format("CODEGEN_TPLDIR points to {0} which doesn't exist!",tplFolder))
						end
					end

					;;Looks like we're using CODEGEN_TPLDIR: for now
					if (!ErrStatus)
					begin
						Env.TemplateDir = tplFolder
						if (Env.DeveloperDebug)
							Logging.DebugLog(String.Format("DEVDBG: CODEGEN_TPLDIR sets template folder to {0}",Env.TemplateDir))
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have a template folder specified for the task or taskset?
			;;If so this overrides CODEGEN_TPLDIR:
			
			if (!ErrStatus)
			begin
				if (!String.IsNullOrWhiteSpace(task.TemplateFolder)) then
				begin
					;;Is the folder valid?
					if (!FileTools.FolderExists(task.TemplateFolder)) then
						ErrStatus = Logging.ErrorLog(String.Format("Task specifies an invalid template folder {0}!",task.TemplateFolder))
					else
					begin
						Env.TemplateDir = task.TemplateFolder
						if (Env.DeveloperDebug)
							Logging.DebugLog(String.Format("DEVDBG: Task sets template folder to {0}",Env.TemplateDir))
					end
				end
				else if (!String.IsNullOrWhiteSpace(mTaskSet.TemplateFolder))
				begin
					;;Is the folder valid?
					if (!FileTools.FolderExists(mTaskSet.TemplateFolder)) then
						ErrStatus = Logging.ErrorLog(String.Format("Task set specifies an invalid template folder {0}!",mTaskSet.TemplateFolder))
					else
					begin
						Env.TemplateDir = mTaskSet.TemplateFolder
						if (Env.DeveloperDebug)
							Logging.DebugLog(String.Format("DEVDBG: Task set sets template folder to {0}",Env.TemplateDir))
					end
				end
			end

			;;-------------------------------------------------------------------------
			;;Make sure there are template file(s) in the template folder
			
			if (!ErrStatus && !FileTools.FolderContainsFilesOfType(Env.TemplateDir,"*.tpl"))
				ErrStatus = Logging.ErrorLog("No templates found in the template folder " + Env.TemplateDir)

			;;-------------------------------------------------------------------------
			;;Report template file location (verbose mode only)
			
			if ((!ErrStatus) && Env.Verbose)
			begin
				if (Env.TemplateDir) then
					Logging.Log("Template location: " + Env.TemplateDir)
				else
					Logging.Log("Template location: Current directory")
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have an output location specified with CODEGEN_OUTDIR
			;;If present, this location overrides the default location (current dir)
			
			if (!ErrStatus)
			begin
				data tmpbuf, a256
				data length, int
				xcall getlog("CODEGEN_OUTDIR",tmpbuf,length)
				if (length)
				begin
					data outFolder, String, tmpbuf(1:length)
					
					;;Make sure the path ends with either a : (logical) or \
					if (!outFolder.EndsWith(":") && !outFolder.EndsWith("\"))
						outFolder += "\"
						
					;;Make sure the folder exists
					if (!FileTools.FolderExists(outFolder))
					begin
						;;CODEGEN_OUTDIR: is bad, but do we care?
						if (String.IsNullOrWhiteSpace(task.OutputFolder) && String.IsNullOrWhiteSpace(mTaskSet.OutputFolder))
						begin
							;;Yes, we care!
							ErrStatus = Logging.ErrorLog(String.Format("CODEGEN_OUTDIR points to {0} which doesn't exist!",outFolder))
						end
					end
					
					;;Looks like we're using CODEGEN_OUTDIR: for now
					if (!ErrStatus)
					begin
						Env.OutputDir = outFolder
						if (Env.DeveloperDebug)
							Logging.DebugLog(String.Format("DEVDBG: CODEGEN_OUTDIR sets output folder to {0}",Env.OutputDir))
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have an output location command line option
			;;If present, this location overrides the default and CODEGEN_OUTDIR
			
			if (!ErrStatus)
			begin
				if (!String.IsNullOrWhiteSpace(task.OutputFolder)) then
				begin
					;;Is the folder valid?
					if (!FileTools.FolderExists(task.OutputFolder)) then
						ErrStatus = Logging.ErrorLog(String.Format("Task output folder {0} is invalid!",task.OutputFolder))
					else
					begin
						Env.OutputDir = task.OutputFolder
						if (Env.DeveloperDebug)
							Logging.DebugLog(String.Format("DEVDBG: Task sets output folder to {0}",Env.OutputDir))
					end
				end
				else if (!String.IsNullOrWhiteSpace(mTaskSet.OutputFolder))
				begin
					;;Is the folder valid?
					if (!FileTools.FolderExists(mTaskSet.OutputFolder)) then
						ErrStatus = Logging.ErrorLog(String.Format("TaskSet output folder {0} is invalid!",mTaskSet.OutputFolder))
					else
					begin
						Env.OutputDir = mTaskSet.OutputFolder
						if (Env.DeveloperDebug)
							Logging.DebugLog(String.Format("DEVDBG: Task set sets output folder to {0}",Env.OutputDir))
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Make sure we can create files in the output folder
			
			if (!ErrStatus && !FileTools.CanCreateFileInFolder(Env.OutputDir))
				ErrStatus = Logging.ErrorLog(String.Format("Can't create files in output folder {0}!",Env.OutputDir))
			
			;;-------------------------------------------------------------------------
			;;Report output location (verbose mode only)
			
			if (!ErrStatus && Env.Verbose)
			begin
				if (Env.OutputDir) then
					Logging.Log("Output location:   " + Env.OutputDir)
				else
					Logging.Log("Output location:   Current directory")
			end
			
			;;-------------------------------------------------------------------------
			;;Make sure we can create files in the output location.  The output location
			;;variable is in global data, for use by the generator routines.
			
			if (!ErrStatus&&!FileTools.CanCreateFileInFolder(Env.OutputDir))
				ErrStatus = Logging.Errorlog("Can't create files in " + Env.OutputDir)
			
			;;-------------------------------------------------------------------------
			;;Replace existing files?
			
			if (!ErrStatus)
			begin
				Env.ReplaceFiles = task.ReplaceFiles
				if (Env.ReplaceFiles) then
					Logging.VerboseLog("Replace files:     YES")
				else
					Logging.VerboseLog("Replace files:     NO")
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have an author name specified with CODEGEN_AUTHOR
			;;If present, this location overrides the default author (CodeGen)
			
			if (!ErrStatus)
			begin
				data tmpbuf, a80
				data length, int
				getlog("CODEGEN_AUTHOR",tmpbuf,length)
				if (length)
				begin
					Env.Author = tmpbuf
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: Author name set by CODEGEN_AUTHOR to " + Env.Author)				
				end
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have an company name specified with CODEGEN_COMPANY
			;;If present, this location overrides the default company (Synergex)
			
			if (!ErrStatus)
			begin
				data tmpbuf, a80
				data length, int
				getlog("CODEGEN_COMPANY",tmpbuf,length)
				if (length)
				begin
					Env.Company = tmpbuf
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: Company name set by CODEGEN_COMPANY to " + Env.Company)				
				end
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have a default namespace specified with SYNDEFNS
			;;If present, this location overrides the default of "codegen"
			
			if (!ErrStatus)
			begin
				data tmpbuf, a80
				data length, int
				getlog("SYNDEFNS",tmpbuf,length)
				if (length)
					Env.DefaultNamespace = tmpbuf
				if (Env.DeveloperDebug)
					Logging.DebugLog("DEVDBG: Namespace set by SYNDEFNS to " + Env.DefaultNamespace)				
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have a default namespace command line option
			;;If present, this location overrides the SYNDEFNS environment variable.
			
			if (!ErrStatus && !String.IsNullOrWhiteSpace(task.Namespace))
			begin
				Env.DefaultNamespace = task.Namespace
				if (Env.DeveloperDebug)
					Logging.DebugLog("DEVDBG: Namespace set by Namespace property to " + Env.DefaultNamespace)				
			end
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to use a field / group member prefix
			if (!ErrStatus)
			begin
				if (!String.IsNullOrWhiteSpace(task.FieldPrefix)) then
				begin
					Env.ClDoFieldPrefix = true
					Env.ClFieldPrefix = task.FieldPrefix
				end
				else
				begin
					Env.ClDoFieldPrefix = false
					Env.ClFieldPrefix = ""
				end
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have a request to override the default pixel width of a character
			
			if (!ErrStatus && (task.CharacterWidth>0))
				Env.CharacterWidth = task.CharacterWidth
			
			;;-------------------------------------------------------------------------
			;;See if we have a request to override the default pixel height of a row
			
			if (!ErrStatus && (task.CharacterHeight>0))
				Env.CharacterHeight = task.CharacterHeight
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to override the key that is used with the <PRIMARY_KEY> construct?
			
			if (!ErrStatus && (task.PrimaryKeyNumber!=0))
			begin
				Env.OverridePrimaryKeyNum = task.PrimaryKeyNumber
				Logging.DebugLog("<PRIMARY_KEY> blocks will use key "+string(Env.OverridePrimaryKeyNum),true,false)
			end
			
			;;-------------------------------------------------------------------------
			;;Get a list of template files in template directory
			
			if (!ErrStatus)
			begin
				Logging.VerboseLog("")
				
				if (task.Templates.Count==0) then
				begin
					Logging.Log("Nothing to do! Specify template(s) via the Templates property!")
					ErrStatus = true
				end
				else
				begin
					if (task.Templates[0]=="*") then
					begin
						Templates = FileTools.GetFileNamesInFolder(Env.TemplateDir,"*.tpl")
						if (Templates.Count==0)
							ErrStatus = Logging.Errorlog("No templates to process in " + Env.TemplateDir)
					end
					else
					begin						
						;;Create a new templates collection
						Templates = new List<String>()
						
						;;Check that all of the specified template files exist
						data ix, int
						for ix from 0 thru task.Templates.Count -1
						begin
							;;Add ".tpl" if necessary
							if (!task.Templates[ix].ToLower().EndsWith(".tpl"))
								task.Templates[ix] = task.Templates[ix] + ".tpl"
							
							;;Does this template spec contain a wildward?
							if (task.Templates[ix].Contains("*")) then
							begin
								data matchingFiles, @List<String>, FileTools.GetFileNamesInFolder(Env.TemplateDir,task.Templates[ix])
								if (matchingFiles.Count>0) then
								begin
									;;Add these templates to the list to process, if not already in the list
									data matchingFile, String
									foreach matchingFile in matchingFiles
										AlUtil.AddIfMissing(Templates,matchingFile)
								end
								else
									Logging.Log(String.Format("WARNING: No templates match {0}",task.Templates[ix]),false,true)
							end
							else
							begin
								;;Make sure the template can be opened
								if (!FileTools.FileExists(Env.TemplateDir+task.Templates[ix]))
								begin
									ErrStatus = Logging.Errorlog("Template " + task.Templates[ix] + " not found!")
									exitloop
								end
								
								;;Add the template to the collection
								AlUtil.AddIfMissing(Templates,task.Templates[ix])
							end
						end
					end
				end
				
				if (!ErrStatus)
				begin
					data ix, int
					;;Report templates to process
					if (Env.Verbose)
					begin
						data tmpTemplate, String
						Logging.Log("Template(s):")
						foreach tmpTemplate in Templates
							Logging.Log(" - " + tmpTemplate)
					end
					;;Remove .tpl file extensions
					for ix from 0 thru Templates.Count-1
						Templates[ix] = ((String)Templates[ix]).Replace(".tpl","")
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to process a user defined token file?
			
			if (!ErrStatus && (!String.IsNullOrWhiteSpace(task.UserTokenFile)))
			begin
				try
				begin
					UserTokenCollection.LoadTokensFromFile(task.UserTokenFile)
				end
				catch (ex)
				begin
					ErrStatus = Logging.Errorlog("Failed to open or process user token file " + task.UserTokenFile)
				end
				endtry
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have user defined tokens on the command line?
			
			if (!ErrStatus && (task.UserTokens.Count>0))
			begin
				if (Env.UserTokens==^null||Env.UserTokens.Count==0) then
					Env.UserTokens = task.UserTokens
				else
					UserTokenCollection.AddTokens(task.UserTokens)
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have a repository file definition specified?
			
			if (!ErrStatus && (!String.IsNullOrWhiteSpace(task.RepositoryFile)))
			begin
				;;Get the file details from the repository
				task.RepositoryFile = task.RepositoryFile.ToUpper()
				try
				begin
					FileDef = new RpsFile(task.RepositoryFile)
				end
				catch (e, @RpsFileException)
				begin
					ErrStatus = Logging.Errorlog("Failed to load repository file definition " + task.RepositoryFile)
				end
				endtry
				
				if (!ErrStatus)
				begin
					;;Make sure the file has at least one structure defined, and if so set them as the structures to process
					if (FileDef.StructureCount>0) then
					begin
						Structures = FileDef.Structures
						Env.RpsInUse = true
						
						;;Default all structures to use the file being processed
						begin
							data ix, int
							FileIndex = new int[Structures.Count]
							for ix from 0 thru Structures.Count-1
							begin
								data iy, int
								FileIndex[ix+1] = 0
								for iy from 0 thru Structures[ix].Files.Count-1
								begin
									if (Structures[ix].Files[iy].Name==FileDef.Name)
									begin
										FileIndex[ix+1] = iy
										exitloop
									end
								end
							end
						end
						
					end
					else
						ErrStatus = Logging.Errorlog("Repository file " + task.RepositoryFile + " doesn't have any structures assigned")
				end					
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have a UI Toolkit window script specified?
			
			if (!ErrStatus && (!String.IsNullOrWhiteSpace(task.WindowScript)))
			begin
				if (!String.IsNullOrWhiteSpace(task.RepositoryFile)) then
					ErrStatus = Logging.Errorlog("The repository file and window script file options can't be used together!")
				else
				begin
					WscFile = task.WindowScript
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: Window script file " + WscFile + " will br processed")
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to ignore field attributes in UI Toolkit window scripts
			
			if (!ErrStatus)
				Env.NoWscAttributes = task.IgnoreScriptFieldAttributes
			
			;;-------------------------------------------------------------------------
			;;Do we have a BusinessCraft Proforma file specified?
			
			if (!ErrStatus && (!String.IsNullOrWhiteSpace(task.ProformaFile)))
			begin
				if (FileDef!=^null) then
				begin
					Console.WriteLine("ERROR: Proforma and repository file processing can't be used together!")
					ErrStatus = true
				end
				else if (!String.IsNullOrWhiteSpace(WscFile)) then
				begin
					Console.WriteLine("ERROR: Proforma and window script processing can't be used together!")
					ErrStatus = true
				end
				else
				begin
					ProFormaFile = task.ProformaFile
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: ProForma file was specified via -proforma")					
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Are we provided with a UI Toolkit window script to search for selection windows in?
			
			if (!ErrStatus && (!String.IsNullOrWhiteSpace(task.SelectionWindowScript)))
			begin
				;;Open the file, fail if can't. Don't use File.Exists so that logicals are supported.
				if (FileTools.FileExists(task.SelectionWindowScript)) then
				begin
					Env.SelectionWindowScript = task.SelectionWindowScript
					Logging.DebugLog(String.Format("Selection window processing enabled from file {0}",Env.SelectionWindowScript))
				end
				else
					ErrStatus = Logging.Errorlog(String.Format("Can't open selection window script {0}. Check your -ws option!",task.SelectionWindowScript))
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have Repository structures specified?
			
			if (!ErrStatus && (task.Structures.Count>0))
			begin
				if (FileDef!=^null) then
					ErrStatus = Logging.Errorlog("You can't specify both a repository file and repository structures at the same time!")
				else if (!String.IsNullOrWhiteSpace(task.WindowScript)) then
					ErrStatus = Logging.Errorlog("You can't specify a window script and repository structures at the same time!")
				else if (!String.IsNullOrEmpty(ProFormaFile)) then
					ErrStatus = Logging.Errorlog("You can't specify a proforma file and repository structures at the same time!")
				else
				begin
					Env.RpsInUse = true
					
					;;All or specific structures?
					if (task.Structures[0]=="*") then
					begin
						;;Process all structures
						try
						begin
							Structures = new RpsStructureCollection(RpsLoadMode.Load)
							if (Structures.Count) then
								Env.AllStructures = true
							else
								ErrStatus = Logging.Errorlog("Your repository contains no structures!")
						end
						catch (ex, @RpsException)
						begin
							ErrStatus = Logging.Errorlog(ex.Message)
						end
						endtry
					end
					else
					begin
						;;Process specified structures
						data ix, int
						Structures = new RpsStructureCollection(RpsLoadMode.NoLoad)
						for ix from 0 thru task.Structures.Count-1 
						begin
							try
							begin
								data newStructure, @RpsStructure, new RpsStructure(task.Structures[ix])
								data errorText, String
								if (!String.IsNullOrWhiteSpace(Env.SelectionWindowScript))
								begin
									if (!ProcessSelectionWindows(newStructure,errorText))
									begin
										ErrStatus = Logging.Errorlog(String.Format("Failed to resolve selection windows for structure {0}. Error was {1}.",newStructure.Name,errorText))
										exitloop
									end
								end
								Structures.Add(newStructure)
							end
							catch (ex)
							begin
								ErrStatus = Logging.Errorlog(ex.Message)
							end
							endtry
						end
					end
					
					;;Default all structures to use the first file assigned
					if (!ErrStatus)
					begin
						data ix, int
						FileIndex = new int[Structures.Count]
						for ix from 1 thru Structures.Count
							FileIndex[ix] = 0
					end							
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to process a subset of the fields in a structure?
			
			if (!ErrStatus && (!String.IsNullOrWhiteSpace(task.Subset)))
			begin
				if (!Env.RpsInUse) then
					ErrStatus = Logging.Errorlog("Field subsets can't be used without a repository structure!")
				else if (!ErrStatus&&Structures.Count>1) then
					ErrStatus = Logging.Errorlog("Field subsets can only be used when processing a single structure!")
				else
				begin
					Env.SubSetName = task.Subset
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: Subset processing was enabled for subset " + Env.SubSetName)					
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to create a subset from a list of field names?
			
			if (!ErrStatus && (task.SubsetFields.Count>0))
			begin
				if (!Env.RpsInUse) then
					ErrStatus = Logging.Errorlog("Field subsets can't be used without a repository structure!")
				else if (Structures.Count>1) then
					ErrStatus = Logging.Errorlog("Field subsets can only be used when processing a single structure!")
				else if (!String.IsNullOrWhiteSpace(Env.SubSetName)) then
					ErrStatus = Logging.Errorlog("Field subsets from field names can't be used at the same time as a named subset!")
				else
				begin
					data fieldName, String
					foreach fieldName in task.SubsetFields
						Env.SubSetFields.Add(fieldName.ToUpper())
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: Subset processing was enabled via a list of supplied field names")					
				end
			end
			
			;;-------------------------------------------------------------------------
			;;If we have a window script file or ProForma file then process it
			
			if (!ErrStatus)
			begin
				
				;;Create a default (empty) button collection
				Env.Buttons = new WscButtonCollection()
				
				;;Now parse the script file
				if (!String.IsNullOrWhiteSpace(WscFile)) then
				begin
					data errTxt, string
					
					if (Env.DeveloperDebug)
						Logging.DebugLog("DEVDBG: Parsing window script " + WscFile)					
					
					ErrStatus = (boolean)ParseWindowScript(WscFile,Structures,errTxt)
				end
				else if (!String.IsNullOrWhiteSpace(ProFormaFile))
				begin
					data errTxt, string
					data address, D_ADDR
					
					;;Try to load the Proforma extensions
					if (!%loadProformaExtensions()) then
						ErrStatus = true
					else
					begin
						if (Env.DeveloperDebug)
							Logging.DebugLog("DEVDBG: Parsing ProForma file " + ProFormaFile)					
						
						if (address = %xaddr("ParseProForma",,1)) then
						begin
							data pfStructure, @RpsStructure
							
							Env.ProFormaStructures = new RpsStructureCollection(RpsLoadMode.NoLoad)
							
							try
							begin
								Logging.DebugLog("Executing ParseProForma()")
								
								if (ErrStatus = (boolean)%xsubr(address,(a)ProFormaFile))
									exit
								
								;;Did we get any structures loaded?
								if (!Env.ProFormaStructures.Count)
									ErrStatus = Logging.Errorlog("ParseProForma() did not load any structures!")
							end
							catch (e, @Exception)
							begin
								ErrStatus = Logging.Errorlog(String.Format("Failed to execute ParseProForma(). Error was {0}",e.Message))
								if (e.InnerException!=^null)
									Logging.Log(String.Format("       {0}",e.InnerException.Message))
							end
							endtry
							
							;;Load the structures from ParseProForma()
							if (!ErrStatus)
							begin
								if (Structures == ^null)
									Structures = new RpsStructureCollection(RpsLoadMode.NoLoad)
								
								foreach pfStructure in Env.ProFormaStructures
									Structures.Add(pfStructure)
								
								Env.RpsInUse = true
							end
						end
						else
							ErrStatus = Logging.Errorlog("Failed to locate the ParseProForma() routine!")
					end
				end
				
				if (ErrStatus)
					exit
				
				;;Default the structures to using the first assigned file definition
				if (Structures!=^null)
				begin
					data ix, int
					FileIndex = new int[Structures.Count]
					for ix from 1 thru Structures.Count
						FileIndex[ix] = 0
				end
				
				;;If we got buttons from the script file, but we're being told not to do
				;;button processing (-bn), then delete the buttons
				if (task.NeverLoadAnyButtons && (Env.Buttons.Count > 0))
				begin
					Logging.DebugLog("Removing script file buttons because of the NeverLoadAnyButtons property")
					Env.Buttons.Clear()
				end
				
				;;If after parsing the script file we don't have any buttons, or we are being
				;;told to always use default buttons (-ba), and we're not being told to not
				;;load default buttons (-bd) and were not being told to not use any buttons
				;;(-bn) then add the default buttons that are defined in
				;;CODEGEN_EXE:DefaultButtons.xml
				if (((Env.Buttons.Count == 0) || (task.AlwaysLoadDefaultButtons)) && (!task.NeverLoadDefaultButtons) && (!task.NeverLoadAnyButtons))
				begin
					if (Env.Buttons.Count == 0) then
						Logging.DebugLog("Loading default buttons because no script file buttons were found",true,false)
					else if (task.AlwaysLoadDefaultButtons)
						Logging.DebugLog("Loading default buttons because of the AlwaysLoadDefaultButtons property",true,false)
					Env.Buttons.LoadDefaultButtons()
				end
				
			end
			
			;;-------------------------------------------------------------------------
			;;Report if we're doing Repository processing
			
			if (!ErrStatus && Env.Verbose)
			begin
				if (Env.RpsInUse) then
				begin
					data str, @RpsStructure
					Logging.Log("Structure(s):",true,false)
					
					foreach str in Structures
						Logging.Log(" - " + str.Name)
				end
				else
					Logging.Log("No Repository structure processing")
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have structure aliases specified
			
			if (!ErrStatus&&Structures!=^null)
			begin
				data tmpStr, @RpsStructure
				data AliasIndex, int
				
				;;First, default all alias names to the same as the structure name
				foreach tmpStr in Structures
					tmpStr.Alias = tmpStr.Name
				
				;;Now apply specific aliases from the command line
				if (task.Aliases.Count>0)
				begin
					if (!String.IsNullOrWhiteSpace(WscFile)) then
						ErrStatus = Logging.Errorlog("Can't use WindowScript and Aliases properties together!")
					else if (task.Aliases.Count > Structures.Count) then
						ErrStatus = Logging.Errorlog("More aliases than repository structures!")
					else
					begin
						Logging.VerboseLog("Applying structure aliases",true,false)
						for AliasIndex from 0 thru task.Aliases.Count - 1
						begin
							Structures[AliasIndex].Alias = task.Aliases[AliasIndex].ToUpper()
							Logging.VerboseLog(" - Structure " + Structures[AliasIndex].Name + " aliased as " + Structures[AliasIndex].Alias)
						end
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Do we have alternate repository file references specified
			
			if (!ErrStatus && (task.FileOverrides.Count>0))
			begin
				if ((Structures==^null)||(!Structures.Count)) then
					ErrStatus = Logging.Errorlog("File overrides can only be used when structures are being processed!")
				else if (task.FileOverrides.Count > Structures.Count) then
					ErrStatus = Logging.Errorlog("You have specified more file name overrides than structures!")
				else if (!String.IsNullOrWhiteSpace(WscFile)) then
					ErrStatus = Logging.Errorlog("File overrides can't be used when processing a window script file!")
				else
				begin
					;;Check that the alternate file names are valid for the structures
					data clFileIndex, int
					for clFileIndex from 0 thru task.FileOverrides.Count -1
					begin
						data tmpStr, @RpsStructure
						data strFileIndex, int
						data foundFile, Boolean, false
						task.FileOverrides[clFileIndex] = task.FileOverrides[clFileIndex].ToUpper()
						
						tmpStr = Structures[clFileIndex]
						
						for strFileIndex from 0 thru tmpStr.Files.Count-1
						begin
							if (tmpStr.Files[strFileIndex].Name.eqs.task.FileOverrides[clFileIndex])
							begin
								;;Found it - this is the one we need later
								FileIndex[clFileIndex] = strFileIndex
								foundFile = true
								Logging.VerboseLog("Using file definition " + tmpStr.Files[strFileIndex].Name,true,false)
								exitloop
							end
						end
						if (!foundFile)
						begin
							ErrStatus = Logging.Errorlog("Structure "+tmpStr.Name+" is not assigned to file "+task.FileOverrides[clFileIndex])
							exitloop
						end
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have any special field processing filters specified
			
			if (!ErrStatus)
			begin
				;;Default to enabling the "excluded by language" filter
				Env.ExcludeLanguage = true
				
				if (task.IncludeOverlayFields||task.IgnoreExcludeLanguage||task.HonorExcludeToolkit||task.HonorExcludeReportWriter||task.HonorExcludeWeb)
				begin
					if (Env.GenFromWsc) then
					begin
						;;Can't use filters if we're processing a script file, the fields to include are determined by the script file.
						ErrStatus = Logging.Errorlog("Can't use field filters when processing a window script!")
					end
					else
					begin
						Logging.VerboseLog("Custom field filters in use")
						
						if (task.IncludeOverlayFields)
						begin
							Env.IncludeOverlays = true
							Logging.VerboseLog(" - Overlays will be included")
						end
						
						if (task.IgnoreExcludeLanguage)
						begin
							Env.ExcludeLanguage = false
							Logging.VerboseLog(" - 'Excluded by Language' will be ignored")
						end
						
						if (task.HonorExcludeToolkit)
						begin
							Env.ExcludeToolkit = true
							Logging.VerboseLog(" - 'Excluded by Toolkit' will be honored")
						end
						
						if (task.HonorExcludeReportWriter)
						begin
							Env.ExcludeReport = true
							Logging.VerboseLog(" - 'Excluded by ReportWriter' will be honored")
						end
						
						if (task.HonorExcludeWeb)
						begin
							Env.ExcludeWeb = true
							Logging.VerboseLog(" - 'Excluded by Web' will be honored")
						end						
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;See if we have any special group processing filters specified
			
			if (!ErrStatus)
			begin
				;;Default to using both types of group field prefixes
				Env.GroupPrefix = true
				Env.GroupMemberPrefix = true
				
				if (task.GroupFieldNoGroupPrefix||task.GroupFieldNoRpsPrefix||task.GroupNoExpand)
				begin
					if (Env.GenFromWsc) then
					begin
						;;Can't specify group prefixes if we're processing a script file,
						;;the field names are determined by the script file.
						ErrStatus = Logging.Errorlog("Can't use group prefixes when processing a window script!")
					end
					else
					begin
						Logging.VerboseLog("Custom group rules in use")
						
						if (task.GroupFieldNoGroupPrefix)  ;;Do not prefix group fields with group name
						begin
							Env.GroupPrefix = false
							Logging.VerboseLog(" - Group members not prefixed with group field name")
						end
						
						if (task.GroupNoExpand)
						begin
							Env.DontExpandImplicitGroups = true
							Logging.VerboseLog(" - Implicit groups not expanded to individual fields")
						end
						
						if (task.GroupFieldNoRpsPrefix)  ;;Do not use repository group field prefix
						begin
							Env.GroupMemberPrefix = false
							Logging.VerboseLog(" - Repository group member prefix not used")
						end
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;Are we being asked to process multiple structures at the same time (in the same template)
			
			if (!ErrStatus && Env.RpsInUse && (task.MultipleStructures||((FileDef!=^null)&&(Structures.Count>1))))
			begin
				data structureToCheck, @RpsStructure
				
				;;Make sure that we have at least two structures
				if (Structures.Count<2) then
					ErrStatus = Logging.Errorlog("MultipleStructures property requires that you specify at least two structures in the Structures property!")
				else
				begin
					;;Check all of the structures and load them into the Env.CurrentStructures collection
					foreach structureToCheck in Structures
					begin
						if (!CheckStructure(structureToCheck))
						begin
							ErrStatus = true
							exitloop
						end
					end
					if (!ErrStatus)
					begin
						Env.CurrentStructures = Structures
						Env.FileIndexes = FileIndex
						Logging.VerboseLog("Processing "+string(Structures.Count)+" structures concurrently",true,false)
					end
				end
			end
			
			;;-------------------------------------------------------------------------
			;;We're good to go. Generate souce code
			
			if (!ErrStatus)
			begin
				if (Env.DeveloperDebug)
				begin
					Logging.DebugLog("------------------------------",true,false)
					Logging.DebugLog("DEVDBG: READY TO GENERATE CODE")
					Logging.DebugLog("------------------------------")
				end
				
				Logging.VerboseLog("")
				
				Env.OutputFiles = new List<String>()
				
				if ((!Env.RpsInUse)||(Env.CurrentStructures!=^null)) then
					call process_templates
				else
				begin
					for StrNum from 0 thru Structures.Count-1
					begin
						;;Check the structure, flatten arrays and groups, etc.
						if (CheckStructure(Structures[StrNum])) then
							Env.CurrentStructure = Structures[StrNum]
						else
							nextloop
						
						Env.FileIndex = FileIndex[StrNum+1]
						
						;;Generate code for this structure
						call process_templates
						
						Env.CurrentStructure = ^null
					end
				end
				
			end
			
			;;-------------------------------------------------------------------------
			;;Cleanup and exit
			
			clear Templates
			
			if (Env.FilesCreated&&Env.FilesFailed) then
			begin
				data msg, String, string(Env.FilesCreated) + " file"
				if (Env.FilesCreated>1)
					msg = msg + "s"
				msg = msg + " created, " + string(Env.FilesFailed) + " failed"
				Logging.Log(msg,(Env.Verbose||Env.Debug),false)
				
			end
			else if (Env.FilesCreated) then
			begin
				data msg, String, string(Env.FilesCreated) + " file"
				if (Env.FilesCreated>1)
					msg = msg + "s"
				msg = msg + " created"
				Logging.Log(msg,(Env.Verbose||Env.Debug),false)
			end
			else if (Env.FilesFailed)
			begin
				data msg, String, string(Env.FilesFailed) + " file"
				if (Env.FilesFailed>1)
					msg = msg + "s"
				msg = msg + " failed"
				Logging.Log(msg,(Env.Verbose||Env.Debug),false)
			end
			
			if (Env.ListFiles && (Env.OutputFiles.Count>0))
			begin
				data fileSpec, String
				foreach fileSpec in Env.OutputFiles
					Logging.Log(fileSpec)
			end
			
			mreturn (!ErrStatus)
			
			;;-------------------------------------------------------------------------------
			;;Iterate through the template files and generating code
			
		process_templates,
			
			;;Process each template
			data tmpTemplate, String
			foreach tmpTemplate in Templates
			begin
				Env.CurrentTemplate = tmpTemplate
				
				;;If we're processing multiple structures in the same template then make
				;;sure that context is set to the first structure for each template
				if (Env.CurrentStructures!=^null)
				begin
					Env.CurrentStructure = Env.CurrentStructures[0]
					Env.FileIndex = Env.FileIndexes[1]
				end
				
				;;Generate the code
				if (!Generate())
				begin
					;;If we had a failure in Generate then we'll mark the entire task as failed.
					ErrStatus = true
				end
				
				Env.CurrentTemplate = ""
			end
			
			return
			
		endmethod
		
		.region "Helper methods"
		
		;;;<summary>
		;;;Configures the basic environment by setting the environment variables
		;;;CODEGEN_EXE, CODEGEN_TPLDIR, CODEGEN_AUTHOR and CODEGEN_COMPANY
		;;;</summary>
		private method configureEnvironment, void
			endparams
		proc
			;;This code basically does what MAIN$CODEGEN normally does.
			
			data TxtLen		,int
			data TempString	,a256
			
			;;Explicitly set CODEGEN_EXE to the location of the running executable
			TempString = Path.GetDirectoryName(System.Reflection.Assembly.GetAssembly(^typeof(CodeGenerator)).Location)
			xcall setlog("CODEGEN_EXE",atrim(TempString),TxtLen)
			
			;;Is CODEGEN_TPLDIR already set in the environment?
			xcall getlog("CODEGEN_TPLDIR",TempString,TxtLen)
			if (!TxtLen)
			begin
				;;No, look in the registry for the value set by InstallShield
				data templateFolder, string
				data templateFolderFound, boolean, false
				
				templateFolder = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Synergex\CodeGen","TemplatePath","")
				if ((templateFolder!=^null)&&(templateFolder!="")) then
				begin
					;;Found it
					xcall setlog("CODEGEN_TPLDIR",templateFolder,TxtLen)
					templateFolderFound = true
				end
				else if (Environment.Is64BitProcess)
				begin
					;;Not found. If we're a 64-bit process then try looking in the 32-bit registry
					templateFolder = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Synergex\CodeGen","TemplatePath","")
					if ((templateFolder!=^null)&&(templateFolder!=""))
					begin
						;;Found it
						xcall setlog("CODEGEN_TPLDIR",templateFolder,TxtLen)
						templateFolderFound = true
					end
				end
				
				;;Still nothing - default to current directory
				if (!templateFolderFound)
					xcall setlog("CODEGEN_TPLDIR",".",TxtLen)
			end
			
			;;Is CODEGEN_AUTHOR already set in the environment?
			xcall getlog("CODEGEN_AUTHOR",TempString,TxtLen)
			if (TxtLen) then
				Env.Author = atrim(TempString)
			else
			begin
				;;No, look in the registry for the value set by InstallShield
				TempString = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Synergex\CodeGen","DefaultAuthor","")
				if (TempString) then
					Env.Author = atrim(TempString)
				else if (Environment.Is64BitProcess)
				begin
					;;Not found. If we're a 64-bit process then try looking in the 32-bit registry
					TempString = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Synergex\CodeGen","DefaultAuthor","")
					if (TempString)
						Env.Author = atrim(TempString)
				end
			end
			
			;;Is CODEGEN_COMPANY already set in the environment?
			xcall getlog("CODEGEN_COMPANY",TempString,TxtLen)
			if (TxtLen) then
				Env.Company = atrim(TempString)
			else
			begin
				;;No, look in the registry for the value set by InstallShield
				TempString = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Synergex\CodeGen","DefaultCompany","")
				if (TempString) then
					Env.Company = atrim(TempString)
				else if (Environment.Is64BitProcess)
				begin
					;;Not found. If we're a 64-bit process then try looking in the 32-bit registry
					TempString = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Synergex\CodeGen","DefaultCompany","")
					if (TempString)
						Env.Company = atrim(TempString)
				end
			end
			
		endmethod
		
		private method echoCommand, void
			required in task, @CodeGenTask
			endparams
		proc
			data command, String, "codegen "
			
			;;Templates
			if (task.Templates.Count>0)
			begin
				command += "-t "
				data tmp, String
				foreach tmp in task.Templates
					command += tmp + " "
			end
			
			;;Structures
			if (task.Structures.Count>0)
			begin
				command += "-s "
				data tmp, String
				foreach tmp in task.Structures
					command += tmp + " "
			end
			
			;;Processing multiple structures
			if (task.MultipleStructures)
				command += "-ms "
			
			;;Aliases
			if (task.Aliases.Count>0)
			begin
				command += "-a "
				data tmp, String
				foreach tmp in task.Aliases
					command += tmp + " "
			end
			
			;;File overrides
			if (task.FileOverrides.Count>0)
			begin
				command += "-fo "
				data tmp, String
				foreach tmp in task.FileOverrides
					command += tmp + " "
			end
			
			;;Subset
			if (!String.IsNullOrWhiteSpace(task.Subset))
				command += "-subset " + task.Subset + " "
			
			;;Repository file
			if (!String.IsNullOrWhiteSpace(task.RepositoryFile))
				command += "-file " + task.RepositoryFile + " "
			
			;;Window Script
			if (!String.IsNullOrWhiteSpace(task.WindowScript))
				command += "-w " + task.WindowScript + " "
			
			;;Ignore script field attributes
			if (task.IgnoreScriptFieldAttributes)
				command += "-wn "
			
			;;Selection window script
			if (!String.IsNullOrWhiteSpace(task.SelectionWindowScript))
				command += "-ws " + task.SelectionWindowScript + " "
			
			;;Replace files
			if (task.ReplaceFiles)
				command += "-r "
			
			;;Namespace
			if (!String.IsNullOrWhiteSpace(task.Namespace))
				command += "-n " + task.Namespace + " "
			
			;;Field prefix
			if (!String.IsNullOrWhiteSpace(task.FieldPrefix))
				command += "-prefix " + task.FieldPrefix + " "
			
			;;User token file
			if (!String.IsNullOrWhiteSpace(task.UserTokenFile))
				command += "-u " + task.UserTokenFile + " "
			
			;;Command line user tokens
			if (task.UserTokens.Count>0)
			begin
				command += "-ut "
				data tmp, @UserToken
				foreach tmp in task.UserTokens
					command += tmp.Name + "=" + tmp.Value + " "
			end
			
			;;
			if (task.IncludeOverlayFields)
				command += "-f o "
			
			;;
			if (task.IgnoreExcludeLanguage)
				command += "-f l "
			
			;;
			if (task.HonorExcludeToolkit)
				command += "-f t "
			
			;;
			if (task.HonorExcludeReportWriter)
				command += "-f r "
			
			;;
			if (task.HonorExcludeWeb)
				command += "-f w "
			
			;;
			if (task.GroupFieldNoGroupPrefix)
				command += "-g f "
			
			;;
			if (task.GroupFieldNoRpsPrefix)
				command += "-g r "
			
			;;
			if (task.GroupNoExpand)
				command += "-g i "
			
			;;
			if (task.AlwaysLoadDefaultButtons)
				command += "-b a "
			
			;;
			if (task.NeverLoadDefaultButtons)
				command += "-b d "
			
			;;
			if (task.NeverLoadAnyButtons)
				command += "-b n "
			
			;;Template folder
			if (!String.IsNullOrWhiteSpace(task.TemplateFolder))
				command += "-i " + task.TemplateFolder + " "
			
			;;Output folder
			if (!String.IsNullOrWhiteSpace(task.OutputFolder))
				command += "-o " + task.OutputFolder + " "
			
			;;Character width
			if (task.CharacterWidth!=12)
				command += "-cw " + task.CharacterWidth.ToString() + " "
			
			;;Character height
			if (task.CharacterHeight!=25)
				command += "-ch " + task.CharacterHeight.ToString() + " "
			
			if (mTaskSet.EchoCommands)
				command += "-e "
			
			using mTaskSet.LoggingLevel select
			(LoggingLevel.Verbose),
				command += "-v "
			(LoggingLevel.Debug),
				command += "-d "
			(LoggingLevel.DeveloperDebug),
				command += "-debug "
			endusing	
			
			Logging.Log(command,true,false)
			
		endmethod
		
		.endregion
		
	endclass
	
endnamespace

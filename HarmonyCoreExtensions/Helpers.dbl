
import System
import System.Collections.Generic
import System.Text
import CodeGen.Engine
import CodeGen.RepositoryAPI

namespace HarmonyCoreExtensions

	public static class Helpers
	
		public static method MatchRelationType, boolean

			required in tkn,            @Token
			required in template,       @FileNode 
			required in loops,          @IEnumerable<LoopNode>

			required in context,        @CodeGenContext
			required in fromStructure,  @RpsStructure
			required in relation,       @RpsRelation
			required in index,          int
			required in fromkey,        @RpsKey
			required in tostr,          @RpsStructure
			required in tokey,          @RpsKey

		proc
			
			data fkCleanFromKey, @RpsKey, fromkey
			if(fromkey.Name.StartsWith("FK_"))
			begin
				;;Remove the FK_ from the from the key name
				data fkCleanName = fromkey.Name.Substring(3)
				data fkDescr = fromkey.Description
				;;Locate the matching access key
				data fromStructureKey, @RpsKey
				foreach fromStructureKey in fromStructure.Keys
				begin
					if (fromStructureKey.Name == fkCleanName || string.Compare(fromStructureKey.Name, fkDescr, true) == 0)
					begin
						fkCleanFromKey = fromStructureKey
						exitloop
					end
				end
			end

			;I suspect the issue is here, fkCleanFromKey allows DUPS but our relation is many to one?

			data isOneToOneToOne = (tokey.Size == fkCleanFromKey.Size && fkCleanFromKey.Duplicates == RpsKeyDuplicates.NoDuplicates && tokey.Duplicates == RpsKeyDuplicates.NoDuplicates)
			data isOneToOne = ((tokey.Size < fkCleanFromKey.Size) || (tokey.Size == fkCleanFromKey.Size && tokey.Duplicates == RpsKeyDuplicates.NoDuplicates))

;                lambda getBackRelation(relation)
;                begin
;                    if(relation.ToStructure == fromStructure.Name)
;                    begin
;                        if(relation.ToKey.StartsWith("FK_") && relation.ToKey.Substring(3) == fromkey.Name)
;                            mreturn true
;
;                        if(relation.ToKey == fromkey.Name)
;                            mreturn true
;                    end
;
;                    mreturn false
;                end
			;;TODO: compiler bug here
			;;data isBackRelation = tostr.Relations.FirstOrDefault(getBackRelation)
			;;data isBackRelation, @RpsRelation, tostr.Relations.FirstOrDefault(getBackRelation)
			;;data hasBackRelation = (isBackRelation != ^null)
			data toRelation, @RpsRelation
			data hasBackRelation = false
			foreach toRelation in tostr.Relations
			begin
				if(toRelation.ToStructure == fromStructure.Name)
				begin
					if(toRelation.ToKey == fkCleanFromKey.Name)
						hasBackRelation = true
				end
			end

			using tkn.Value select
			("ONE_TO_ONE"),
				mreturn (isOneToOne && !hasBackRelation)
			("ONE_TO_MANY"),
				mreturn (!isOneToOne && !hasBackRelation)
			("ONE_TO_MANY_TO_ONE"),
				mreturn (!isOneToOne && hasBackRelation)
			("ONE_TO_ONE_TO_ONE"),
				mreturn (isOneToOneToOne && hasBackRelation)
			("MANY_TO_ONE_TO_MANY"),
				mreturn (isOneToOne && !isOneToOneToOne && hasBackRelation)
			endusing

			;;Should never get here!
			throw new ApplicationException(String.Format("Invalid expression token {0} encountered in evaluateRelationType()",tkn.Value))

		endmethod


	endclass

endnamespace
